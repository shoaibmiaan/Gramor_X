========== File 1: pages/api/ai/coach.ts ==========
// pages/api/ai/coach.ts
import type { NextApiRequest, NextApiResponse } from "next";
import { createClient } from "@supabase/supabase-js";

/* -------------------------------------------------------------------------- */
/* ENV expected (set in .env.local)                                           */
/* -------------------------------------------------------------------------- */
/*
GROQ_API_KEY=gsk-...
GROQ_API_BASE=https://api.groq.com/openai/v1
GROQ_MODEL=llama-3.3-70b-versatile

GEMINI_API_KEY=AIza...
GEMINI_API_BASE=https://generativelanguage.googleapis.com/v1beta/openai
GEMINI_MODEL=gemini-1.5-flash-latest

OPENAI_API_KEY=sk-...
OPENAI_API_BASE=https://api.openai.com/v1
OPENAI_MODEL=gpt-4o-mini

DEEPSEEK_API_KEY=sk-...
DEEPSEEK_API_BASE=https://api.deepseek.com
DEEPSEEK_MODEL=deepseek-chat

GROK_API_KEY=xai-...
GROK_API_BASE=https://api.x.ai/v1
GROK_MODEL=grok-4-latest

SUPABASE_URL=...
SUPABASE_SERVICE_ROLE_KEY=...
AI_MOCK=1            # optional for dev offline
*/

const supabaseAdmin = createClient(
  process.env.SUPABASE_URL!,
  process.env.SUPABASE_SERVICE_ROLE_KEY!
);

/* -------------------------------------------------------------------------- */
/* Provider chain                                                             */
/* -------------------------------------------------------------------------- */

type Prov = {
  name: "groq" | "gemini" | "openai" | "deepseek" | "grok";
  baseURL: string;
  apiKey?: string;
  model: string;
};

const PROVIDERS: Prov[] = [
  {
    name: "groq",
    baseURL: process.env.GROQ_API_BASE || "https://api.groq.com/openai/v1",
    apiKey: process.env.GROQ_API_KEY,
    model: process.env.GROQ_MODEL || "llama-3.3-70b-versatile",
  },
  {
    name: "gemini",
    baseURL:
      process.env.GEMINI_API_BASE ||
      "https://generativelanguage.googleapis.com/v1beta/openai",
    apiKey: process.env.GEMINI_API_KEY,
    model: process.env.GEMINI_MODEL || "gemini-1.5-flash-latest",
  },
  {
    name: "openai",
    baseURL: process.env.OPENAI_API_BASE || "https://api.openai.com/v1",
    apiKey: process.env.OPENAI_API_KEY,
    model: process.env.OPENAI_MODEL || "gpt-4o-mini",
  },
  {
    name: "deepseek",
    baseURL: process.env.DEEPSEEK_API_BASE || "https://api.deepseek.com",
    apiKey: process.env.DEEPSEEK_API_KEY,
    model: process.env.DEEPSEEK_MODEL || "deepseek-chat",
  },
  {
    name: "grok",
    baseURL: process.env.GROK_API_BASE || "https://api.x.ai/v1",
    apiKey: process.env.GROK_API_KEY,
    model: process.env.GROK_MODEL || "grok-4-latest",
  },
];

/* -------------------------------------------------------------------------- */
/* Helpers                                                                    */
/* -------------------------------------------------------------------------- */

const SYSTEM_PROMPT =
  "You are an IELTS coaching assistant. Provide concise actionable suggestions (3–6), each with a short title, a 1–2 sentence detail, and estimated minutes to practice. Output pure JSON only.";

function extractJSON(str: string): any {
  if (!str) return null;
  try {
    return JSON.parse(str);
  } catch {}
  const fence = str.match(/```(?:json)?\s*([\s\S]*?)```/i);
  if (fence) try { return JSON.parse(fence[1]); } catch {}
  const block = str.match(/\{[\s\S]*\}/);
  if (block) try { return JSON.parse(block[0]); } catch {}
  return { raw: str };
}

async function callProvider(p: Prov, payload: any) {
  if (!p.apiKey)
    return { ok: false, err: { status: 500, detail: `${p.name} key missing` }, provider: p.name };

  try {
    const r = await fetch(`${p.baseURL}/chat/completions`, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        Authorization: `Bearer ${p.apiKey}`,
      },
      body: JSON.stringify({ ...payload, model: p.model }),
    });

    const txt = await r.text();
    if (!r.ok)
      return {
        ok: false,
        err: { status: r.status, detail: (() => { try { return JSON.parse(txt); } catch { return txt; } })() },
        provider: p.name,
      };

    const json = JSON.parse(txt);
    const content =
      json?.choices?.[0]?.message?.content ??
      json?.choices?.[0]?.text ??
      "";

    if (!content.trim())
      return { ok: false, err: { status: 502, detail: "Empty content" }, provider: p.name };

    return { ok: true, content, provider: p.name };
  } catch (e: any) {
    return { ok: false, err: { status: 500, detail: e.message || String(e) }, provider: p.name };
  }
}

/* -------------------------------------------------------------------------- */
/* Handler                                                                    */
/* -------------------------------------------------------------------------- */

export default async function handler(req: NextApiRequest, res: NextApiResponse) {
  if (req.method !== "POST")
    return res.status(405).json({ error: "Method not allowed" });

  const { userId = null, context = "", goal = "" } = req.body ?? {};

  /* Mock mode --------------------------------------------------------------- */
  if (process.env.AI_MOCK === "1") {
    const mock = {
      id: "mock",
      summary: "Mock AI response — providers unavailable.",
      suggestions: [
        { id: "s1", title: "Plan paragraphs", detail: "Spend 5 min outlining key ideas.", estimatedMinutes: 10 },
        { id: "s2", title: "Add connectors", detail: "Use clear linkers to connect ideas.", estimatedMinutes: 8 },
        { id: "s3", title: "Rewrite one paragraph", detail: "Improve flow and coherence.", estimatedMinutes: 12 },
      ],
    };
    await supabaseAdmin.from("ai_logs").insert([
      { user_id: userId, request: JSON.stringify({ provider: "mock", context, goal }), response: JSON.stringify(mock), status: "ok" },
    ]);
    return res.status(200).json(mock);
  }

  const userPrompt = `User goal: ${goal}\nContext: ${context}\nReturn JSON: { id, summary, suggestions: [{id,title,detail,estimatedMinutes}], reasoning? }`;

  const payload = {
    messages: [
      { role: "system", content: SYSTEM_PROMPT },
      { role: "user", content: userPrompt },
    ],
    max_tokens: 700,
    temperature: 0.2,
  };

  const attempts: Array<{ provider: string; status?: number; detail?: any }> = [];

  for (const p of PROVIDERS) {
    const result = await callProvider(p, payload);

    if (result.ok) {
      const parsed = extractJSON(result.content);
      await supabaseAdmin.from("ai_logs").insert([
        {
          user_id: userId,
          request: JSON.stringify({ provider: result.provider, model: p.model, context, goal }),
          response: JSON.stringify(parsed),
          status: "ok",
        },
      ]);
      console.log(`[ai/coach] ✅ responded from ${result.provider}`);
      return res.status(200).json(parsed);
    }

    attempts.push({ provider: p.name, status: result.err?.status, detail: result.err?.detail });
    await supabaseAdmin.from("ai_logs").insert([
      {
        user_id: userId,
        request: JSON.stringify({ provider: p.name, model: p.model, context, goal }),
        response: JSON.stringify(result.err),
        status: "error",
      },
    ]);
    console.warn(`[ai/coach] ❌ ${p.name} failed`, result.err);
  }

  return res.status(502).json({ error: "All AI providers failed", attempts });
}



========== File 2: pages/api/ai/coach/action.ts ==========
import type { NextApiRequest, NextApiResponse } from 'next';
import { createClient } from '@supabase/supabase-js';

const supabase = createClient(SUPABASE_URL, SUPABASE_SERVICE_ROLE_KEY);

export default async function actionHandler(req: NextApiRequest, res: NextApiResponse) {
  if (req.method !== 'POST') return res.status(405).json({ error: 'Method not allowed' });
  const { suggestionId, userId = null } = req.body ?? {};
  try {
    await supabase.from('ai_actions').insert([{ user_id: userId, suggestion_id: suggestionId, created_at: new Date().toISOString() }]);
    return res.status(200).json({ success: true });
  } catch (e: any) {
    console.error('ai action insert', e);
    return res.status(500).json({ error: 'Failed to record action' });
  }
}



========== File 3: pages/api/ai/speaking/grade.ts ==========
import type { NextApiRequest, NextApiResponse } from 'next';
import { z } from 'zod';
import { createClient } from '@supabase/supabase-js';

const BodySchema = z.object({
  attemptId: z.string().optional(),   // if provided, we’ll look for a transcript or audio (future)
  transcript: z.string().optional(),  // if provided, we grade based on this text
});

type AIFeedback = {
  bandOverall: number;
  fluency: number;
  lexical: number;
  grammar: number;
  pronunciation: number;
  notes: string[];
};

type Resp = { ok: true; feedback: AIFeedback } | { ok: false; error: string };

const openaiModel = process.env.OPENAI_SPEAKING_MODEL || 'gpt-4o-mini';

export default async function handler(req: NextApiRequest, res: NextApiResponse<Resp>) {
  if (req.method !== 'POST') return res.status(405).json({ ok: false, error: 'Method not allowed' });

  const parse = BodySchema.safeParse(req.body);
  if (!parse.success) {
    return res.status(400).json({ ok: false, error: parse.error.issues.map(i => i.message).join(', ') });
  }
  const { attemptId, transcript } = parse.data;

  // 1) Try transcript (provided directly)
  let text = (transcript || '').trim();

  // 2) Fallback: if attemptId provided and `attempts_speaking.transcript` exists, use that
  if (!text && attemptId && process.env.NEXT_PUBLIC_SUPABASE_URL && (process.env.SUPABASE_SERVICE_ROLE_KEY || process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY)) {
    try {
      const supabase = createClient(
        process.env.NEXT_PUBLIC_SUPABASE_URL!,
        (process.env.SUPABASE_SERVICE_ROLE_KEY || process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY)!,
      );
      const { data } = await supabase.from('attempts_speaking').select('transcript').eq('id', attemptId).single();
      if (data?.transcript) text = String(data.transcript);
    } catch {
      // ignore
    }
  }

  // 3) Grade
  let feedback: AIFeedback;
  try {
    if (process.env.OPENAI_API_KEY && text) {
      feedback = await gradeWithOpenAI(text);
    } else {
      feedback = heuristic(text);
    }
  } catch {
    feedback = heuristic(text);
  }

  return res.status(200).json({ ok: true, feedback });
}

function heuristic(text: string): AIFeedback {
  const wc = text.trim() ? text.trim().split(/\s+/).length : 0;
  const base = 6 + Math.min(1, Math.max(0, (wc - 120) / 200));
  const band = clampHalf(base, 4, 9);
  return {
    bandOverall: band,
    fluency: clampHalf(band - 0.5, 4, 9),
    lexical: clampHalf(band, 4, 9),
    grammar: clampHalf(band - 0.5, 4, 9),
    pronunciation: clampHalf(band, 4, 9),
    notes: [
      'Maintain steady pace; avoid long pauses.',
      'Use more topic-specific vocabulary.',
      'Vary sentence structures; check articles and prepositions.',
      'Chunk ideas and use signposting (firstly, moreover).',
    ],
  };
}

async function gradeWithOpenAI(transcript: string): Promise<AIFeedback> {
  const prompt = `You are an IELTS Speaking examiner. Grade the following transcript.
Return ONLY JSON with keys: bandOverall, fluency, lexical, grammar, pronunciation, notes (array).
Transcript:
${transcript}
  `;
  const r = await fetch('https://api.openai.com/v1/chat/completions', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json', Authorization: `Bearer ${process.env.OPENAI_API_KEY}` },
    body: JSON.stringify({
      model: openaiModel,
      messages: [{ role: 'user', content: prompt }],
      temperature: 0.2,
      response_format: { type: 'json_object' },
    }),
  });
  if (!r.ok) throw new Error('OpenAI error');
  const json = await r.json();
  const content = json.choices?.[0]?.message?.content;
  const out = JSON.parse(content || '{}');

  const band = clampHalf(Number(out.bandOverall ?? 6), 4, 9);
  return {
    bandOverall: band,
    fluency: clampHalf(Number(out.fluency ?? band - 0.5), 4, 9),
    lexical: clampHalf(Number(out.lexical ?? band), 4, 9),
    grammar: clampHalf(Number(out.grammar ?? band - 0.5), 4, 9),
    pronunciation: clampHalf(Number(out.pronunciation ?? band), 4, 9),
    notes: Array.isArray(out.notes) ? out.notes.slice(0, 8) : ['Speak steadily and expand answers.'],
  };
}

const clampHalf = (n: number, min: number, max: number) => Math.max(min, Math.min(max, Math.round(n * 2) / 2));



========== File 4: pages/api/ai/writing/grade.ts ==========
import type { NextApiRequest, NextApiResponse } from 'next';
import { z } from 'zod';

// Optional: service-side Supabase (used only if you pass attemptId to persist)
import { createClient } from '@supabase/supabase-js';

const BodySchema = z.object({
  task1: z.string().min(1, 'task1 required'),
  task2: z.string().min(1, 'task2 required'),
  attemptId: z.string().optional(), // if provided, we'll persist AI feedback to attempts_writing.ai_feedback
});

type AIFeedback = {
  bandOverall: number;
  criteria: {
    taskAchievement: number;
    coherence: number;
    lexical: number;
    grammar: number;
  };
  notes: string[];
};

type Resp =
  | { ok: true; feedback: AIFeedback }
  | { ok: false; error: string };

const openaiModel = process.env.OPENAI_WRITING_MODEL || 'gpt-4o-mini';

export default async function handler(req: NextApiRequest, res: NextApiResponse<Resp>) {
  if (req.method !== 'POST') return res.status(405).json({ ok: false, error: 'Method not allowed' });

  const parse = BodySchema.safeParse(req.body);
  if (!parse.success) {
    return res.status(400).json({ ok: false, error: parse.error.issues.map(i => i.message).join(', ') });
  }
  const { task1, task2, attemptId } = parse.data;

  // Try OpenAI if key present, otherwise use heuristic
  let feedback: AIFeedback;
  try {
    if (process.env.OPENAI_API_KEY) {
      feedback = await gradeWithOpenAI(task1, task2);
    } else {
      feedback = heuristic(task1, task2);
    }
  } catch (e: any) {
    feedback = heuristic(task1, task2);
  }

  // Optional: persist to attempts_writing.ai_feedback if attemptId provided
  if (attemptId && process.env.NEXT_PUBLIC_SUPABASE_URL && (process.env.SUPABASE_SERVICE_ROLE_KEY || process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY)) {
    try {
      const supabase = createClient(
        process.env.NEXT_PUBLIC_SUPABASE_URL!,
        (process.env.SUPABASE_SERVICE_ROLE_KEY || process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY)!,
      );
      await supabase.from('attempts_writing').update({ ai_feedback: feedback }).eq('id', attemptId);
    } catch {
      // ignore persistence errors
    }
  }

  return res.status(200).json({ ok: true, feedback });
}

function heuristic(t1: string, t2: string): AIFeedback {
  const wc = (s: string) => (s.trim() ? s.trim().split(/\s+/).length : 0);
  const w1 = wc(t1), w2 = wc(t2);
  const base = 5.5 + Math.min(1.0, Math.max(0, (w1 - 150) / 300)) + Math.min(1.5, Math.max(0, (w2 - 250) / 500));
  const band = clampHalf(base, 4, 9);
  return {
    bandOverall: band,
    criteria: {
      taskAchievement: clampHalf(5 + (w1 >= 150 ? 1 : 0), 4, 9),
      coherence:  clampHalf(5.5 + (w2 >= 250 ? 0.5 : 0), 4, 9),
      lexical:    clampHalf(5.5, 4, 9),
      grammar:    clampHalf(5.5, 4, 9),
    },
    notes: [
      'Use clear topic sentences and logical paragraphing.',
      'Vary cohesive devices (however, furthermore, consequently).',
      'Aim for precise vocabulary; reduce repetition.',
      'Check complex sentences for agreement and punctuation.',
    ],
  };
}
const clampHalf = (n: number, min: number, max: number) => Math.max(min, Math.min(max, Math.round(n * 2) / 2));

async function gradeWithOpenAI(task1: string, task2: string): Promise<AIFeedback> {
  const prompt = `You are an IELTS examiner. Grade the two essays below. Return ONLY a compact JSON with keys:
  bandOverall (number 4-9, halves allowed),
  criteria { taskAchievement, coherence, lexical, grammar } (numbers with halves),
  notes (array of short coaching bullets).
  Essays:
  [Task 1]
  ${task1}

  [Task 2]
  ${task2}
  `;

  const r = await fetch('https://api.openai.com/v1/chat/completions', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json', Authorization: `Bearer ${process.env.OPENAI_API_KEY}` },
    body: JSON.stringify({
      model: openaiModel,
      messages: [{ role: 'user', content: prompt }],
      temperature: 0.2,
      response_format: { type: 'json_object' },
    }),
  });
  if (!r.ok) throw new Error('OpenAI error');
  const json = await r.json();
  const content = json.choices?.[0]?.message?.content;
  const out = JSON.parse(content);
  // Minimal shape guard
  return {
    bandOverall: clampHalf(Number(out.bandOverall ?? 6), 4, 9),
    criteria: {
      taskAchievement: clampHalf(Number(out?.criteria?.taskAchievement ?? 6), 4, 9),
      coherence: clampHalf(Number(out?.criteria?.coherence ?? 6), 4, 9),
      lexical: clampHalf(Number(out?.criteria?.lexical ?? 6), 4, 9),
      grammar: clampHalf(Number(out?.criteria?.grammar ?? 6), 4, 9),
    },
    notes: Array.isArray(out?.notes) ? out.notes.slice(0, 8) : ['Organize ideas clearly.', 'Use precise vocabulary.', 'Vary sentence structures.'],
  };
}



========== File 5: pages/api/activities/export.ts ==========
// pages/api/activities/export.ts
import { NextApiRequest, NextApiResponse } from 'next';
import { createClient } from '@supabase/supabase-js';
import { parse } from 'json2csv';

const supabaseAdmin = createClient(
  process.env.NEXT_PUBLIC_SUPABASE_URL!,
  process.env.SUPABASE_SERVICE_ROLE_KEY!
);

export default async function handler(req: NextApiRequest, res: NextApiResponse) {
  if (req.method !== 'GET') {
    return res.status(405).json({ error: 'Method not allowed' });
  }

  try {
    // Get user from auth token
    const authHeader = req.headers.authorization;
    if (!authHeader) {
      return res.status(401).json({ error: 'Unauthorized' });
    }

    const token = authHeader.replace('Bearer ', '');
    const { data: { user }, error: authError } = await supabaseAdmin.auth.getUser(token);

    if (authError || !user) {
      return res.status(401).json({ error: 'Unauthorized' });
    }

    // Fetch user activities
    const { data: activities, error } = await supabaseAdmin
      .from('user_activities')
      .select('*')
      .eq('user_id', user.id)
      .order('created_at', { ascending: false });

    if (error) {
      throw error;
    }

    // Format data for CSV
    const formattedActivities = activities.map(activity => ({
      Date: new Date(activity.created_at).toLocaleString(),
      Type: activity.activity_type.replace(/_/g, ' '),
      Description: activity.description,
      IP_Address: activity.ip_address,
      User_Agent: activity.user_agent,
      Metadata: JSON.stringify(activity.metadata),
      Related_Table: activity.related_table,
      Related_ID: activity.related_id,
    }));

    // Convert to CSV
    const csv = parse(formattedActivities);

    // Set headers for CSV download
    res.setHeader('Content-Type', 'text/csv');
    res.setHeader('Content-Disposition', `attachment; filename=gramorx-activities-${user.id}-${new Date().toISOString().split('T')[0]}.csv`);

    return res.status(200).send(csv);
  } catch (error) {
    console.error('Export error:', error);
    return res.status(500).json({ error: 'Failed to export activities' });
  }
}



========== File 6: pages/api/counters/increment.ts ==========
import type { NextApiRequest, NextApiResponse } from 'next';
import { z } from 'zod';
import { createClient } from '@supabase/supabase-js';

const BodySchema = z.object({
  counter: z.enum([
    'listening_attempts',
    'reading_attempts',
    'writing_ai_checks',
    'speaking_minutes',
  ]),
  delta: z.number().int().min(1).max(120),
});

type Resp = {
  ok: true;
  counter: string;
  current: number;
  limit: number;
  blocked: boolean;
} | { ok: false; error: string };

// Default free limits (per day). You can override via env vars later.
const FREE_LIMITS = {
  listening_attempts: Number(process.env.LIMIT_FREE_LISTENING ?? 1),
  reading_attempts: Number(process.env.LIMIT_FREE_READING ?? 1),
  writing_ai_checks: Number(process.env.LIMIT_FREE_WRITING_AI ?? 2),
  speaking_minutes: Number(process.env.LIMIT_FREE_SPEAKING_MIN ?? 10),
};
// Booster/Master limits (examples)
const BOOSTER_LIMITS = {
  listening_attempts: 999,
  reading_attempts: 999,
  writing_ai_checks: 50,
  speaking_minutes: 120,
};
const MASTER_LIMITS = {
  listening_attempts: 999,
  reading_attempts: 999,
  writing_ai_checks: 200,
  speaking_minutes: 240,
};

export default async function handler(req: NextApiRequest, res: NextApiResponse<Resp>) {
  if (req.method !== 'POST') return res.status(405).json({ ok: false, error: 'Method not allowed' });

  const parse = BodySchema.safeParse(req.body);
  if (!parse.success) return res.status(400).json({ ok: false, error: parse.error.issues.map(i => i.message).join(', ') });

  const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL!;
  const supabaseKey = process.env.SUPABASE_SERVICE_ROLE_KEY || process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY;
  if (!supabaseUrl || !supabaseKey) return res.status(503).json({ ok: false, error: 'Supabase env missing' });

  // Auth: require Bearer token so we know the user
  const token = (req.headers.authorization || '').replace(/^Bearer\s+/i, '');
  if (!token) return res.status(401).json({ ok: false, error: 'Missing Authorization bearer token' });

  const supabase = createClient(supabaseUrl, supabaseKey, { global: { headers: { Authorization: `Bearer ${token}` } } });
  const { data: userRes, error: userErr } = await supabase.auth.getUser();
  if (userErr || !userRes.user?.id) return res.status(401).json({ ok: false, error: 'Unauthorized' });
  const userId = userRes.user.id;

  const { counter, delta } = parse.data;

  // Determine plan & limits
  let plan: 'free'|'starter'|'booster'|'master' = 'free';
  try {
    const { data: profile } = await supabase.from('profiles').select('membership_plan').eq('id', userId).single();
    if (profile?.membership_plan) plan = profile.membership_plan as typeof plan;
  } catch { /* ignore */ }

  const limit = plan === 'master' ? MASTER_LIMITS[counter]
    : plan === 'booster' || plan === 'starter' ? BOOSTER_LIMITS[counter]
    : FREE_LIMITS[counter];

  // Read today's current
  const today = new Date().toISOString().slice(0, 10);
  const { data: row } = await supabase
    .from('usage_counters')
    .select('id,current')
    .eq('user_id', userId)
    .eq('counter', counter)
    .eq('date', today)
    .single();

  const current = row?.current ?? 0;
  const proposed = current + delta;
  const blocked = proposed > limit;

  if (!blocked) {
    if (row?.id) {
      await supabase.from('usage_counters').update({ current: proposed }).eq('id', row.id);
    } else {
      await supabase.from('usage_counters').insert({ user_id: userId, counter, date: today, current: proposed });
    }
  }

  return res.status(200).json({ ok: true, counter, current: blocked ? current : proposed, limit, blocked });
}



========== File 7: pages/api/premium/eligibility.ts ==========
// pages/api/premium/eligibility.ts
import type { NextApiRequest, NextApiResponse } from 'next';
import { createClient } from '@supabase/supabase-js';

type Resp = { eligible: boolean; plan: string | null; reason?: string };

export default async function handler(req: NextApiRequest, res: NextApiResponse<Resp>) {
  const token = req.headers.authorization?.split(' ')[1];
  if (!token) return res.status(200).json({ eligible: false, plan: null, reason: 'unauthenticated' });

  const supabase = createClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!
  );

  const { data: { user } } = await supabase.auth.getUser(token);
  if (!user) return res.status(200).json({ eligible: false, plan: null, reason: 'unauthenticated' });

  const { data: prof, error } = await supabase
    .from('profiles')
    .select('plan')
    .eq('id', user.id)
    .single();

  if (error) return res.status(200).json({ eligible: false, plan: null, reason: 'no_profile' });

  const plan = (prof?.plan ?? null) as string | null;
  const eligible = plan === 'premium' || plan === 'master';
  return res.status(200).json({ eligible, plan, reason: eligible ? undefined : 'plan_required' });
}



========== File 8: pages/api/premium/session.ts ==========
// pages/api/premium/session.ts
import type { NextApiRequest, NextApiResponse } from 'next';
import { createClient } from '@supabase/supabase-js';

type Resp = { ok: true; userId: string } | { ok: false; error: string };

export default async function handler(req: NextApiRequest, res: NextApiResponse<Resp>) {
  if (req.method !== 'POST') {
    res.setHeader('Allow', 'POST');
    return res.status(405).json({ ok: false, error: 'method-not-allowed' });
  }

  const token = req.headers.authorization?.split(' ')[1];
  if (!token) return res.status(401).json({ ok: false, error: 'no-token' });

  const supabase = createClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!
  );

  const { data: { user }, error } = await supabase.auth.getUser(token);
  if (error || !user) return res.status(401).json({ ok: false, error: 'invalid-token' });

  return res.status(200).json({ ok: true, userId: user.id });
}



========== File 9: pages/api/premium/status.ts ==========
// pages/api/premium/status.ts
import type { NextApiRequest, NextApiResponse } from 'next';
import { createClient } from '@supabase/supabase-js';

type Resp = {
  pinOk: boolean;
  loggedIn: boolean;
  userId: string | null;
  plan: string | null;
};

export default async function handler(req: NextApiRequest, res: NextApiResponse<Resp>) {
  const pinOk = req.cookies?.pr_pin_ok === '1';

  const token = req.headers.authorization?.split(' ')[1];
  if (!token) {
    return res.status(200).json({ pinOk, loggedIn: false, userId: null, plan: null });
  }

  const supabase = createClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!
  );

  const { data: { user } } = await supabase.auth.getUser(token);
  if (!user) {
    return res.status(200).json({ pinOk, loggedIn: false, userId: null, plan: null });
  }

  const { data: prof } = await supabase
    .from('profiles')
    .select('plan')
    .eq('id', user.id)
    .single();

  return res.status(200).json({
    pinOk,
    loggedIn: true,
    userId: user.id,
    plan: (prof?.plan ?? null) as string | null,
  });
}



========== File 10: pages/api/reading/dashboard.ts ==========
// pages/api/reading/dashboard.ts
import type { NextApiRequest, NextApiResponse } from 'next';

// Prefer your existing helper if present
// import { getServerClient } from '@/lib/supabaseServer';
import { createClient } from '@supabase/supabase-js';

// ---- Adjust these if your env helpers differ
const supabaseAdmin = () =>
  createClient(process.env.NEXT_PUBLIC_SUPABASE_URL as string, process.env.SUPABASE_SERVICE_ROLE_KEY as string, {
    auth: { persistSession: false },
  });

/**
 * Expected minimal columns:
 * reading_attempts: id, user_id, test_id, passage_id, created_at, duration_sec, score (0..1 or 0..100), correct_questions, total_questions
 * attempts_reading: attempt_id, question_id, correct (bool), time_sec
 * reading_questions: id, type ('tfng'|'mcq'|'matching'|'short'|...)
 * reading_passages: id, title, slug
 * reading_tests: id, title, slug
 * reading_user_stats (optional): user_id, streak_days, total_practices
 */

type AttemptRow = {
  id: string;
  user_id: string;
  test_id: string | null;
  passage_id: string | null;
  created_at: string;
  duration_sec: number | null;
  score: number | null; // 0..1 or 0..100
  correct_questions: number | null;
  total_questions: number | null;
};

type AttemptDetailRow = {
  attempt_id: string;
  question_id: string;
  correct: boolean | null;
  time_sec: number | null;
};

type QuestionRow = { id: string; type: string | null };
type PassageRow = { id: string; title: string | null; slug: string | null };
type TestRow = { id: string; title: string | null; slug: string | null };
type UserStatsRow = { user_id: string; streak_days: number | null; total_practices: number | null };

function normScore(a: AttemptRow): number | null {
  if (a == null) return null;
  if (typeof a.score === 'number') {
    // Heuristic: treat >1 as percentage
    return a.score > 1 ? a.score / 100 : a.score;
  }
  if (typeof a.correct_questions === 'number' && typeof a.total_questions === 'number' && a.total_questions > 0) {
    return a.correct_questions / a.total_questions;
  }
  return null;
}

export default async function handler(req: NextApiRequest, res: NextApiResponse) {
  try {
    const sb = supabaseAdmin();

    // ---- Get user from a bearer cookie/session (if you gate with RLS, keep this).
    // Service role is used above for simplicity, but if you prefer per-request auth:
    // const supa = getServerClient(req, res);
    // const { data: { user } } = await supa.auth.getUser();

    // If you want to require auth, flip allowGuest to false
    const allowGuest = true;

    // Try to infer user via a light JWT in Authorization, else treat as guest
    let userId: string | null = null;
    try {
      const auth = req.headers.authorization || '';
      if (auth.startsWith('Bearer ')) {
        const token = auth.slice(7);
        const { data, error } = await sb.auth.getUser(token);
        if (!error && data?.user) userId = data.user.id;
      }
    } catch {
      // ignore; we'll be guest
    }

    if (!userId && !allowGuest) {
      return res.status(401).json({ error: 'not_authenticated' });
    }

    // ---- Fetch attempts (latest first)
    const attemptsQ = sb
      .from('reading_attempts')
      .select('id,user_id,test_id,passage_id,created_at,duration_sec,score,correct_questions,total_questions')
      .order('created_at', { ascending: false })
      .limit(60);

    const { data: attemptsRaw, error: attemptsErr } = await attemptsQ;
    if (attemptsErr) {
      // Don’t explode the UI — return empty, plus an informational hint
      return res.status(200).json({
        kpis: { bandEstimate: null, bandStd: null, accuracy10: null, accuracyDelta10: null, avgSecPerQ: null, streakDays: null, totalPractices: null },
        trend: [],
        byType: [],
        timeVsScore: [],
        weakAreas: [],
        recent: [],
        saved: [],
        queued: [],
        note: 'reading_attempts query failed',
      });
    }

    const attempts: AttemptRow[] = (attemptsRaw ?? []) as any;
    const latest = attempts.slice(0, 20);

    // ---- Batch fetch per-question results for last ~200 details
    const latestIds = latest.map((a) => a.id);
    let details: AttemptDetailRow[] = [];
    if (latestIds.length) {
      const { data: det, error: detErr } = await sb
        .from('attempts_reading')
        .select('attempt_id,question_id,correct,time_sec')
        .in('attempt_id', latestIds)
        .limit(1000);
      if (!detErr && det) details = det as any;
    }

    // ---- Fetch question types for involved questions
    const qIds = Array.from(new Set(details.map((d) => d.question_id)));
    let questions: Record<string, string | null> = {};
    if (qIds.length) {
      const { data: qRows, error: qErr } = await sb
        .from('reading_questions')
        .select('id,type')
        .in('id', qIds)
        .limit(2000);
      if (!qErr && qRows) {
        for (const q of qRows as QuestionRow[]) questions[q.id] = q.type;
      }
    }

    // ---- Simple resource titles (passage/test)
    const passageIds = Array.from(new Set(attempts.map((a) => a.passage_id).filter(Boolean))) as string[];
    const testIds = Array.from(new Set(attempts.map((a) => a.test_id).filter(Boolean))) as string[];

    let passagesById: Record<string, PassageRow> = {};
    if (passageIds.length) {
      const { data: pRows } = await sb.from('reading_passages').select('id,title,slug').in('id', passageIds).limit(2000);
      (pRows ?? []).forEach((p: any) => (passagesById[p.id] = p));
    }

    let testsById: Record<string, TestRow> = {};
    if (testIds.length) {
      const { data: tRows } = await sb.from('reading_tests').select('id,title,slug').in('id', testIds).limit(2000);
      (tRows ?? []).forEach((t: any) => (testsById[t.id] = t));
    }

    // ---- Optional user stats
    let userStats: UserStatsRow | null = null;
    if (userId) {
      const { data: us } = await sb.from('reading_user_stats').select('user_id,streak_days,total_practices').eq('user_id', userId).maybeSingle();
      userStats = (us as any) || null;
    }

    // ---- Compute KPIs
    const last10 = attempts.slice(0, 10);
    const last10Scores = last10.map(normScore).filter((n): n is number => n != null);
    const accuracy10 = last10Scores.length ? avg(last10Scores) : null;

    const prev10 = attempts.slice(10, 20);
    const prev10Scores = prev10.map(normScore).filter((n): n is number => n != null);
    const accuracyPrev10 = prev10Scores.length ? avg(prev10Scores) : null;
    const accuracyDelta10 =
      typeof accuracy10 === 'number' && typeof accuracyPrev10 === 'number' ? accuracy10 - accuracyPrev10 : null;

    const allScores = attempts.map(normScore).filter((n): n is number => n != null);
    const bandEstimate = allScores.length ? toBand(avg(allScores)) : null;
    const bandStd = allScores.length > 1 ? stddev(allScores.map(toBand)) : null;

    // average seconds per question over last 20 with Q data
    const timeDenoms = latest
      .map((a) => {
        const n = typeof a.total_questions === 'number' && a.total_questions > 0 ? a.total_questions : null;
        const dur = typeof a.duration_sec === 'number' ? a.duration_sec : null;
        return { dur, n };
      })
      .filter((x) => x.dur != null && x.n != null);
    const avgSecPerQ =
      timeDenoms.length ? Math.round(avg(timeDenoms.map((x) => (x.dur as number) / (x.n as number)))) : null;

    const streakDays = userStats?.streak_days ?? null;
    const totalPractices = userStats?.total_practices ?? attempts.length;

    // ---- Trend (last 20)
    const trend = latest.map((a) => ({ date: a.created_at, score: normScore(a) ?? 0 }));

    // ---- By type (heatmap) from attempts_reading + reading_questions
    const byTypeAgg: Record<string, { correct: number; total: number }> = {};
    for (const d of details) {
      const t = (questions[d.question_id] || 'unknown')?.toLowerCase();
      if (!byTypeAgg[t]) byTypeAgg[t] = { correct: 0, total: 0 };
      byTypeAgg[t].total += 1;
      if (d.correct) byTypeAgg[t].correct += 1;
    }
    const byType = Object.entries(byTypeAgg)
      .map(([type, v]) => ({
        type,
        accuracy: v.total > 0 ? v.correct / v.total : 0,
        attempts: v.total,
      }))
      .sort((a, b) => a.accuracy - b.accuracy); // weakest first

    // ---- Time vs score (from attempts)
    const timeVsScore = latest
      .map((a) => ({
        id: a.id,
        minutes: Math.max(1, Math.round(((a.duration_sec ?? 0) / 60) * 10) / 10),
        score: normScore(a) ?? 0,
      }))
      .filter((x) => Number.isFinite(x.minutes) && Number.isFinite(x.score));

    // ---- Recent table (last 7)
    const recent = attempts.slice(0, 7).map((a) => {
      const pass = a.passage_id ? passagesById[a.passage_id] : null;
      const test = a.test_id ? testsById[a.test_id] : null;
      const title = pass?.title || test?.title || 'Reading practice';
      const slug = pass?.slug || test?.slug || a.id;
      const hrefReview = pass?.slug
        ? `/reading/${pass.slug}#review`
        : test?.slug
        ? `/reading/${test.slug}#review`
        : `/reading/${slug}#review`;
      return {
        slug: String(slug),
        title: String(title),
        date: a.created_at,
        score: normScore(a) ?? 0,
        minutes: Math.max(1, Math.round(((a.duration_sec ?? 0) / 60) * 10) / 10),
        types: [], // could be filled from details if you want
        hrefReview,
      };
    });

    // ---- Weak areas (top 2 weakest)
    const weakAreas =
      byType.length >= 2
        ? byType.slice(0, 2).map((w) => ({
            label: w.type,
            reason: `Accuracy ${Math.round(w.accuracy * 100)}% over ${w.attempts} Qs`,
            href: `/reading?type=${encodeURIComponent(w.type)}`,
          }))
        : [];

    // ---- Response
    return res.status(200).json({
      kpis: {
        bandEstimate,
        bandStd,
        accuracy10,
        accuracyDelta10,
        avgSecPerQ,
        streakDays,
        totalPractices,
      },
      trend,
      byType,
      timeVsScore,
      weakAreas,
      recent,
      saved: [], // integrate when you add a "saved" table
      queued: [], // integrate with a "queue" table
    });
  } catch (e: any) {
    return res.status(200).json({
      kpis: { bandEstimate: null, bandStd: null, accuracy10: null, accuracyDelta10: null, avgSecPerQ: null, streakDays: null, totalPractices: null },
      trend: [],
      byType: [],
      timeVsScore: [],
      weakAreas: [],
      recent: [],
      saved: [],
      queued: [],
      note: e?.message || 'Unhandled',
    });
  }
}

// ---- helpers
function avg(xs: number[]) {
  return xs.reduce((a, b) => a + b, 0) / Math.max(1, xs.length);
}
function stddev(xs: number[]) {
  const m = avg(xs);
  const v = avg(xs.map((x) => (x - m) ** 2));
  return Math.sqrt(v);
}
function toBand(p: number) {
  // Simple mapping: 0..1 -> 4.0..9.0 (tweak if you have a calibrated curve)
  return 4 + p * 5;
}



========== File 11: pages/api/study-buddy/sessions.ts ==========
// pages/api/study-buddy/sessions.ts
import type { NextApiRequest, NextApiResponse } from 'next';
import { createClient } from '@supabase/supabase-js';
import { v4 as uuidv4, validate as uuidValidate } from 'uuid';
import { z } from 'zod';

type StudySessionItem = { skill: string; minutes: number; topic?: string | null; status?: 'pending' | 'started' | 'completed'; note?: string | null };
type StudySessionRecord = {
  id: string;
  user_id: string | null;
  items: StudySessionItem[];
  state: 'pending' | 'started' | 'completed' | 'cancelled';
  created_at: string;
  updated_at: string;
  started_at: string | null;
  ended_at: string | null;
  duration_minutes: number | null;
  xp_earned: number;
};

const SUPABASE_URL = process.env.SUPABASE_URL;
const SUPABASE_SERVICE_ROLE_KEY = process.env.SUPABASE_SERVICE_ROLE_KEY;

function getAdminClient() {
  if (!SUPABASE_URL || !SUPABASE_SERVICE_ROLE_KEY) {
    throw new Error('Missing SUPABASE_URL / SUPABASE_SERVICE_ROLE_KEY in environment.');
  }
  return createClient(SUPABASE_URL, SUPABASE_SERVICE_ROLE_KEY);
}

function normalizeUserId(raw?: any): string | null {
  if (!raw || typeof raw !== 'string') return null;
  const trimmed = raw.trim();
  if (trimmed.toLowerCase() === 'null') return null;
  return uuidValidate(trimmed) ? trimmed : null;
}

const Body = z.object({
  userId: z.string().uuid().optional().nullable(),
  items: z.array(
    z.object({
      skill: z.string().min(1).max(64),
      minutes: z.number().int().min(1).max(300),
    })
  ).min(1).max(200),
});

export default async function handler(req: NextApiRequest, res: NextApiResponse) {
  if (req.method !== 'POST') {
    res.setHeader('Allow', 'POST');
    return res.status(405).json({ error: 'method_not_allowed' });
  }

  const parsed = Body.safeParse(req.body ?? {});
  if (!parsed.success) {
    return res.status(400).json({ error: 'invalid_body', details: parsed.error.flatten() });
  }

  const { items } = parsed.data;
  const user_id = normalizeUserId(parsed.data.userId ?? undefined);

  let supabaseAdmin;
  try {
    supabaseAdmin = getAdminClient();
  } catch (err: any) {
    console.error('[study-sessions] admin client error', err);
    return res.status(500).json({ error: 'supabase_not_configured' });
  }

  const id = uuidv4();
  const now = new Date().toISOString();

  const normalizedItems = items.map((item) => ({
    skill: item.skill,
    minutes: item.minutes,
    topic: null,
    status: 'pending' as const,
    note: null,
  }));

  const totalMinutes = normalizedItems.reduce((sum, item) => sum + item.minutes, 0);

  const payload: StudySessionRecord = {
    id,
    user_id,
    items: normalizedItems,
    state: 'pending',
    created_at: now,
    updated_at: now,
    started_at: null,
    ended_at: null,
    duration_minutes: totalMinutes,
    xp_earned: 0,
  };

  try {
    const { data, error, status, statusText } = await supabaseAdmin
      .from<StudySessionRecord>('study_buddy_sessions')
      .insert(payload)
      .select('*');

    if (error) {
      console.error('[study-sessions] insert error:', { error, status, statusText });
      const message = (error && (error.message || JSON.stringify(error))) ?? 'db_insert_failed';
      return res.status(500).json({ error: message });
    }

    const inserted = Array.isArray(data) && data.length > 0 ? data[0] : payload;
    return res.status(201).json(inserted);
  } catch (err: any) {
    console.error('[study-sessions] unexpected exception', err);
    const info = (err && err.message) ? String(err.message) : 'unknown_error';
    return res.status(500).json({ error: info });
  }
}



========== File 12: pages/api/check-otp.ts ==========
import type { NextApiRequest, NextApiResponse } from 'next';
import { z } from 'zod';
import Twilio from 'twilio';
import { createClient } from '@supabase/supabase-js';
import { env } from '@/lib/env';
import { rateLimit } from '@/lib/rateLimit';

const client = Twilio(env.TWILIO_ACCOUNT_SID, env.TWILIO_AUTH_TOKEN);
const SERVICE_SID = env.TWILIO_VERIFY_SERVICE_SID;
const supa = createClient(env.SUPABASE_URL, env.SUPABASE_SERVICE_KEY); // server only

const BodySchema = z.object({
  phone: z.string(),
  code: z.string(),
});

export type CheckOtpResponse =
  | { ok: true; message: string }
  | { ok: false; error: string };

export default async function checkOtp(
  req: NextApiRequest,
  res: NextApiResponse<CheckOtpResponse>
) {
  if (req.method !== 'POST') {
    res.setHeader('Allow', 'POST');
    throw new Error('Method Not Allowed');
  }

  if (!(await rateLimit(req, res))) return;

  const result = BodySchema.safeParse(req.body);
  if (!result.success) {
    return res
      .status(400)
      .json({ ok: false, error: 'Invalid request body' });
  }

  const { phone, code } = result.data;
  try {
    const check = await client.verify
      .services(SERVICE_SID)
      .verificationChecks.create({ to: phone, code });
    if (check.status !== 'approved') {
      return res.status(400).json({ ok: false, error: 'Invalid code' });
    }

    const { error: supErr } = await supa
      .from('profiles')
      .upsert({ phone, phone_verified: true, updated_at: new Date() });

    if (supErr) {
      if ((supErr as any).code === 'user_not_found') {
        return res
          .status(404)
          .json({ ok: false, error: 'No account found for that email/phone.' });
      }
      return res.status(500).json({ ok: false, error: (supErr as any).message });
    }

    return res.json({ ok: true, message: 'Phone verified' });
  } catch (err) {
    const message = err instanceof Error ? err.message : 'Unknown error';
    return res.status(500).json({ ok: false, error: message });
  }
}



========== File 13: pages/api/streak.ts ==========
import { NextApiRequest, NextApiResponse } from 'next';
import { createClient, type SupabaseClient } from '@supabase/supabase-js';
import { supabaseService, supabaseServer } from '@/lib/supabaseServer';

const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL!;
const supabaseAnonKey = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!;

export type StreakData = {
  current_streak: number;
  longest_streak: number;
  last_activity_date: string | null; // YYYY-MM-DD
  next_restart_date: string | null;  // not persisted on 'streaks' table
  shields: number;                   // not persisted on 'streaks' table
};

const getDayKey = (d = new Date()) => d.toISOString().split('T')[0];
const ms = (h: number) => h * 60 * 60 * 1000;

export default async function handler(req: NextApiRequest, res: NextApiResponse) {
  let token = req.headers.authorization?.split(' ')[1] ?? null;
  let refreshToken: string | null = null;

  if (!token) {
    try {
      const cookieClient = supabaseServer(req);
      const { data, error } = await cookieClient.auth.getSession();
      if (error) {
        console.error('[API/streak] Cookie session lookup failed:', error);
      }
      token = data?.session?.access_token ?? null;
      refreshToken = data?.session?.refresh_token ?? null;
    } catch (error) {
      console.error('[API/streak] Cookie session client unavailable:', error);
    }
  }

  if (!token) return res.status(401).json({ error: 'No authorization token' });

  // RLS client (acts as the user)
  let supabaseUser: SupabaseClient;
  try {
    supabaseUser = createClient(supabaseUrl, supabaseAnonKey, {
      auth: { autoRefreshToken: false, persistSession: false },
    });
  } catch (error) {
    console.error('[API/streak] User client creation failed:', error);
    return res.status(503).json({ error: 'service_unavailable' });
  }

  try {
    await supabaseUser.auth.setSession({
      access_token: token,
      refresh_token: refreshToken ?? '',
    });
  } catch (error) {
    console.error('[API/streak] User session setup failed:', error);
    return res.status(503).json({ error: 'service_unavailable' });
  }

  let user = null;
  try {
    const { data: { user: authUser }, error: authError } = await supabaseUser.auth.getUser();
    if (authError || !authUser) return res.status(401).json({ error: 'Invalid token' });
    user = authUser;
  } catch (error) {
    console.error('[API/streak] Auth verification failed:', error);
    return res.status(503).json({ error: 'auth_unavailable' });
  }

  try {
    // Read current row (aliases to expected keys)
    let { data: row, error: fetchError } = await supabaseUser
      .from('streaks')
      .select('user_id,current_streak:current,longest_streak:longest,last_activity_date:last_active_date,updated_at')
      .eq('user_id', user.id)
      .maybeSingle();

    if (fetchError && fetchError.code !== 'PGRST116') throw fetchError;

    // If no row, create one
    const baseInsert = { user_id: user.id, current: 0, longest: 0, last_active_date: null, updated_at: null };

    if (!row) {
      const { data: inserted, error: insertError } = await supabaseUser
        .from('streaks')
        .insert(baseInsert)
        .select('user_id,current_streak:current,longest_streak:longest,last_activity_date:last_active_date,updated_at')
        .single();
      if (insertError) {
        console.error('[API/streak] Insert failed:', insertError);

        const shouldRetryWithService =
          insertError?.code === '42501' || insertError?.message?.includes('row-level security');

        if (shouldRetryWithService) {
          try {
            const svc = supabaseService();
            const { data: serviceInserted, error: serviceErr } = await svc
              .from('streaks')
              .insert(baseInsert)
              .select('user_id,current_streak:current,longest_streak:longest,last_activity_date:last_active_date,updated_at')
              .single();

            if (serviceErr) {
              console.error('[API/streak] Service insert failed:', serviceErr);
            } else {
              row = serviceInserted ?? row;
            }
          } catch (serviceClientError) {
            console.error('[API/streak] Service client unavailable for insert:', serviceClientError);
          }
        }

        // Fallback: treat as new streak of 0 when all attempts fail
        if (!row) {
          row = {
            user_id: user.id,
            current_streak: 0,
            longest_streak: 0,
            last_activity_date: null,
            updated_at: null,
          } as typeof row;
        }
      } else {
        row = inserted;
      }
    }

    let shieldTokens = 0;
    try {
      const { data: shieldRow } = await supabaseUser
        .from('streak_shields')
        .select('tokens')
        .eq('user_id', user.id)
        .maybeSingle();
      shieldTokens = shieldRow?.tokens ?? 0;
    } catch (shieldErr) {
      console.warn('[API/streak] Unable to load shields', shieldErr);
      shieldTokens = 0;
    }

    // Build response object (shields/next_restart_date are not stored on this table)
    const asResponse = (r: typeof row, shields = shieldTokens): StreakData => ({
      current_streak: r?.current_streak ?? 0,
      longest_streak: r?.longest_streak ?? r?.current_streak ?? 0,
      last_activity_date: r?.last_activity_date ?? null,
      next_restart_date: null,
      shields,
    });

    if (req.method === 'GET') {
      return res.status(200).json(asResponse(row));
    }

    if (req.method === 'POST') {
      const { action, date } = req.body as { action?: 'use' | 'claim' | 'schedule'; date?: string };

      const now = new Date();
      const today = getDayKey(now);
      const previousCurrent = row.current_streak ?? 0;

      if (action === 'claim') {
        const nextTokens = shieldTokens + 1;
        try {
          const { data: updatedShield, error: shieldErr } = await supabaseUser
            .from('streak_shields')
            .upsert({ user_id: user.id, tokens: nextTokens }, { onConflict: 'user_id' })
            .select('tokens')
            .single();
          if (shieldErr) throw shieldErr;
          shieldTokens = updatedShield?.tokens ?? nextTokens;
          await supabaseUser.from('streak_shield_logs').insert({ user_id: user.id, action: 'claim' });
        } catch (err) {
          console.error('[API/streak] Claim shield failed', err);
          return res.status(500).json({ error: 'Failed to claim shield' });
        }
        return res.status(200).json(asResponse(row, shieldTokens));
      }

      if (action === 'schedule') {
        if (!date) return res.status(400).json({ error: 'Date required for scheduling' });
        return res.status(200).json({ ...asResponse(row, shieldTokens), next_restart_date: date });
      }

      const spentShield = action === 'use';
      if (spentShield && shieldTokens <= 0) {
        return res.status(400).json({ error: 'No shields available' });
      }

      if (!spentShield && row.last_activity_date === today) {
        return res.status(200).json(asResponse(row, shieldTokens));
      }

      const lastTs = row.updated_at ? new Date(row.updated_at) : null;
      const within24h = lastTs ? now.getTime() - lastTs.getTime() <= ms(24) : false;

      let newCurrent = 1;
      if (spentShield) {
        newCurrent = previousCurrent + 1;
      } else if (within24h) {
        newCurrent = previousCurrent + 1;
      } else {
        newCurrent = 1;
      }

      const previousLongest = row.longest_streak ?? row.current_streak ?? 0;
      const newLongest = Math.max(previousLongest, newCurrent);

      const { data: updatedRow, error: upErr } = await supabaseUser
        .from('streaks')
        .update({
          current: newCurrent,
          longest: newLongest,
          last_active_date: today,
          updated_at: now.toISOString(),
        })
        .eq('user_id', user.id)
        .select('user_id,current_streak:current,longest_streak:longest,last_activity_date:last_active_date,updated_at')
        .single();

      if (upErr) {
        console.error('[API/streak] Update failed:', upErr);
        return res.status(200).json(asResponse(row, shieldTokens));
      }

      let tokensDelta = 0;
      if (spentShield) tokensDelta -= 1;
      if (newCurrent > previousCurrent && newCurrent % 7 === 0) tokensDelta += 1;

      let nextTokens = shieldTokens;
      if (tokensDelta !== 0) {
        nextTokens = Math.max(0, shieldTokens + tokensDelta);
        try {
          const { data: shieldRow, error: shieldUpdateErr } = await supabaseUser
            .from('streak_shields')
            .upsert({ user_id: user.id, tokens: nextTokens }, { onConflict: 'user_id' })
            .select('tokens')
            .single();
          if (shieldUpdateErr) {
            console.error('[API/streak] Failed to update shields', shieldUpdateErr);
          } else {
            nextTokens = shieldRow?.tokens ?? nextTokens;
          }
        } catch (shieldUpdateError) {
          console.error('[API/streak] Shield upsert failed', shieldUpdateError);
        }
      }

      if (spentShield) {
        await supabaseUser.from('streak_shield_logs').insert({ user_id: user.id, action: 'use' });
      }
      if (tokensDelta > 0) {
        await supabaseUser.from('streak_shield_logs').insert({ user_id: user.id, action: 'claim' });
      }

      return res.status(200).json(asResponse(updatedRow, nextTokens));
    }

    return res.status(405).json({ error: 'Method not allowed' });
  } catch (err: any) {
    console.error('[API/streak] Error:', err);
    return res.status(500).json({ error: err.message || 'Internal server error' });
  }
}



========== File 14: lib/authServer.ts ==========
import { env } from "@/lib/env";
// lib/authServer.ts
import type { NextApiRequest } from 'next';
import { createClient } from '@supabase/supabase-js';

const URL = env.NEXT_PUBLIC_SUPABASE_URL;
const ANON = env.NEXT_PUBLIC_SUPABASE_ANON_KEY;
const SERVICE = env.SUPABASE_SERVICE_ROLE_KEY || '';

function b64urlToJson(b64: string) {
  const pad = (s:string) => s + '=' * ((4 - (s.length % 4)) % 4);
  const str = Buffer.from(pad(b64).replace(/-/g,'+').replace(/_/g,'/'), 'base64').toString('utf8');
  return JSON.parse(str);
}
function decodeUserId(token: string | null): string | null {
  if (!token) return null;
  try {
    const [_, payload] = token.split('.');
    const p = b64urlToJson(payload);
    return p.sub || p.user_id || null;
  } catch { return null; }
}

export type ServerAuth = {
  user: { id: string; email?: string } | null;
  supabaseDb: ReturnType<typeof createClient>;
  supabaseAuth: ReturnType<typeof createClient>;
  token: string | null;
};

export async function getUserServer(req: NextApiRequest): Promise<ServerAuth> {
  const authHeader = (req.headers.authorization as string) || '';
  const token = authHeader.startsWith('Bearer ') ? authHeader.slice(7) : null;

  // Client used for auth/RLS-aware queries (carries the bearer)
  const supabaseAuth = createClient(URL, ANON, { global: { headers: { Authorization: authHeader } } });

  // Client used for storage/DB writes; prefers service role (bypasses RLS)
  const supabaseDb = SERVICE ? createClient(URL, SERVICE) : supabaseAuth;

  let userId: string | null = null;
  try {
    if (token) {
      const { data } = await supabaseAuth.auth.getUser(token);
      userId = data?.user?.id ?? decodeUserId(token);
    }
  } catch {
    userId = decodeUserId(token);
  }

  return { user: userId ? { id: userId } : null, supabaseDb, supabaseAuth, token };
}



========== File 15: lib/supabaseAdmin.ts ==========
// lib/supabaseAdmin.ts
// Server-only Supabase admin (service-role) client with HMR-safe caching.

import { createClient, type SupabaseClient } from '@supabase/supabase-js';
import { env } from '@/lib/env';

// Accept either server or public URL (both point to the same project)
const url = env.SUPABASE_URL || env.NEXT_PUBLIC_SUPABASE_URL;

// Accept either name for the service key
const serviceRoleKey = env.SUPABASE_SERVICE_ROLE_KEY || env.SUPABASE_SERVICE_KEY;

const isServer = typeof window === 'undefined';
const isProdRuntime =
  typeof process !== 'undefined' &&
  process.env.NODE_ENV === 'production' &&
  process.env.VERCEL_ENV === 'production';

if (isServer && process.env.NODE_ENV !== 'test') {
  if (!url || !serviceRoleKey) {
    if (isProdRuntime) {
      if (!url) {
        throw new Error('Missing SUPABASE_URL (or NEXT_PUBLIC_SUPABASE_URL fallback)');
      }
      if (!serviceRoleKey) {
        throw new Error('Missing SUPABASE_SERVICE_ROLE_KEY (or SUPABASE_SERVICE_KEY)');
      }
    } else {
      console.warn(
        'Supabase admin credentials not fully configured. Falling back to stub admin client.',
      );
    }
  }
}

/** Lightweight test stub for CI/test where keys are intentionally absent */
function makeAdminTestStub(): SupabaseClient<any, 'public', any> {
  const fromHandler = (_table: string) => ({
    async insert(rows: any) {
      const toArr = Array.isArray(rows) ? rows : [rows];
      return { data: toArr.map((r: any, i: number) => ({ id: `stub-${i + 1}`, ...r })), error: null };
    },
    async select(_cols?: string) { return { data: [], error: null }; },
    async update(_rows: any) { return { data: null, error: null }; },
    async delete() { return { data: null, error: null }; },
    eq() { return this; },
    order() { return this; },
  });

  return {
    // @ts-expect-error minimal stub
    from: fromHandler,
    auth: {
      // @ts-expect-error minimal stub
      getUser: async () => ({ data: { user: null }, error: null }),
      // @ts-expect-error minimal stub
      getSession: async () => ({ data: { session: null }, error: null }),
    },
  };
}

declare global {
  // eslint-disable-next-line no-var
  var __supabaseAdmin: SupabaseClient | undefined;
}

export const supabaseAdmin: SupabaseClient =
  globalThis.__supabaseAdmin ??
  (() => {
    if (!isServer) {
      // Never expose service-role credentials in the browser; fall back to stub behaviour.
      // @ts-expect-error test stub used for client fallbacks
      const stub = makeAdminTestStub();
      // @ts-expect-error cache
      globalThis.__supabaseAdmin = stub;
      // @ts-expect-error returning stub client shape
      return stub;
    }

    if ((process.env.NODE_ENV === 'test' || !url || !serviceRoleKey) && !isProdRuntime) {
      // CI/test path
      // @ts-expect-error test stub
      const stub = makeAdminTestStub();
      // @ts-expect-error cache
      globalThis.__supabaseAdmin = stub;
      // @ts-expect-error
      return stub;
    }

    const client = createClient(url!, serviceRoleKey!, {
      auth: { persistSession: false, autoRefreshToken: false, detectSessionInUrl: false },
      global: { fetch: (...args) => fetch(...args) },
    });

    // cache for HMR/dev
    // @ts-expect-error cache
    globalThis.__supabaseAdmin = client;
    return client;
  })();

export default supabaseAdmin;

export function getAdminClient(): SupabaseClient {
  return supabaseAdmin;
}



========== File 16: lib/supabaseSSR.ts ==========
// lib/supabaseSSR.ts (no-SSR version)
// Drop-in replacement so existing API routes keep working without @supabase/ssr.
import type { NextApiRequest, NextApiResponse } from 'next';
import { createClient } from '@supabase/supabase-js';
import cookie from 'cookie';

function bearerFromCookies(req: NextApiRequest): string | undefined {
  const raw = req.headers.cookie;
  if (!raw) return;
  const parsed = cookie.parse(raw);
  const t = parsed['sb-access-token'];
  return t ? `Bearer ${t}` : undefined;
}

export function supabaseServer(req: NextApiRequest, _res: NextApiResponse) {
  const url = process.env.NEXT_PUBLIC_SUPABASE_URL!;
  const anon = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!;
  if (!url || !anon) {
    throw new Error('Missing NEXT_PUBLIC_SUPABASE_URL or NEXT_PUBLIC_SUPABASE_ANON_KEY');
  }

  // Prefer Authorization header; fall back to cookie if present.
  const auth = (req.headers.authorization as string | undefined) || bearerFromCookies(req);

  return createClient(url, anon, {
    global: { headers: auth ? { Authorization: auth } : {} },
  });
}

// Back-compat alias so existing imports keep working
export const createSSRClient = supabaseServer;



========== File 17: functions/activities/index.ts ==========
// /functions/activities/index.ts
import { createClient } from 'https://esm.sh/@supabase/supabase-js@2.39.3'

const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',
}

Deno.serve(async (req) => {
  if (req.method === 'OPTIONS') {
    return new Response('ok', { headers: corsHeaders })
  }

  try {
    const supabaseClient = createClient(
      Deno.env.get('SUPABASE_URL') ?? '',
      Deno.env.get('SUPABASE_ANON_KEY') ?? '',
      {
        global: {
          headers: { Authorization: req.headers.get('Authorization')! },
        },
      }
    )

    const {
      data: { user },
      error: authError,
    } = await supabaseClient.auth.getUser()

    if (authError || !user) {
      return new Response(JSON.stringify({ error: 'Unauthorized' }), {
        status: 401,
        headers: { ...corsHeaders, 'Content-Type': 'application/json' },
      })
    }

    const url = new URL(req.url)
    const path = url.pathname.split('/').pop()

    switch (path) {
      case 'get-activities':
        return await handleGetActivities(req, supabaseClient, user)
      case 'create-task':
        return await handleCreateTask(req, supabaseClient, user)
      case 'get-tasks':
        return await handleGetTasks(req, supabaseClient, user)
      case 'update-task':
        return await handleUpdateTask(req, supabaseClient, user)
      default:
        return new Response(JSON.stringify({ error: 'Not found' }), {
          status: 404,
          headers: { ...corsHeaders, 'Content-Type': 'application/json' },
        })
    }
  } catch (error) {
    return new Response(JSON.stringify({ error: error.message }), {
      status: 500,
      headers: { ...corsHeaders, 'Content-Type': 'application/json' },
    })
  }
})

// Get user activities
async function handleGetActivities(req: Request, supabase: any, user: any) {
  const { searchParams } = new URL(req.url)
  const limit = parseInt(searchParams.get('limit') || '50')
  const offset = parseInt(searchParams.get('offset') || '0')
  const activityType = searchParams.get('type')
  const startDate = searchParams.get('start_date')
  const endDate = searchParams.get('end_date')

  let query = supabase
    .from('user_activities')
    .select('*')
    .eq('user_id', user.id)
    .order('created_at', { ascending: false })
    .range(offset, offset + limit - 1)

  if (activityType) {
    query = query.eq('activity_type', activityType)
  }
  if (startDate) {
    query = query.gte('created_at', startDate)
  }
  if (endDate) {
    query = query.lte('created_at', endDate)
  }

  const { data, error } = await query

  if (error) throw error

  // Format dates for frontend
  const activities = data.map((activity: any) => ({
    ...activity,
    created_at: new Date(activity.created_at).toISOString(),
    formatted_date: new Date(activity.created_at).toLocaleString(),
  }))

  return new Response(JSON.stringify({ activities }), {
    headers: { ...corsHeaders, 'Content-Type': 'application/json' },
  })
}

// Create task for Codex
async function handleCreateTask(req: Request, supabase: any, user: any) {
  const body = await req.json()
  const {
    title,
    description,
    priority = 'medium',
    due_date,
    module,
    task_type,
    reference_id,
    reference_table,
  } = body

  // Find Codex user (assuming Codex has email 'codex@system.com')
  const { data: codexUser, error: codexError } = await supabase
    .from('profiles')
    .select('id, email')
    .eq('email', 'codex@system.com')
    .single()

  if (codexError || !codexUser) {
    throw new Error('Codex user not found. Please create a user with email codex@system.com')
  }

  // Create task using database function
  const { data: taskData, error: taskError } = await supabase.rpc(
    'create_task_with_activity',
    {
      p_title: title,
      p_description: description,
      p_created_by: user.id,
      p_assigned_to: codexUser.id,
      p_priority: priority,
      p_due_date: due_date,
      p_module: module,
      p_task_type: task_type,
      p_reference_id: reference_id,
      p_reference_table: reference_table,
    }
  )

  if (taskError) throw taskError

  return new Response(
    JSON.stringify({
      message: 'Task created successfully',
      task_id: taskData,
      assigned_to: {
        id: codexUser.id,
        email: codexUser.email,
      },
    }),
    {
      headers: { ...corsHeaders, 'Content-Type': 'application/json' },
    }
  )
}

// Get tasks (assigned to user or created by user)
async function handleGetTasks(req: Request, supabase: any, user: any) {
  const { searchParams } = new URL(req.url)
  const status = searchParams.get('status')
  const assigned = searchParams.get('assigned') === 'true'

  let query = supabase
    .from('task_assignments')
    .select(`
      *,
      creator:profiles!task_assignments_created_by_fkey (id, email, full_name, avatar_url),
      assignee:profiles!task_assignments_assigned_to_fkey (id, email, full_name, avatar_url),
      comments:task_comments(count),
      comments_details:task_comments(*, commenter:profiles(id, full_name, avatar_url))
    `)

  if (assigned) {
    query = query.eq('assigned_to', user.id)
  } else {
    query = query.or(`created_by.eq.${user.id},assigned_to.eq.${user.id}`)
  }

  if (status) {
    query = query.eq('status', status)
  }

  query = query.order('created_at', { ascending: false })

  const { data: tasks, error } = await query

  if (error) throw error

  return new Response(JSON.stringify({ tasks }), {
    headers: { ...corsHeaders, 'Content-Type': 'application/json' },
  })
}

// Update task status
async function handleUpdateTask(req: Request, supabase: any, user: any) {
  const { task_id, status, comment } = await req.json()

  // Update task status
  const { data: task, error: updateError } = await supabase
    .from('task_assignments')
    .update({
      status,
      ...(status === 'completed' ? { completed_at: new Date().toISOString() } : {}),
    })
    .eq('id', task_id)
    .select()
    .single()

  if (updateError) throw updateError

  // Add comment if provided
  if (comment) {
    const { error: commentError } = await supabase
      .from('task_comments')
      .insert({
        task_id,
        user_id: user.id,
        comment,
        metadata: { status_change: status },
      })

    if (commentError) throw commentError
  }

  // Log activity
  await supabase.rpc('log_user_activity', {
    p_user_id: user.id,
    p_activity_type: 'task_updated',
    p_description: `Updated task "${task.title}" status to ${status}`,
    p_metadata: {
      task_id,
      old_status: task.status,
      new_status: status,
      comment: comment || null,
    },
    p_related_table: 'task_assignments',
    p_related_id: task_id,
  })

  return new Response(
    JSON.stringify({
      message: 'Task updated successfully',
      task,
    }),
    {
      headers: { ...corsHeaders, 'Content-Type': 'application/json' },
    }
  )
}



========== File 1: pages/api/ai/coach.ts ==========
// pages/api/ai/coach.ts
import type { NextApiRequest, NextApiResponse } from "next";
import { createClient } from "@supabase/supabase-js";

/* -------------------------------------------------------------------------- */
/* ENV expected (set in .env.local)                                           */
/* -------------------------------------------------------------------------- */
/*
GROQ_API_KEY=gsk-...
GROQ_API_BASE=https://api.groq.com/openai/v1
GROQ_MODEL=llama-3.3-70b-versatile

GEMINI_API_KEY=AIza...
GEMINI_API_BASE=https://generativelanguage.googleapis.com/v1beta/openai
GEMINI_MODEL=gemini-1.5-flash-latest

OPENAI_API_KEY=sk-...
OPENAI_API_BASE=https://api.openai.com/v1
OPENAI_MODEL=gpt-4o-mini

DEEPSEEK_API_KEY=sk-...
DEEPSEEK_API_BASE=https://api.deepseek.com
DEEPSEEK_MODEL=deepseek-chat

GROK_API_KEY=xai-...
GROK_API_BASE=https://api.x.ai/v1
GROK_MODEL=grok-4-latest

SUPABASE_URL=...
SUPABASE_SERVICE_ROLE_KEY=...
AI_MOCK=1            # optional for dev offline
*/

const supabaseAdmin = createClient(
  process.env.SUPABASE_URL!,
  process.env.SUPABASE_SERVICE_ROLE_KEY!
);

/* -------------------------------------------------------------------------- */
/* Provider chain                                                             */
/* -------------------------------------------------------------------------- */

type Prov = {
  name: "groq" | "gemini" | "openai" | "deepseek" | "grok";
  baseURL: string;
  apiKey?: string;
  model: string;
};

const PROVIDERS: Prov[] = [
  {
    name: "groq",
    baseURL: process.env.GROQ_API_BASE || "https://api.groq.com/openai/v1",
    apiKey: process.env.GROQ_API_KEY,
    model: process.env.GROQ_MODEL || "llama-3.3-70b-versatile",
  },
  {
    name: "gemini",
    baseURL:
      process.env.GEMINI_API_BASE ||
      "https://generativelanguage.googleapis.com/v1beta/openai",
    apiKey: process.env.GEMINI_API_KEY,
    model: process.env.GEMINI_MODEL || "gemini-1.5-flash-latest",
  },
  {
    name: "openai",
    baseURL: process.env.OPENAI_API_BASE || "https://api.openai.com/v1",
    apiKey: process.env.OPENAI_API_KEY,
    model: process.env.OPENAI_MODEL || "gpt-4o-mini",
  },
  {
    name: "deepseek",
    baseURL: process.env.DEEPSEEK_API_BASE || "https://api.deepseek.com",
    apiKey: process.env.DEEPSEEK_API_KEY,
    model: process.env.DEEPSEEK_MODEL || "deepseek-chat",
  },
  {
    name: "grok",
    baseURL: process.env.GROK_API_BASE || "https://api.x.ai/v1",
    apiKey: process.env.GROK_API_KEY,
    model: process.env.GROK_MODEL || "grok-4-latest",
  },
];

/* -------------------------------------------------------------------------- */
/* Helpers                                                                    */
/* -------------------------------------------------------------------------- */

const SYSTEM_PROMPT =
  "You are an IELTS coaching assistant. Provide concise actionable suggestions (3–6), each with a short title, a 1–2 sentence detail, and estimated minutes to practice. Output pure JSON only.";

function extractJSON(str: string): any {
  if (!str) return null;
  try {
    return JSON.parse(str);
  } catch {}
  const fence = str.match(/```(?:json)?\s*([\s\S]*?)```/i);
  if (fence) try { return JSON.parse(fence[1]); } catch {}
  const block = str.match(/\{[\s\S]*\}/);
  if (block) try { return JSON.parse(block[0]); } catch {}
  return { raw: str };
}

async function callProvider(p: Prov, payload: any) {
  if (!p.apiKey)
    return { ok: false, err: { status: 500, detail: `${p.name} key missing` }, provider: p.name };

  try {
    const r = await fetch(`${p.baseURL}/chat/completions`, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        Authorization: `Bearer ${p.apiKey}`,
      },
      body: JSON.stringify({ ...payload, model: p.model }),
    });

    const txt = await r.text();
    if (!r.ok)
      return {
        ok: false,
        err: { status: r.status, detail: (() => { try { return JSON.parse(txt); } catch { return txt; } })() },
        provider: p.name,
      };

    const json = JSON.parse(txt);
    const content =
      json?.choices?.[0]?.message?.content ??
      json?.choices?.[0]?.text ??
      "";

    if (!content.trim())
      return { ok: false, err: { status: 502, detail: "Empty content" }, provider: p.name };

    return { ok: true, content, provider: p.name };
  } catch (e: any) {
    return { ok: false, err: { status: 500, detail: e.message || String(e) }, provider: p.name };
  }
}

/* -------------------------------------------------------------------------- */
/* Handler                                                                    */
/* -------------------------------------------------------------------------- */

export default async function handler(req: NextApiRequest, res: NextApiResponse) {
  if (req.method !== "POST")
    return res.status(405).json({ error: "Method not allowed" });

  const { userId = null, context = "", goal = "" } = req.body ?? {};

  /* Mock mode --------------------------------------------------------------- */
  if (process.env.AI_MOCK === "1") {
    const mock = {
      id: "mock",
      summary: "Mock AI response — providers unavailable.",
      suggestions: [
        { id: "s1", title: "Plan paragraphs", detail: "Spend 5 min outlining key ideas.", estimatedMinutes: 10 },
        { id: "s2", title: "Add connectors", detail: "Use clear linkers to connect ideas.", estimatedMinutes: 8 },
        { id: "s3", title: "Rewrite one paragraph", detail: "Improve flow and coherence.", estimatedMinutes: 12 },
      ],
    };
    await supabaseAdmin.from("ai_logs").insert([
      { user_id: userId, request: JSON.stringify({ provider: "mock", context, goal }), response: JSON.stringify(mock), status: "ok" },
    ]);
    return res.status(200).json(mock);
  }

  const userPrompt = `User goal: ${goal}\nContext: ${context}\nReturn JSON: { id, summary, suggestions: [{id,title,detail,estimatedMinutes}], reasoning? }`;

  const payload = {
    messages: [
      { role: "system", content: SYSTEM_PROMPT },
      { role: "user", content: userPrompt },
    ],
    max_tokens: 700,
    temperature: 0.2,
  };

  const attempts: Array<{ provider: string; status?: number; detail?: any }> = [];

  for (const p of PROVIDERS) {
    const result = await callProvider(p, payload);

    if (result.ok) {
      const parsed = extractJSON(result.content);
      await supabaseAdmin.from("ai_logs").insert([
        {
          user_id: userId,
          request: JSON.stringify({ provider: result.provider, model: p.model, context, goal }),
          response: JSON.stringify(parsed),
          status: "ok",
        },
      ]);
      console.log(`[ai/coach] ✅ responded from ${result.provider}`);
      return res.status(200).json(parsed);
    }

    attempts.push({ provider: p.name, status: result.err?.status, detail: result.err?.detail });
    await supabaseAdmin.from("ai_logs").insert([
      {
        user_id: userId,
        request: JSON.stringify({ provider: p.name, model: p.model, context, goal }),
        response: JSON.stringify(result.err),
        status: "error",
      },
    ]);
    console.warn(`[ai/coach] ❌ ${p.name} failed`, result.err);
  }

  return res.status(502).json({ error: "All AI providers failed", attempts });
}
========== File 2: pages/api/ai/coach/action.ts ==========
import type { NextApiRequest, NextApiResponse } from 'next';
import { createClient } from '@supabase/supabase-js';

const supabase = createClient(SUPABASE_URL, SUPABASE_SERVICE_ROLE_KEY);

export default async function actionHandler(req: NextApiRequest, res: NextApiResponse) {
  if (req.method !== 'POST') return res.status(405).json({ error: 'Method not allowed' });
  const { suggestionId, userId = null } = req.body ?? {};
  try {
    await supabase.from('ai_actions').insert([{ user_id: userId, suggestion_id: suggestionId, created_at: new Date().toISOString() }]);
    return res.status(200).json({ success: true });
  } catch (e: any) {
    console.error('ai action insert', e);
    return res.status(500).json({ error: 'Failed to record action' });
  }
}
========== File 3: pages/api/ai/speaking/grade.ts ==========
import type { NextApiRequest, NextApiResponse } from 'next';
import { z } from 'zod';
import { createClient } from '@supabase/supabase-js';

const BodySchema = z.object({
  attemptId: z.string().optional(),   // if provided, we’ll look for a transcript or audio (future)
  transcript: z.string().optional(),  // if provided, we grade based on this text
});

type AIFeedback = {
  bandOverall: number;
  fluency: number;
  lexical: number;
  grammar: number;
  pronunciation: number;
  notes: string[];
};

type Resp = { ok: true; feedback: AIFeedback } | { ok: false; error: string };

const openaiModel = process.env.OPENAI_SPEAKING_MODEL || 'gpt-4o-mini';

export default async function handler(req: NextApiRequest, res: NextApiResponse<Resp>) {
  if (req.method !== 'POST') return res.status(405).json({ ok: false, error: 'Method not allowed' });

  const parse = BodySchema.safeParse(req.body);
  if (!parse.success) {
    return res.status(400).json({ ok: false, error: parse.error.issues.map(i => i.message).join(', ') });
  }
  const { attemptId, transcript } = parse.data;

  // 1) Try transcript (provided directly)
  let text = (transcript || '').trim();

  // 2) Fallback: if attemptId provided and `attempts_speaking.transcript` exists, use that
  if (!text && attemptId && process.env.NEXT_PUBLIC_SUPABASE_URL && (process.env.SUPABASE_SERVICE_ROLE_KEY || process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY)) {
    try {
      const supabase = createClient(
        process.env.NEXT_PUBLIC_SUPABASE_URL!,
        (process.env.SUPABASE_SERVICE_ROLE_KEY || process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY)!,
      );
      const { data } = await supabase.from('attempts_speaking').select('transcript').eq('id', attemptId).single();
      if (data?.transcript) text = String(data.transcript);
    } catch {
      // ignore
    }
  }

  // 3) Grade
  let feedback: AIFeedback;
  try {
    if (process.env.OPENAI_API_KEY && text) {
      feedback = await gradeWithOpenAI(text);
    } else {
      feedback = heuristic(text);
    }
  } catch {
    feedback = heuristic(text);
  }

  return res.status(200).json({ ok: true, feedback });
}

function heuristic(text: string): AIFeedback {
  const wc = text.trim() ? text.trim().split(/\s+/).length : 0;
  const base = 6 + Math.min(1, Math.max(0, (wc - 120) / 200));
  const band = clampHalf(base, 4, 9);
  return {
    bandOverall: band,
    fluency: clampHalf(band - 0.5, 4, 9),
    lexical: clampHalf(band, 4, 9),
    grammar: clampHalf(band - 0.5, 4, 9),
    pronunciation: clampHalf(band, 4, 9),
    notes: [
      'Maintain steady pace; avoid long pauses.',
      'Use more topic-specific vocabulary.',
      'Vary sentence structures; check articles and prepositions.',
      'Chunk ideas and use signposting (firstly, moreover).',
    ],
  };
}

async function gradeWithOpenAI(transcript: string): Promise<AIFeedback> {
  const prompt = `You are an IELTS Speaking examiner. Grade the following transcript.
Return ONLY JSON with keys: bandOverall, fluency, lexical, grammar, pronunciation, notes (array).
Transcript:
${transcript}
  `;
  const r = await fetch('https://api.openai.com/v1/chat/completions', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json', Authorization: `Bearer ${process.env.OPENAI_API_KEY}` },
    body: JSON.stringify({
      model: openaiModel,
      messages: [{ role: 'user', content: prompt }],
      temperature: 0.2,
      response_format: { type: 'json_object' },
    }),
  });
  if (!r.ok) throw new Error('OpenAI error');
  const json = await r.json();
  const content = json.choices?.[0]?.message?.content;
  const out = JSON.parse(content || '{}');

  const band = clampHalf(Number(out.bandOverall ?? 6), 4, 9);
  return {
    bandOverall: band,
    fluency: clampHalf(Number(out.fluency ?? band - 0.5), 4, 9),
    lexical: clampHalf(Number(out.lexical ?? band), 4, 9),
    grammar: clampHalf(Number(out.grammar ?? band - 0.5), 4, 9),
    pronunciation: clampHalf(Number(out.pronunciation ?? band), 4, 9),
    notes: Array.isArray(out.notes) ? out.notes.slice(0, 8) : ['Speak steadily and expand answers.'],
  };
}

const clampHalf = (n: number, min: number, max: number) => Math.max(min, Math.min(max, Math.round(n * 2) / 2));
========== File 4: pages/api/ai/writing/grade.ts ==========
import type { NextApiRequest, NextApiResponse } from 'next';
import { z } from 'zod';

// Optional: service-side Supabase (used only if you pass attemptId to persist)
import { createClient } from '@supabase/supabase-js';

const BodySchema = z.object({
  task1: z.string().min(1, 'task1 required'),
  task2: z.string().min(1, 'task2 required'),
  attemptId: z.string().optional(), // if provided, we'll persist AI feedback to attempts_writing.ai_feedback
});

type AIFeedback = {
  bandOverall: number;
  criteria: {
    taskAchievement: number;
    coherence: number;
    lexical: number;
    grammar: number;
  };
  notes: string[];
};

type Resp =
  | { ok: true; feedback: AIFeedback }
  | { ok: false; error: string };

const openaiModel = process.env.OPENAI_WRITING_MODEL || 'gpt-4o-mini';

export default async function handler(req: NextApiRequest, res: NextApiResponse<Resp>) {
  if (req.method !== 'POST') return res.status(405).json({ ok: false, error: 'Method not allowed' });

  const parse = BodySchema.safeParse(req.body);
  if (!parse.success) {
    return res.status(400).json({ ok: false, error: parse.error.issues.map(i => i.message).join(', ') });
  }
  const { task1, task2, attemptId } = parse.data;

  // Try OpenAI if key present, otherwise use heuristic
  let feedback: AIFeedback;
  try {
    if (process.env.OPENAI_API_KEY) {
      feedback = await gradeWithOpenAI(task1, task2);
    } else {
      feedback = heuristic(task1, task2);
    }
  } catch (e: any) {
    feedback = heuristic(task1, task2);
  }

  // Optional: persist to attempts_writing.ai_feedback if attemptId provided
  if (attemptId && process.env.NEXT_PUBLIC_SUPABASE_URL && (process.env.SUPABASE_SERVICE_ROLE_KEY || process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY)) {
    try {
      const supabase = createClient(
        process.env.NEXT_PUBLIC_SUPABASE_URL!,
        (process.env.SUPABASE_SERVICE_ROLE_KEY || process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY)!,
      );
      await supabase.from('attempts_writing').update({ ai_feedback: feedback }).eq('id', attemptId);
    } catch {
      // ignore persistence errors
    }
  }

  return res.status(200).json({ ok: true, feedback });
}

function heuristic(t1: string, t2: string): AIFeedback {
  const wc = (s: string) => (s.trim() ? s.trim().split(/\s+/).length : 0);
  const w1 = wc(t1), w2 = wc(t2);
  const base = 5.5 + Math.min(1.0, Math.max(0, (w1 - 150) / 300)) + Math.min(1.5, Math.max(0, (w2 - 250) / 500));
  const band = clampHalf(base, 4, 9);
  return {
    bandOverall: band,
    criteria: {
      taskAchievement: clampHalf(5 + (w1 >= 150 ? 1 : 0), 4, 9),
      coherence:  clampHalf(5.5 + (w2 >= 250 ? 0.5 : 0), 4, 9),
      lexical:    clampHalf(5.5, 4, 9),
      grammar:    clampHalf(5.5, 4, 9),
    },
    notes: [
      'Use clear topic sentences and logical paragraphing.',
      'Vary cohesive devices (however, furthermore, consequently).',
      'Aim for precise vocabulary; reduce repetition.',
      'Check complex sentences for agreement and punctuation.',
    ],
  };
}
const clampHalf = (n: number, min: number, max: number) => Math.max(min, Math.min(max, Math.round(n * 2) / 2));

async function gradeWithOpenAI(task1: string, task2: string): Promise<AIFeedback> {
  const prompt = `You are an IELTS examiner. Grade the two essays below. Return ONLY a compact JSON with keys:
  bandOverall (number 4-9, halves allowed),
  criteria { taskAchievement, coherence, lexical, grammar } (numbers with halves),
  notes (array of short coaching bullets).
  Essays:
  [Task 1]
  ${task1}

  [Task 2]
  ${task2}
  `;

  const r = await fetch('https://api.openai.com/v1/chat/completions', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json', Authorization: `Bearer ${process.env.OPENAI_API_KEY}` },
    body: JSON.stringify({
      model: openaiModel,
      messages: [{ role: 'user', content: prompt }],
      temperature: 0.2,
      response_format: { type: 'json_object' },
    }),
  });
  if (!r.ok) throw new Error('OpenAI error');
  const json = await r.json();
  const content = json.choices?.[0]?.message?.content;
  const out = JSON.parse(content);
  // Minimal shape guard
  return {
    bandOverall: clampHalf(Number(out.bandOverall ?? 6), 4, 9),
    criteria: {
      taskAchievement: clampHalf(Number(out?.criteria?.taskAchievement ?? 6), 4, 9),
      coherence: clampHalf(Number(out?.criteria?.coherence ?? 6), 4, 9),
      lexical: clampHalf(Number(out?.criteria?.lexical ?? 6), 4, 9),
      grammar: clampHalf(Number(out?.criteria?.grammar ?? 6), 4, 9),
    },
    notes: Array.isArray(out?.notes) ? out.notes.slice(0, 8) : ['Organize ideas clearly.', 'Use precise vocabulary.', 'Vary sentence structures.'],
  };
}
========== File 5: pages/api/activities/export.ts ==========
// pages/api/activities/export.ts
import { NextApiRequest, NextApiResponse } from 'next';
import { createClient } from '@supabase/supabase-js';
import { parse } from 'json2csv';

const supabaseAdmin = createClient(
  process.env.NEXT_PUBLIC_SUPABASE_URL!,
  process.env.SUPABASE_SERVICE_ROLE_KEY!
);

export default async function handler(req: NextApiRequest, res: NextApiResponse) {
  if (req.method !== 'GET') {
    return res.status(405).json({ error: 'Method not allowed' });
  }

  try {
    // Get user from auth token
    const authHeader = req.headers.authorization;
    if (!authHeader) {
      return res.status(401).json({ error: 'Unauthorized' });
    }

    const token = authHeader.replace('Bearer ', '');
    const { data: { user }, error: authError } = await supabaseAdmin.auth.getUser(token);

    if (authError || !user) {
      return res.status(401).json({ error: 'Unauthorized' });
    }

    // Fetch user activities
    const { data: activities, error } = await supabaseAdmin
      .from('user_activities')
      .select('*')
      .eq('user_id', user.id)
      .order('created_at', { ascending: false });

    if (error) {
      throw error;
    }

    // Format data for CSV
    const formattedActivities = activities.map(activity => ({
      Date: new Date(activity.created_at).toLocaleString(),
      Type: activity.activity_type.replace(/_/g, ' '),
      Description: activity.description,
      IP_Address: activity.ip_address,
      User_Agent: activity.user_agent,
      Metadata: JSON.stringify(activity.metadata),
      Related_Table: activity.related_table,
      Related_ID: activity.related_id,
    }));

    // Convert to CSV
    const csv = parse(formattedActivities);

    // Set headers for CSV download
    res.setHeader('Content-Type', 'text/csv');
    res.setHeader('Content-Disposition', `attachment; filename=gramorx-activities-${user.id}-${new Date().toISOString().split('T')[0]}.csv`);

    return res.status(200).send(csv);
  } catch (error) {
    console.error('Export error:', error);
    return res.status(500).json({ error: 'Failed to export activities' });
  }
}
========== File 6: pages/api/counters/increment.ts ==========
import type { NextApiRequest, NextApiResponse } from 'next';
import { z } from 'zod';
import { createClient } from '@supabase/supabase-js';

const BodySchema = z.object({
  counter: z.enum([
    'listening_attempts',
    'reading_attempts',
    'writing_ai_checks',
    'speaking_minutes',
  ]),
  delta: z.number().int().min(1).max(120),
});

type Resp = {
  ok: true;
  counter: string;
  current: number;
  limit: number;
  blocked: boolean;
} | { ok: false; error: string };

// Default free limits (per day). You can override via env vars later.
const FREE_LIMITS = {
  listening_attempts: Number(process.env.LIMIT_FREE_LISTENING ?? 1),
  reading_attempts: Number(process.env.LIMIT_FREE_READING ?? 1),
  writing_ai_checks: Number(process.env.LIMIT_FREE_WRITING_AI ?? 2),
  speaking_minutes: Number(process.env.LIMIT_FREE_SPEAKING_MIN ?? 10),
};
// Booster/Master limits (examples)
const BOOSTER_LIMITS = {
  listening_attempts: 999,
  reading_attempts: 999,
  writing_ai_checks: 50,
  speaking_minutes: 120,
};
const MASTER_LIMITS = {
  listening_attempts: 999,
  reading_attempts: 999,
  writing_ai_checks: 200,
  speaking_minutes: 240,
};

export default async function handler(req: NextApiRequest, res: NextApiResponse<Resp>) {
  if (req.method !== 'POST') return res.status(405).json({ ok: false, error: 'Method not allowed' });

  const parse = BodySchema.safeParse(req.body);
  if (!parse.success) return res.status(400).json({ ok: false, error: parse.error.issues.map(i => i.message).join(', ') });

  const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL!;
  const supabaseKey = process.env.SUPABASE_SERVICE_ROLE_KEY || process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY;
  if (!supabaseUrl || !supabaseKey) return res.status(503).json({ ok: false, error: 'Supabase env missing' });

  // Auth: require Bearer token so we know the user
  const token = (req.headers.authorization || '').replace(/^Bearer\s+/i, '');
  if (!token) return res.status(401).json({ ok: false, error: 'Missing Authorization bearer token' });

  const supabase = createClient(supabaseUrl, supabaseKey, { global: { headers: { Authorization: `Bearer ${token}` } } });
  const { data: userRes, error: userErr } = await supabase.auth.getUser();
  if (userErr || !userRes.user?.id) return res.status(401).json({ ok: false, error: 'Unauthorized' });
  const userId = userRes.user.id;

  const { counter, delta } = parse.data;

  // Determine plan & limits
  let plan: 'free'|'starter'|'booster'|'master' = 'free';
  try {
    const { data: profile } = await supabase.from('profiles').select('membership_plan').eq('id', userId).single();
    if (profile?.membership_plan) plan = profile.membership_plan as typeof plan;
  } catch { /* ignore */ }

  const limit = plan === 'master' ? MASTER_LIMITS[counter]
    : plan === 'booster' || plan === 'starter' ? BOOSTER_LIMITS[counter]
    : FREE_LIMITS[counter];

  // Read today's current
  const today = new Date().toISOString().slice(0, 10);
  const { data: row } = await supabase
    .from('usage_counters')
    .select('id,current')
    .eq('user_id', userId)
    .eq('counter', counter)
    .eq('date', today)
    .single();

  const current = row?.current ?? 0;
  const proposed = current + delta;
  const blocked = proposed > limit;

  if (!blocked) {
    if (row?.id) {
      await supabase.from('usage_counters').update({ current: proposed }).eq('id', row.id);
    } else {
      await supabase.from('usage_counters').insert({ user_id: userId, counter, date: today, current: proposed });
    }
  }

  return res.status(200).json({ ok: true, counter, current: blocked ? current : proposed, limit, blocked });
}
========== File 7: pages/api/premium/eligibility.ts ==========
// pages/api/premium/eligibility.ts
import type { NextApiRequest, NextApiResponse } from 'next';
import { createClient } from '@supabase/supabase-js';

type Resp = { eligible: boolean; plan: string | null; reason?: string };

export default async function handler(req: NextApiRequest, res: NextApiResponse<Resp>) {
  const token = req.headers.authorization?.split(' ')[1];
  if (!token) return res.status(200).json({ eligible: false, plan: null, reason: 'unauthenticated' });

  const supabase = createClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!
  );

  const { data: { user } } = await supabase.auth.getUser(token);
  if (!user) return res.status(200).json({ eligible: false, plan: null, reason: 'unauthenticated' });

  const { data: prof, error } = await supabase
    .from('profiles')
    .select('plan')
    .eq('id', user.id)
    .single();

  if (error) return res.status(200).json({ eligible: false, plan: null, reason: 'no_profile' });

  const plan = (prof?.plan ?? null) as string | null;
  const eligible = plan === 'premium' || plan === 'master';
  return res.status(200).json({ eligible, plan, reason: eligible ? undefined : 'plan_required' });
}
========== File 8: pages/api/premium/session.ts ==========
// pages/api/premium/session.ts
import type { NextApiRequest, NextApiResponse } from 'next';
import { createClient } from '@supabase/supabase-js';

type Resp = { ok: true; userId: string } | { ok: false; error: string };

export default async function handler(req: NextApiRequest, res: NextApiResponse<Resp>) {
  if (req.method !== 'POST') {
    res.setHeader('Allow', 'POST');
    return res.status(405).json({ ok: false, error: 'method-not-allowed' });
  }

  const token = req.headers.authorization?.split(' ')[1];
  if (!token) return res.status(401).json({ ok: false, error: 'no-token' });

  const supabase = createClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!
  );

  const { data: { user }, error } = await supabase.auth.getUser(token);
  if (error || !user) return res.status(401).json({ ok: false, error: 'invalid-token' });

  return res.status(200).json({ ok: true, userId: user.id });
}
========== File 9: pages/api/premium/status.ts ==========
// pages/api/premium/status.ts
import type { NextApiRequest, NextApiResponse } from 'next';
import { createClient } from '@supabase/supabase-js';

type Resp = {
  pinOk: boolean;
  loggedIn: boolean;
  userId: string | null;
  plan: string | null;
};

export default async function handler(req: NextApiRequest, res: NextApiResponse<Resp>) {
  const pinOk = req.cookies?.pr_pin_ok === '1';

  const token = req.headers.authorization?.split(' ')[1];
  if (!token) {
    return res.status(200).json({ pinOk, loggedIn: false, userId: null, plan: null });
  }

  const supabase = createClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!
  );

  const { data: { user } } = await supabase.auth.getUser(token);
  if (!user) {
    return res.status(200).json({ pinOk, loggedIn: false, userId: null, plan: null });
  }

  const { data: prof } = await supabase
    .from('profiles')
    .select('plan')
    .eq('id', user.id)
    .single();

  return res.status(200).json({
    pinOk,
    loggedIn: true,
    userId: user.id,
    plan: (prof?.plan ?? null) as string | null,
  });
}
========== File 10: pages/api/reading/dashboard.ts ==========
// pages/api/reading/dashboard.ts
import type { NextApiRequest, NextApiResponse } from 'next';

// Prefer your existing helper if present
// import { getServerClient } from '@/lib/supabaseServer';
import { createClient } from '@supabase/supabase-js';

// ---- Adjust these if your env helpers differ
const supabaseAdmin = () =>
  createClient(process.env.NEXT_PUBLIC_SUPABASE_URL as string, process.env.SUPABASE_SERVICE_ROLE_KEY as string, {
    auth: { persistSession: false },
  });

/**
 * Expected minimal columns:
 * reading_attempts: id, user_id, test_id, passage_id, created_at, duration_sec, score (0..1 or 0..100), correct_questions, total_questions
 * attempts_reading: attempt_id, question_id, correct (bool), time_sec
 * reading_questions: id, type ('tfng'|'mcq'|'matching'|'short'|...)
 * reading_passages: id, title, slug
 * reading_tests: id, title, slug
 * reading_user_stats (optional): user_id, streak_days, total_practices
 */

type AttemptRow = {
  id: string;
  user_id: string;
  test_id: string | null;
  passage_id: string | null;
  created_at: string;
  duration_sec: number | null;
  score: number | null; // 0..1 or 0..100
  correct_questions: number | null;
  total_questions: number | null;
};

type AttemptDetailRow = {
  attempt_id: string;
  question_id: string;
  correct: boolean | null;
  time_sec: number | null;
};

type QuestionRow = { id: string; type: string | null };
type PassageRow = { id: string; title: string | null; slug: string | null };
type TestRow = { id: string; title: string | null; slug: string | null };
type UserStatsRow = { user_id: string; streak_days: number | null; total_practices: number | null };

function normScore(a: AttemptRow): number | null {
  if (a == null) return null;
  if (typeof a.score === 'number') {
    // Heuristic: treat >1 as percentage
    return a.score > 1 ? a.score / 100 : a.score;
  }
  if (typeof a.correct_questions === 'number' && typeof a.total_questions === 'number' && a.total_questions > 0) {
    return a.correct_questions / a.total_questions;
  }
  return null;
}

export default async function handler(req: NextApiRequest, res: NextApiResponse) {
  try {
    const sb = supabaseAdmin();

    // ---- Get user from a bearer cookie/session (if you gate with RLS, keep this).
    // Service role is used above for simplicity, but if you prefer per-request auth:
    // const supa = getServerClient(req, res);
    // const { data: { user } } = await supa.auth.getUser();

    // If you want to require auth, flip allowGuest to false
    const allowGuest = true;

    // Try to infer user via a light JWT in Authorization, else treat as guest
    let userId: string | null = null;
    try {
      const auth = req.headers.authorization || '';
      if (auth.startsWith('Bearer ')) {
        const token = auth.slice(7);
        const { data, error } = await sb.auth.getUser(token);
        if (!error && data?.user) userId = data.user.id;
      }
    } catch {
      // ignore; we'll be guest
    }

    if (!userId && !allowGuest) {
      return res.status(401).json({ error: 'not_authenticated' });
    }

    // ---- Fetch attempts (latest first)
    const attemptsQ = sb
      .from('reading_attempts')
      .select('id,user_id,test_id,passage_id,created_at,duration_sec,score,correct_questions,total_questions')
      .order('created_at', { ascending: false })
      .limit(60);

    const { data: attemptsRaw, error: attemptsErr } = await attemptsQ;
    if (attemptsErr) {
      // Don’t explode the UI — return empty, plus an informational hint
      return res.status(200).json({
        kpis: { bandEstimate: null, bandStd: null, accuracy10: null, accuracyDelta10: null, avgSecPerQ: null, streakDays: null, totalPractices: null },
        trend: [],
        byType: [],
        timeVsScore: [],
        weakAreas: [],
        recent: [],
        saved: [],
        queued: [],
        note: 'reading_attempts query failed',
      });
    }

    const attempts: AttemptRow[] = (attemptsRaw ?? []) as any;
    const latest = attempts.slice(0, 20);

    // ---- Batch fetch per-question results for last ~200 details
    const latestIds = latest.map((a) => a.id);
    let details: AttemptDetailRow[] = [];
    if (latestIds.length) {
      const { data: det, error: detErr } = await sb
        .from('attempts_reading')
        .select('attempt_id,question_id,correct,time_sec')
        .in('attempt_id', latestIds)
        .limit(1000);
      if (!detErr && det) details = det as any;
    }

    // ---- Fetch question types for involved questions
    const qIds = Array.from(new Set(details.map((d) => d.question_id)));
    let questions: Record<string, string | null> = {};
    if (qIds.length) {
      const { data: qRows, error: qErr } = await sb
        .from('reading_questions')
        .select('id,type')
        .in('id', qIds)
        .limit(2000);
      if (!qErr && qRows) {
        for (const q of qRows as QuestionRow[]) questions[q.id] = q.type;
      }
    }

    // ---- Simple resource titles (passage/test)
    const passageIds = Array.from(new Set(attempts.map((a) => a.passage_id).filter(Boolean))) as string[];
    const testIds = Array.from(new Set(attempts.map((a) => a.test_id).filter(Boolean))) as string[];

    let passagesById: Record<string, PassageRow> = {};
    if (passageIds.length) {
      const { data: pRows } = await sb.from('reading_passages').select('id,title,slug').in('id', passageIds).limit(2000);
      (pRows ?? []).forEach((p: any) => (passagesById[p.id] = p));
    }

    let testsById: Record<string, TestRow> = {};
    if (testIds.length) {
      const { data: tRows } = await sb.from('reading_tests').select('id,title,slug').in('id', testIds).limit(2000);
      (tRows ?? []).forEach((t: any) => (testsById[t.id] = t));
    }

    // ---- Optional user stats
    let userStats: UserStatsRow | null = null;
    if (userId) {
      const { data: us } = await sb.from('reading_user_stats').select('user_id,streak_days,total_practices').eq('user_id', userId).maybeSingle();
      userStats = (us as any) || null;
    }

    // ---- Compute KPIs
    const last10 = attempts.slice(0, 10);
    const last10Scores = last10.map(normScore).filter((n): n is number => n != null);
    const accuracy10 = last10Scores.length ? avg(last10Scores) : null;

    const prev10 = attempts.slice(10, 20);
    const prev10Scores = prev10.map(normScore).filter((n): n is number => n != null);
    const accuracyPrev10 = prev10Scores.length ? avg(prev10Scores) : null;
    const accuracyDelta10 =
      typeof accuracy10 === 'number' && typeof accuracyPrev10 === 'number' ? accuracy10 - accuracyPrev10 : null;

    const allScores = attempts.map(normScore).filter((n): n is number => n != null);
    const bandEstimate = allScores.length ? toBand(avg(allScores)) : null;
    const bandStd = allScores.length > 1 ? stddev(allScores.map(toBand)) : null;

    // average seconds per question over last 20 with Q data
    const timeDenoms = latest
      .map((a) => {
        const n = typeof a.total_questions === 'number' && a.total_questions > 0 ? a.total_questions : null;
        const dur = typeof a.duration_sec === 'number' ? a.duration_sec : null;
        return { dur, n };
      })
      .filter((x) => x.dur != null && x.n != null);
    const avgSecPerQ =
      timeDenoms.length ? Math.round(avg(timeDenoms.map((x) => (x.dur as number) / (x.n as number)))) : null;

    const streakDays = userStats?.streak_days ?? null;
    const totalPractices = userStats?.total_practices ?? attempts.length;

    // ---- Trend (last 20)
    const trend = latest.map((a) => ({ date: a.created_at, score: normScore(a) ?? 0 }));

    // ---- By type (heatmap) from attempts_reading + reading_questions
    const byTypeAgg: Record<string, { correct: number; total: number }> = {};
    for (const d of details) {
      const t = (questions[d.question_id] || 'unknown')?.toLowerCase();
      if (!byTypeAgg[t]) byTypeAgg[t] = { correct: 0, total: 0 };
      byTypeAgg[t].total += 1;
      if (d.correct) byTypeAgg[t].correct += 1;
    }
    const byType = Object.entries(byTypeAgg)
      .map(([type, v]) => ({
        type,
        accuracy: v.total > 0 ? v.correct / v.total : 0,
        attempts: v.total,
      }))
      .sort((a, b) => a.accuracy - b.accuracy); // weakest first

    // ---- Time vs score (from attempts)
    const timeVsScore = latest
      .map((a) => ({
        id: a.id,
        minutes: Math.max(1, Math.round(((a.duration_sec ?? 0) / 60) * 10) / 10),
        score: normScore(a) ?? 0,
      }))
      .filter((x) => Number.isFinite(x.minutes) && Number.isFinite(x.score));

    // ---- Recent table (last 7)
    const recent = attempts.slice(0, 7).map((a) => {
      const pass = a.passage_id ? passagesById[a.passage_id] : null;
      const test = a.test_id ? testsById[a.test_id] : null;
      const title = pass?.title || test?.title || 'Reading practice';
      const slug = pass?.slug || test?.slug || a.id;
      const hrefReview = pass?.slug
        ? `/reading/${pass.slug}#review`
        : test?.slug
        ? `/reading/${test.slug}#review`
        : `/reading/${slug}#review`;
      return {
        slug: String(slug),
        title: String(title),
        date: a.created_at,
        score: normScore(a) ?? 0,
        minutes: Math.max(1, Math.round(((a.duration_sec ?? 0) / 60) * 10) / 10),
        types: [], // could be filled from details if you want
        hrefReview,
      };
    });

    // ---- Weak areas (top 2 weakest)
    const weakAreas =
      byType.length >= 2
        ? byType.slice(0, 2).map((w) => ({
            label: w.type,
            reason: `Accuracy ${Math.round(w.accuracy * 100)}% over ${w.attempts} Qs`,
            href: `/reading?type=${encodeURIComponent(w.type)}`,
          }))
        : [];

    // ---- Response
    return res.status(200).json({
      kpis: {
        bandEstimate,
        bandStd,
        accuracy10,
        accuracyDelta10,
        avgSecPerQ,
        streakDays,
        totalPractices,
      },
      trend,
      byType,
      timeVsScore,
      weakAreas,
      recent,
      saved: [], // integrate when you add a "saved" table
      queued: [], // integrate with a "queue" table
    });
  } catch (e: any) {
    return res.status(200).json({
      kpis: { bandEstimate: null, bandStd: null, accuracy10: null, accuracyDelta10: null, avgSecPerQ: null, streakDays: null, totalPractices: null },
      trend: [],
      byType: [],
      timeVsScore: [],
      weakAreas: [],
      recent: [],
      saved: [],
      queued: [],
      note: e?.message || 'Unhandled',
    });
  }
}

// ---- helpers
function avg(xs: number[]) {
  return xs.reduce((a, b) => a + b, 0) / Math.max(1, xs.length);
}
function stddev(xs: number[]) {
  const m = avg(xs);
  const v = avg(xs.map((x) => (x - m) ** 2));
  return Math.sqrt(v);
}
function toBand(p: number) {
  // Simple mapping: 0..1 -> 4.0..9.0 (tweak if you have a calibrated curve)
  return 4 + p * 5;
}
========== File 11: pages/api/study-buddy/sessions.ts ==========
// pages/api/study-buddy/sessions.ts
import type { NextApiRequest, NextApiResponse } from 'next';
import { createClient } from '@supabase/supabase-js';
import { v4 as uuidv4, validate as uuidValidate } from 'uuid';
import { z } from 'zod';

type StudySessionItem = { skill: string; minutes: number; topic?: string | null; status?: 'pending' | 'started' | 'completed'; note?: string | null };
type StudySessionRecord = {
  id: string;
  user_id: string | null;
  items: StudySessionItem[];
  state: 'pending' | 'started' | 'completed' | 'cancelled';
  created_at: string;
  updated_at: string;
  started_at: string | null;
  ended_at: string | null;
  duration_minutes: number | null;
  xp_earned: number;
};

const SUPABASE_URL = process.env.SUPABASE_URL;
const SUPABASE_SERVICE_ROLE_KEY = process.env.SUPABASE_SERVICE_ROLE_KEY;

function getAdminClient() {
  if (!SUPABASE_URL || !SUPABASE_SERVICE_ROLE_KEY) {
    throw new Error('Missing SUPABASE_URL / SUPABASE_SERVICE_ROLE_KEY in environment.');
  }
  return createClient(SUPABASE_URL, SUPABASE_SERVICE_ROLE_KEY);
}

function normalizeUserId(raw?: any): string | null {
  if (!raw || typeof raw !== 'string') return null;
  const trimmed = raw.trim();
  if (trimmed.toLowerCase() === 'null') return null;
  return uuidValidate(trimmed) ? trimmed : null;
}

const Body = z.object({
  userId: z.string().uuid().optional().nullable(),
  items: z.array(
    z.object({
      skill: z.string().min(1).max(64),
      minutes: z.number().int().min(1).max(300),
    })
  ).min(1).max(200),
});

export default async function handler(req: NextApiRequest, res: NextApiResponse) {
  if (req.method !== 'POST') {
    res.setHeader('Allow', 'POST');
    return res.status(405).json({ error: 'method_not_allowed' });
  }

  const parsed = Body.safeParse(req.body ?? {});
  if (!parsed.success) {
    return res.status(400).json({ error: 'invalid_body', details: parsed.error.flatten() });
  }

  const { items } = parsed.data;
  const user_id = normalizeUserId(parsed.data.userId ?? undefined);

  let supabaseAdmin;
  try {
    supabaseAdmin = getAdminClient();
  } catch (err: any) {
    console.error('[study-sessions] admin client error', err);
    return res.status(500).json({ error: 'supabase_not_configured' });
  }

  const id = uuidv4();
  const now = new Date().toISOString();

  const normalizedItems = items.map((item) => ({
    skill: item.skill,
    minutes: item.minutes,
    topic: null,
    status: 'pending' as const,
    note: null,
  }));

  const totalMinutes = normalizedItems.reduce((sum, item) => sum + item.minutes, 0);

  const payload: StudySessionRecord = {
    id,
    user_id,
    items: normalizedItems,
    state: 'pending',
    created_at: now,
    updated_at: now,
    started_at: null,
    ended_at: null,
    duration_minutes: totalMinutes,
    xp_earned: 0,
  };

  try {
    const { data, error, status, statusText } = await supabaseAdmin
      .from<StudySessionRecord>('study_buddy_sessions')
      .insert(payload)
      .select('*');

    if (error) {
      console.error('[study-sessions] insert error:', { error, status, statusText });
      const message = (error && (error.message || JSON.stringify(error))) ?? 'db_insert_failed';
      return res.status(500).json({ error: message });
    }

    const inserted = Array.isArray(data) && data.length > 0 ? data[0] : payload;
    return res.status(201).json(inserted);
  } catch (err: any) {
    console.error('[study-sessions] unexpected exception', err);
    const info = (err && err.message) ? String(err.message) : 'unknown_error';
    return res.status(500).json({ error: info });
  }
}
========== File 12: pages/api/check-otp.ts ==========
import type { NextApiRequest, NextApiResponse } from 'next';
import { z } from 'zod';
import Twilio from 'twilio';
import { createClient } from '@supabase/supabase-js';
import { env } from '@/lib/env';
import { rateLimit } from '@/lib/rateLimit';

const client = Twilio(env.TWILIO_ACCOUNT_SID, env.TWILIO_AUTH_TOKEN);
const SERVICE_SID = env.TWILIO_VERIFY_SERVICE_SID;
const supa = createClient(env.SUPABASE_URL, env.SUPABASE_SERVICE_KEY); // server only

const BodySchema = z.object({
  phone: z.string(),
  code: z.string(),
});

export type CheckOtpResponse =
  | { ok: true; message: string }
  | { ok: false; error: string };

export default async function checkOtp(
  req: NextApiRequest,
  res: NextApiResponse<CheckOtpResponse>
) {
  if (req.method !== 'POST') {
    res.setHeader('Allow', 'POST');
    throw new Error('Method Not Allowed');
  }

  if (!(await rateLimit(req, res))) return;

  const result = BodySchema.safeParse(req.body);
  if (!result.success) {
    return res
      .status(400)
      .json({ ok: false, error: 'Invalid request body' });
  }

  const { phone, code } = result.data;
  try {
    const check = await client.verify
      .services(SERVICE_SID)
      .verificationChecks.create({ to: phone, code });
    if (check.status !== 'approved') {
      return res.status(400).json({ ok: false, error: 'Invalid code' });
    }

    const { error: supErr } = await supa
      .from('profiles')
      .upsert({ phone, phone_verified: true, updated_at: new Date() });

    if (supErr) {
      if ((supErr as any).code === 'user_not_found') {
        return res
          .status(404)
          .json({ ok: false, error: 'No account found for that email/phone.' });
      }
      return res.status(500).json({ ok: false, error: (supErr as any).message });
    }

    return res.json({ ok: true, message: 'Phone verified' });
  } catch (err) {
    const message = err instanceof Error ? err.message : 'Unknown error';
    return res.status(500).json({ ok: false, error: message });
  }
}
========== File 13: pages/api/streak.ts ==========
import { NextApiRequest, NextApiResponse } from 'next';
import { createClient, type SupabaseClient } from '@supabase/supabase-js';
import { supabaseService, supabaseServer } from '@/lib/supabaseServer';

const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL!;
const supabaseAnonKey = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!;

export type StreakData = {
  current_streak: number;
  longest_streak: number;
  last_activity_date: string | null; // YYYY-MM-DD
  next_restart_date: string | null;  // not persisted on 'streaks' table
  shields: number;                   // not persisted on 'streaks' table
};

const getDayKey = (d = new Date()) => d.toISOString().split('T')[0];
const ms = (h: number) => h * 60 * 60 * 1000;

export default async function handler(req: NextApiRequest, res: NextApiResponse) {
  let token = req.headers.authorization?.split(' ')[1] ?? null;
  let refreshToken: string | null = null;

  if (!token) {
    try {
      const cookieClient = supabaseServer(req);
      const { data, error } = await cookieClient.auth.getSession();
      if (error) {
        console.error('[API/streak] Cookie session lookup failed:', error);
      }
      token = data?.session?.access_token ?? null;
      refreshToken = data?.session?.refresh_token ?? null;
    } catch (error) {
      console.error('[API/streak] Cookie session client unavailable:', error);
    }
  }

  if (!token) return res.status(401).json({ error: 'No authorization token' });

  // RLS client (acts as the user)
  let supabaseUser: SupabaseClient;
  try {
    supabaseUser = createClient(supabaseUrl, supabaseAnonKey, {
      auth: { autoRefreshToken: false, persistSession: false },
    });
  } catch (error) {
    console.error('[API/streak] User client creation failed:', error);
    return res.status(503).json({ error: 'service_unavailable' });
  }

  try {
    await supabaseUser.auth.setSession({
      access_token: token,
      refresh_token: refreshToken ?? '',
    });
  } catch (error) {
    console.error('[API/streak] User session setup failed:', error);
    return res.status(503).json({ error: 'service_unavailable' });
  }

  let user = null;
  try {
    const { data: { user: authUser }, error: authError } = await supabaseUser.auth.getUser();
    if (authError || !authUser) return res.status(401).json({ error: 'Invalid token' });
    user = authUser;
  } catch (error) {
    console.error('[API/streak] Auth verification failed:', error);
    return res.status(503).json({ error: 'auth_unavailable' });
  }

  try {
    // Read current row (aliases to expected keys)
    let { data: row, error: fetchError } = await supabaseUser
      .from('streaks')
      .select('user_id,current_streak:current,longest_streak:longest,last_activity_date:last_active_date,updated_at')
      .eq('user_id', user.id)
      .maybeSingle();

    if (fetchError && fetchError.code !== 'PGRST116') throw fetchError;

    // If no row, create one
    const baseInsert = { user_id: user.id, current: 0, longest: 0, last_active_date: null, updated_at: null };

    if (!row) {
      const { data: inserted, error: insertError } = await supabaseUser
        .from('streaks')
        .insert(baseInsert)
        .select('user_id,current_streak:current,longest_streak:longest,last_activity_date:last_active_date,updated_at')
        .single();
      if (insertError) {
        console.error('[API/streak] Insert failed:', insertError);

        const shouldRetryWithService =
          insertError?.code === '42501' || insertError?.message?.includes('row-level security');

        if (shouldRetryWithService) {
          try {
            const svc = supabaseService();
            const { data: serviceInserted, error: serviceErr } = await svc
              .from('streaks')
              .insert(baseInsert)
              .select('user_id,current_streak:current,longest_streak:longest,last_activity_date:last_active_date,updated_at')
              .single();

            if (serviceErr) {
              console.error('[API/streak] Service insert failed:', serviceErr);
            } else {
              row = serviceInserted ?? row;
            }
          } catch (serviceClientError) {
            console.error('[API/streak] Service client unavailable for insert:', serviceClientError);
          }
        }

        // Fallback: treat as new streak of 0 when all attempts fail
        if (!row) {
          row = {
            user_id: user.id,
            current_streak: 0,
            longest_streak: 0,
            last_activity_date: null,
            updated_at: null,
          } as typeof row;
        }
      } else {
        row = inserted;
      }
    }

    let shieldTokens = 0;
    try {
      const { data: shieldRow } = await supabaseUser
        .from('streak_shields')
        .select('tokens')
        .eq('user_id', user.id)
        .maybeSingle();
      shieldTokens = shieldRow?.tokens ?? 0;
    } catch (shieldErr) {
      console.warn('[API/streak] Unable to load shields', shieldErr);
      shieldTokens = 0;
    }

    // Build response object (shields/next_restart_date are not stored on this table)
    const asResponse = (r: typeof row, shields = shieldTokens): StreakData => ({
      current_streak: r?.current_streak ?? 0,
      longest_streak: r?.longest_streak ?? r?.current_streak ?? 0,
      last_activity_date: r?.last_activity_date ?? null,
      next_restart_date: null,
      shields,
    });

    if (req.method === 'GET') {
      return res.status(200).json(asResponse(row));
    }

    if (req.method === 'POST') {
      const { action, date } = req.body as { action?: 'use' | 'claim' | 'schedule'; date?: string };

      const now = new Date();
      const today = getDayKey(now);
      const previousCurrent = row.current_streak ?? 0;

      if (action === 'claim') {
        const nextTokens = shieldTokens + 1;
        try {
          const { data: updatedShield, error: shieldErr } = await supabaseUser
            .from('streak_shields')
            .upsert({ user_id: user.id, tokens: nextTokens }, { onConflict: 'user_id' })
            .select('tokens')
            .single();
          if (shieldErr) throw shieldErr;
          shieldTokens = updatedShield?.tokens ?? nextTokens;
          await supabaseUser.from('streak_shield_logs').insert({ user_id: user.id, action: 'claim' });
        } catch (err) {
          console.error('[API/streak] Claim shield failed', err);
          return res.status(500).json({ error: 'Failed to claim shield' });
        }
        return res.status(200).json(asResponse(row, shieldTokens));
      }

      if (action === 'schedule') {
        if (!date) return res.status(400).json({ error: 'Date required for scheduling' });
        return res.status(200).json({ ...asResponse(row, shieldTokens), next_restart_date: date });
      }

      const spentShield = action === 'use';
      if (spentShield && shieldTokens <= 0) {
        return res.status(400).json({ error: 'No shields available' });
      }

      if (!spentShield && row.last_activity_date === today) {
        return res.status(200).json(asResponse(row, shieldTokens));
      }

      const lastTs = row.updated_at ? new Date(row.updated_at) : null;
      const within24h = lastTs ? now.getTime() - lastTs.getTime() <= ms(24) : false;

      let newCurrent = 1;
      if (spentShield) {
        newCurrent = previousCurrent + 1;
      } else if (within24h) {
        newCurrent = previousCurrent + 1;
      } else {
        newCurrent = 1;
      }

      const previousLongest = row.longest_streak ?? row.current_streak ?? 0;
      const newLongest = Math.max(previousLongest, newCurrent);

      const { data: updatedRow, error: upErr } = await supabaseUser
        .from('streaks')
        .update({
          current: newCurrent,
          longest: newLongest,
          last_active_date: today,
          updated_at: now.toISOString(),
        })
        .eq('user_id', user.id)
        .select('user_id,current_streak:current,longest_streak:longest,last_activity_date:last_active_date,updated_at')
        .single();

      if (upErr) {
        console.error('[API/streak] Update failed:', upErr);
        return res.status(200).json(asResponse(row, shieldTokens));
      }

      let tokensDelta = 0;
      if (spentShield) tokensDelta -= 1;
      if (newCurrent > previousCurrent && newCurrent % 7 === 0) tokensDelta += 1;

      let nextTokens = shieldTokens;
      if (tokensDelta !== 0) {
        nextTokens = Math.max(0, shieldTokens + tokensDelta);
        try {
          const { data: shieldRow, error: shieldUpdateErr } = await supabaseUser
            .from('streak_shields')
            .upsert({ user_id: user.id, tokens: nextTokens }, { onConflict: 'user_id' })
            .select('tokens')
            .single();
          if (shieldUpdateErr) {
            console.error('[API/streak] Failed to update shields', shieldUpdateErr);
          } else {
            nextTokens = shieldRow?.tokens ?? nextTokens;
          }
        } catch (shieldUpdateError) {
          console.error('[API/streak] Shield upsert failed', shieldUpdateError);
        }
      }

      if (spentShield) {
        await supabaseUser.from('streak_shield_logs').insert({ user_id: user.id, action: 'use' });
      }
      if (tokensDelta > 0) {
        await supabaseUser.from('streak_shield_logs').insert({ user_id: user.id, action: 'claim' });
      }

      return res.status(200).json(asResponse(updatedRow, nextTokens));
    }

    return res.status(405).json({ error: 'Method not allowed' });
  } catch (err: any) {
    console.error('[API/streak] Error:', err);
    return res.status(500).json({ error: err.message || 'Internal server error' });
  }
}
========== File 14: lib/authServer.ts ==========
import { env } from "@/lib/env";
// lib/authServer.ts
import type { NextApiRequest } from 'next';
import { createClient } from '@supabase/supabase-js';

const URL = env.NEXT_PUBLIC_SUPABASE_URL;
const ANON = env.NEXT_PUBLIC_SUPABASE_ANON_KEY;
const SERVICE = env.SUPABASE_SERVICE_ROLE_KEY || '';

function b64urlToJson(b64: string) {
  const pad = (s:string) => s + '=' * ((4 - (s.length % 4)) % 4);
  const str = Buffer.from(pad(b64).replace(/-/g,'+').replace(/_/g,'/'), 'base64').toString('utf8');
  return JSON.parse(str);
}
function decodeUserId(token: string | null): string | null {
  if (!token) return null;
  try {
    const [_, payload] = token.split('.');
    const p = b64urlToJson(payload);
    return p.sub || p.user_id || null;
  } catch { return null; }
}

export type ServerAuth = {
  user: { id: string; email?: string } | null;
  supabaseDb: ReturnType<typeof createClient>;
  supabaseAuth: ReturnType<typeof createClient>;
  token: string | null;
};

export async function getUserServer(req: NextApiRequest): Promise<ServerAuth> {
  const authHeader = (req.headers.authorization as string) || '';
  const token = authHeader.startsWith('Bearer ') ? authHeader.slice(7) : null;

  // Client used for auth/RLS-aware queries (carries the bearer)
  const supabaseAuth = createClient(URL, ANON, { global: { headers: { Authorization: authHeader } } });

  // Client used for storage/DB writes; prefers service role (bypasses RLS)
  const supabaseDb = SERVICE ? createClient(URL, SERVICE) : supabaseAuth;

  let userId: string | null = null;
  try {
    if (token) {
      const { data } = await supabaseAuth.auth.getUser(token);
      userId = data?.user?.id ?? decodeUserId(token);
    }
  } catch {
    userId = decodeUserId(token);
  }

  return { user: userId ? { id: userId } : null, supabaseDb, supabaseAuth, token };
}
========== File 15: lib/supabaseAdmin.ts ==========
// lib/supabaseAdmin.ts
// Server-only Supabase admin (service-role) client with HMR-safe caching.

import { createClient, type SupabaseClient } from '@supabase/supabase-js';
import { env } from '@/lib/env';

// Accept either server or public URL (both point to the same project)
const url = env.SUPABASE_URL || env.NEXT_PUBLIC_SUPABASE_URL;

// Accept either name for the service key
const serviceRoleKey = env.SUPABASE_SERVICE_ROLE_KEY || env.SUPABASE_SERVICE_KEY;

const isServer = typeof window === 'undefined';
const isProdRuntime =
  typeof process !== 'undefined' &&
  process.env.NODE_ENV === 'production' &&
  process.env.VERCEL_ENV === 'production';

if (isServer && process.env.NODE_ENV !== 'test') {
  if (!url || !serviceRoleKey) {
    if (isProdRuntime) {
      if (!url) {
        throw new Error('Missing SUPABASE_URL (or NEXT_PUBLIC_SUPABASE_URL fallback)');
      }
      if (!serviceRoleKey) {
        throw new Error('Missing SUPABASE_SERVICE_ROLE_KEY (or SUPABASE_SERVICE_KEY)');
      }
    } else {
      console.warn(
        'Supabase admin credentials not fully configured. Falling back to stub admin client.',
      );
    }
  }
}

/** Lightweight test stub for CI/test where keys are intentionally absent */
function makeAdminTestStub(): SupabaseClient<any, 'public', any> {
  const fromHandler = (_table: string) => ({
    async insert(rows: any) {
      const toArr = Array.isArray(rows) ? rows : [rows];
      return { data: toArr.map((r: any, i: number) => ({ id: `stub-${i + 1}`, ...r })), error: null };
    },
    async select(_cols?: string) { return { data: [], error: null }; },
    async update(_rows: any) { return { data: null, error: null }; },
    async delete() { return { data: null, error: null }; },
    eq() { return this; },
    order() { return this; },
  });

  return {
    // @ts-expect-error minimal stub
    from: fromHandler,
    auth: {
      // @ts-expect-error minimal stub
      getUser: async () => ({ data: { user: null }, error: null }),
      // @ts-expect-error minimal stub
      getSession: async () => ({ data: { session: null }, error: null }),
    },
  };
}

declare global {
  // eslint-disable-next-line no-var
  var __supabaseAdmin: SupabaseClient | undefined;
}

export const supabaseAdmin: SupabaseClient =
  globalThis.__supabaseAdmin ??
  (() => {
    if (!isServer) {
      // Never expose service-role credentials in the browser; fall back to stub behaviour.
      // @ts-expect-error test stub used for client fallbacks
      const stub = makeAdminTestStub();
      // @ts-expect-error cache
      globalThis.__supabaseAdmin = stub;
      // @ts-expect-error returning stub client shape
      return stub;
    }

    if ((process.env.NODE_ENV === 'test' || !url || !serviceRoleKey) && !isProdRuntime) {
      // CI/test path
      // @ts-expect-error test stub
      const stub = makeAdminTestStub();
      // @ts-expect-error cache
      globalThis.__supabaseAdmin = stub;
      // @ts-expect-error
      return stub;
    }

    const client = createClient(url!, serviceRoleKey!, {
      auth: { persistSession: false, autoRefreshToken: false, detectSessionInUrl: false },
      global: { fetch: (...args) => fetch(...args) },
    });

    // cache for HMR/dev
    // @ts-expect-error cache
    globalThis.__supabaseAdmin = client;
    return client;
  })();

export default supabaseAdmin;

export function getAdminClient(): SupabaseClient {
  return supabaseAdmin;
}
========== File 16: lib/supabaseSSR.ts ==========
// lib/supabaseSSR.ts (no-SSR version)
// Drop-in replacement so existing API routes keep working without @supabase/ssr.
import type { NextApiRequest, NextApiResponse } from 'next';
import { createClient } from '@supabase/supabase-js';
import cookie from 'cookie';

function bearerFromCookies(req: NextApiRequest): string | undefined {
  const raw = req.headers.cookie;
  if (!raw) return;
  const parsed = cookie.parse(raw);
  const t = parsed['sb-access-token'];
  return t ? `Bearer ${t}` : undefined;
}

export function supabaseServer(req: NextApiRequest, _res: NextApiResponse) {
  const url = process.env.NEXT_PUBLIC_SUPABASE_URL!;
  const anon = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!;
  if (!url || !anon) {
    throw new Error('Missing NEXT_PUBLIC_SUPABASE_URL or NEXT_PUBLIC_SUPABASE_ANON_KEY');
  }

  // Prefer Authorization header; fall back to cookie if present.
  const auth = (req.headers.authorization as string | undefined) || bearerFromCookies(req);

  return createClient(url, anon, {
    global: { headers: auth ? { Authorization: auth } : {} },
  });
}

// Back-compat alias so existing imports keep working
export const createSSRClient = supabaseServer;
========== File 17: functions/activities/index.ts ==========
// /functions/activities/index.ts
import { createClient } from 'https://esm.sh/@supabase/supabase-js@2.39.3'

const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',
}

Deno.serve(async (req) => {
  if (req.method === 'OPTIONS') {
    return new Response('ok', { headers: corsHeaders })
  }

  try {
    const supabaseClient = createClient(
      Deno.env.get('SUPABASE_URL') ?? '',
      Deno.env.get('SUPABASE_ANON_KEY') ?? '',
      {
        global: {
          headers: { Authorization: req.headers.get('Authorization')! },
        },
      }
    )

    const {
      data: { user },
      error: authError,
    } = await supabaseClient.auth.getUser()

    if (authError || !user) {
      return new Response(JSON.stringify({ error: 'Unauthorized' }), {
        status: 401,
        headers: { ...corsHeaders, 'Content-Type': 'application/json' },
      })
    }

    const url = new URL(req.url)
    const path = url.pathname.split('/').pop()

    switch (path) {
      case 'get-activities':
        return await handleGetActivities(req, supabaseClient, user)
      case 'create-task':
        return await handleCreateTask(req, supabaseClient, user)
      case 'get-tasks':
        return await handleGetTasks(req, supabaseClient, user)
      case 'update-task':
        return await handleUpdateTask(req, supabaseClient, user)
      default:
        return new Response(JSON.stringify({ error: 'Not found' }), {
          status: 404,
          headers: { ...corsHeaders, 'Content-Type': 'application/json' },
        })
    }
  } catch (error) {
    return new Response(JSON.stringify({ error: error.message }), {
      status: 500,
      headers: { ...corsHeaders, 'Content-Type': 'application/json' },
    })
  }
})

// Get user activities
async function handleGetActivities(req: Request, supabase: any, user: any) {
  const { searchParams } = new URL(req.url)
  const limit = parseInt(searchParams.get('limit') || '50')
  const offset = parseInt(searchParams.get('offset') || '0')
  const activityType = searchParams.get('type')
  const startDate = searchParams.get('start_date')
  const endDate = searchParams.get('end_date')

  let query = supabase
    .from('user_activities')
    .select('*')
    .eq('user_id', user.id)
    .order('created_at', { ascending: false })
    .range(offset, offset + limit - 1)

  if (activityType) {
    query = query.eq('activity_type', activityType)
  }
  if (startDate) {
    query = query.gte('created_at', startDate)
  }
  if (endDate) {
    query = query.lte('created_at', endDate)
  }

  const { data, error } = await query

  if (error) throw error

  // Format dates for frontend
  const activities = data.map((activity: any) => ({
    ...activity,
    created_at: new Date(activity.created_at).toISOString(),
    formatted_date: new Date(activity.created_at).toLocaleString(),
  }))

  return new Response(JSON.stringify({ activities }), {
    headers: { ...corsHeaders, 'Content-Type': 'application/json' },
  })
}

// Create task for Codex
async function handleCreateTask(req: Request, supabase: any, user: any) {
  const body = await req.json()
  const {
    title,
    description,
    priority = 'medium',
    due_date,
    module,
    task_type,
    reference_id,
    reference_table,
  } = body

  // Find Codex user (assuming Codex has email 'codex@system.com')
  const { data: codexUser, error: codexError } = await supabase
    .from('profiles')
    .select('id, email')
    .eq('email', 'codex@system.com')
    .single()

  if (codexError || !codexUser) {
    throw new Error('Codex user not found. Please create a user with email codex@system.com')
  }

  // Create task using database function
  const { data: taskData, error: taskError } = await supabase.rpc(
    'create_task_with_activity',
    {
      p_title: title,
      p_description: description,
      p_created_by: user.id,
      p_assigned_to: codexUser.id,
      p_priority: priority,
      p_due_date: due_date,
      p_module: module,
      p_task_type: task_type,
      p_reference_id: reference_id,
      p_reference_table: reference_table,
    }
  )

  if (taskError) throw taskError

  return new Response(
    JSON.stringify({
      message: 'Task created successfully',
      task_id: taskData,
      assigned_to: {
        id: codexUser.id,
        email: codexUser.email,
      },
    }),
    {
      headers: { ...corsHeaders, 'Content-Type': 'application/json' },
    }
  )
}

// Get tasks (assigned to user or created by user)
async function handleGetTasks(req: Request, supabase: any, user: any) {
  const { searchParams } = new URL(req.url)
  const status = searchParams.get('status')
  const assigned = searchParams.get('assigned') === 'true'

  let query = supabase
    .from('task_assignments')
    .select(`
      *,
      creator:profiles!task_assignments_created_by_fkey (id, email, full_name, avatar_url),
      assignee:profiles!task_assignments_assigned_to_fkey (id, email, full_name, avatar_url),
      comments:task_comments(count),
      comments_details:task_comments(*, commenter:profiles(id, full_name, avatar_url))
    `)

  if (assigned) {
    query = query.eq('assigned_to', user.id)
  } else {
    query = query.or(`created_by.eq.${user.id},assigned_to.eq.${user.id}`)
  }

  if (status) {
    query = query.eq('status', status)
  }

  query = query.order('created_at', { ascending: false })

  const { data: tasks, error } = await query

  if (error) throw error

  return new Response(JSON.stringify({ tasks }), {
    headers: { ...corsHeaders, 'Content-Type': 'application/json' },
  })
}

// Update task status
async function handleUpdateTask(req: Request, supabase: any, user: any) {
  const { task_id, status, comment } = await req.json()

  // Update task status
  const { data: task, error: updateError } = await supabase
    .from('task_assignments')
    .update({
      status,
      ...(status === 'completed' ? { completed_at: new Date().toISOString() } : {}),
    })
    .eq('id', task_id)
    .select()
    .single()

  if (updateError) throw updateError

  // Add comment if provided
  if (comment) {
    const { error: commentError } = await supabase
      .from('task_comments')
      .insert({
        task_id,
        user_id: user.id,
        comment,
        metadata: { status_change: status },
      })

    if (commentError) throw commentError
  }

  // Log activity
  await supabase.rpc('log_user_activity', {
    p_user_id: user.id,
    p_activity_type: 'task_updated',
    p_description: `Updated task "${task.title}" status to ${status}`,
    p_metadata: {
      task_id,
      old_status: task.status,
      new_status: status,
      comment: comment || null,
    },
    p_related_table: 'task_assignments',
    p_related_id: task_id,
  })

  return new Response(
    JSON.stringify({
      message: 'Task updated successfully',
      task,
    }),
    {
      headers: { ...corsHeaders, 'Content-Type': 'application/json' },
    }
  )
}
========== File 1: pages/api/ai/coach.ts ==========
// pages/api/ai/coach.ts
import type { NextApiRequest, NextApiResponse } from "next";
import { createClient } from "@supabase/supabase-js";

/* -------------------------------------------------------------------------- */
/* ENV expected (set in .env.local)                                           */
/* -------------------------------------------------------------------------- */
/*
GROQ_API_KEY=gsk-...
GROQ_API_BASE=https://api.groq.com/openai/v1
GROQ_MODEL=llama-3.3-70b-versatile

GEMINI_API_KEY=AIza...
GEMINI_API_BASE=https://generativelanguage.googleapis.com/v1beta/openai
GEMINI_MODEL=gemini-1.5-flash-latest

OPENAI_API_KEY=sk-...
OPENAI_API_BASE=https://api.openai.com/v1
OPENAI_MODEL=gpt-4o-mini

DEEPSEEK_API_KEY=sk-...
DEEPSEEK_API_BASE=https://api.deepseek.com
DEEPSEEK_MODEL=deepseek-chat

GROK_API_KEY=xai-...
GROK_API_BASE=https://api.x.ai/v1
GROK_MODEL=grok-4-latest

SUPABASE_URL=...
SUPABASE_SERVICE_ROLE_KEY=...
AI_MOCK=1            # optional for dev offline
*/

const supabaseAdmin = createClient(
  process.env.SUPABASE_URL!,
  process.env.SUPABASE_SERVICE_ROLE_KEY!
);

/* -------------------------------------------------------------------------- */
/* Provider chain                                                             */
/* -------------------------------------------------------------------------- */

type Prov = {
  name: "groq" | "gemini" | "openai" | "deepseek" | "grok";
  baseURL: string;
  apiKey?: string;
  model: string;
};

const PROVIDERS: Prov[] = [
  {
    name: "groq",
    baseURL: process.env.GROQ_API_BASE || "https://api.groq.com/openai/v1",
    apiKey: process.env.GROQ_API_KEY,
    model: process.env.GROQ_MODEL || "llama-3.3-70b-versatile",
  },
  {
    name: "gemini",
    baseURL:
      process.env.GEMINI_API_BASE ||
      "https://generativelanguage.googleapis.com/v1beta/openai",
    apiKey: process.env.GEMINI_API_KEY,
    model: process.env.GEMINI_MODEL || "gemini-1.5-flash-latest",
  },
  {
    name: "openai",
    baseURL: process.env.OPENAI_API_BASE || "https://api.openai.com/v1",
    apiKey: process.env.OPENAI_API_KEY,
    model: process.env.OPENAI_MODEL || "gpt-4o-mini",
  },
  {
    name: "deepseek",
    baseURL: process.env.DEEPSEEK_API_BASE || "https://api.deepseek.com",
    apiKey: process.env.DEEPSEEK_API_KEY,
    model: process.env.DEEPSEEK_MODEL || "deepseek-chat",
  },
  {
    name: "grok",
    baseURL: process.env.GROK_API_BASE || "https://api.x.ai/v1",
    apiKey: process.env.GROK_API_KEY,
    model: process.env.GROK_MODEL || "grok-4-latest",
  },
];

/* -------------------------------------------------------------------------- */
/* Helpers                                                                    */
/* -------------------------------------------------------------------------- */

const SYSTEM_PROMPT =
  "You are an IELTS coaching assistant. Provide concise actionable suggestions (3–6), each with a short title, a 1–2 sentence detail, and estimated minutes to practice. Output pure JSON only.";

function extractJSON(str: string): any {
  if (!str) return null;
  try {
    return JSON.parse(str);
  } catch {}
  const fence = str.match(/```(?:json)?\s*([\s\S]*?)```/i);
  if (fence) try { return JSON.parse(fence[1]); } catch {}
  const block = str.match(/\{[\s\S]*\}/);
  if (block) try { return JSON.parse(block[0]); } catch {}
  return { raw: str };
}

async function callProvider(p: Prov, payload: any) {
  if (!p.apiKey)
    return { ok: false, err: { status: 500, detail: `${p.name} key missing` }, provider: p.name };

  try {
    const r = await fetch(`${p.baseURL}/chat/completions`, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        Authorization: `Bearer ${p.apiKey}`,
      },
      body: JSON.stringify({ ...payload, model: p.model }),
    });

    const txt = await r.text();
    if (!r.ok)
      return {
        ok: false,
        err: { status: r.status, detail: (() => { try { return JSON.parse(txt); } catch { return txt; } })() },
        provider: p.name,
      };

    const json = JSON.parse(txt);
    const content =
      json?.choices?.[0]?.message?.content ??
      json?.choices?.[0]?.text ??
      "";

    if (!content.trim())
      return { ok: false, err: { status: 502, detail: "Empty content" }, provider: p.name };

    return { ok: true, content, provider: p.name };
  } catch (e: any) {
    return { ok: false, err: { status: 500, detail: e.message || String(e) }, provider: p.name };
  }
}

/* -------------------------------------------------------------------------- */
/* Handler                                                                    */
/* -------------------------------------------------------------------------- */

export default async function handler(req: NextApiRequest, res: NextApiResponse) {
  if (req.method !== "POST")
    return res.status(405).json({ error: "Method not allowed" });

  const { userId = null, context = "", goal = "" } = req.body ?? {};

  /* Mock mode --------------------------------------------------------------- */
  if (process.env.AI_MOCK === "1") {
    const mock = {
      id: "mock",
      summary: "Mock AI response — providers unavailable.",
      suggestions: [
        { id: "s1", title: "Plan paragraphs", detail: "Spend 5 min outlining key ideas.", estimatedMinutes: 10 },
        { id: "s2", title: "Add connectors", detail: "Use clear linkers to connect ideas.", estimatedMinutes: 8 },
        { id: "s3", title: "Rewrite one paragraph", detail: "Improve flow and coherence.", estimatedMinutes: 12 },
      ],
    };
    await supabaseAdmin.from("ai_logs").insert([
      { user_id: userId, request: JSON.stringify({ provider: "mock", context, goal }), response: JSON.stringify(mock), status: "ok" },
    ]);
    return res.status(200).json(mock);
  }

  const userPrompt = `User goal: ${goal}\nContext: ${context}\nReturn JSON: { id, summary, suggestions: [{id,title,detail,estimatedMinutes}], reasoning? }`;

  const payload = {
    messages: [
      { role: "system", content: SYSTEM_PROMPT },
      { role: "user", content: userPrompt },
    ],
    max_tokens: 700,
    temperature: 0.2,
  };

  const attempts: Array<{ provider: string; status?: number; detail?: any }> = [];

  for (const p of PROVIDERS) {
    const result = await callProvider(p, payload);

    if (result.ok) {
      const parsed = extractJSON(result.content);
      await supabaseAdmin.from("ai_logs").insert([
        {
          user_id: userId,
          request: JSON.stringify({ provider: result.provider, model: p.model, context, goal }),
          response: JSON.stringify(parsed),
          status: "ok",
        },
      ]);
      console.log(`[ai/coach] ✅ responded from ${result.provider}`);
      return res.status(200).json(parsed);
    }

    attempts.push({ provider: p.name, status: result.err?.status, detail: result.err?.detail });
    await supabaseAdmin.from("ai_logs").insert([
      {
        user_id: userId,
        request: JSON.stringify({ provider: p.name, model: p.model, context, goal }),
        response: JSON.stringify(result.err),
        status: "error",
      },
    ]);
    console.warn(`[ai/coach] ❌ ${p.name} failed`, result.err);
  }

  return res.status(502).json({ error: "All AI providers failed", attempts });
}

================================================================================


========== File 2: pages/api/ai/coach/action.ts ==========
import type { NextApiRequest, NextApiResponse } from 'next';
import { createClient } from '@supabase/supabase-js';

const supabase = createClient(SUPABASE_URL, SUPABASE_SERVICE_ROLE_KEY);

export default async function actionHandler(req: NextApiRequest, res: NextApiResponse) {
  if (req.method !== 'POST') return res.status(405).json({ error: 'Method not allowed' });
  const { suggestionId, userId = null } = req.body ?? {};
  try {
    await supabase.from('ai_actions').insert([{ user_id: userId, suggestion_id: suggestionId, created_at: new Date().toISOString() }]);
    return res.status(200).json({ success: true });
  } catch (e: any) {
    console.error('ai action insert', e);
    return res.status(500).json({ error: 'Failed to record action' });
  }
}

================================================================================


========== File 3: pages/api/ai/speaking/grade.ts ==========
import type { NextApiRequest, NextApiResponse } from 'next';
import { z } from 'zod';
import { createClient } from '@supabase/supabase-js';

const BodySchema = z.object({
  attemptId: z.string().optional(),   // if provided, we’ll look for a transcript or audio (future)
  transcript: z.string().optional(),  // if provided, we grade based on this text
});

type AIFeedback = {
  bandOverall: number;
  fluency: number;
  lexical: number;
  grammar: number;
  pronunciation: number;
  notes: string[];
};

type Resp = { ok: true; feedback: AIFeedback } | { ok: false; error: string };

const openaiModel = process.env.OPENAI_SPEAKING_MODEL || 'gpt-4o-mini';

export default async function handler(req: NextApiRequest, res: NextApiResponse<Resp>) {
  if (req.method !== 'POST') return res.status(405).json({ ok: false, error: 'Method not allowed' });

  const parse = BodySchema.safeParse(req.body);
  if (!parse.success) {
    return res.status(400).json({ ok: false, error: parse.error.issues.map(i => i.message).join(', ') });
  }
  const { attemptId, transcript } = parse.data;

  // 1) Try transcript (provided directly)
  let text = (transcript || '').trim();

  // 2) Fallback: if attemptId provided and `attempts_speaking.transcript` exists, use that
  if (!text && attemptId && process.env.NEXT_PUBLIC_SUPABASE_URL && (process.env.SUPABASE_SERVICE_ROLE_KEY || process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY)) {
    try {
      const supabase = createClient(
        process.env.NEXT_PUBLIC_SUPABASE_URL!,
        (process.env.SUPABASE_SERVICE_ROLE_KEY || process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY)!,
      );
      const { data } = await supabase.from('attempts_speaking').select('transcript').eq('id', attemptId).single();
      if (data?.transcript) text = String(data.transcript);
    } catch {
      // ignore
    }
  }

  // 3) Grade
  let feedback: AIFeedback;
  try {
    if (process.env.OPENAI_API_KEY && text) {
      feedback = await gradeWithOpenAI(text);
    } else {
      feedback = heuristic(text);
    }
  } catch {
    feedback = heuristic(text);
  }

  return res.status(200).json({ ok: true, feedback });
}

function heuristic(text: string): AIFeedback {
  const wc = text.trim() ? text.trim().split(/\s+/).length : 0;
  const base = 6 + Math.min(1, Math.max(0, (wc - 120) / 200));
  const band = clampHalf(base, 4, 9);
  return {
    bandOverall: band,
    fluency: clampHalf(band - 0.5, 4, 9),
    lexical: clampHalf(band, 4, 9),
    grammar: clampHalf(band - 0.5, 4, 9),
    pronunciation: clampHalf(band, 4, 9),
    notes: [
      'Maintain steady pace; avoid long pauses.',
      'Use more topic-specific vocabulary.',
      'Vary sentence structures; check articles and prepositions.',
      'Chunk ideas and use signposting (firstly, moreover).',
    ],
  };
}

async function gradeWithOpenAI(transcript: string): Promise<AIFeedback> {
  const prompt = `You are an IELTS Speaking examiner. Grade the following transcript.
Return ONLY JSON with keys: bandOverall, fluency, lexical, grammar, pronunciation, notes (array).
Transcript:
${transcript}
  `;
  const r = await fetch('https://api.openai.com/v1/chat/completions', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json', Authorization: `Bearer ${process.env.OPENAI_API_KEY}` },
    body: JSON.stringify({
      model: openaiModel,
      messages: [{ role: 'user', content: prompt }],
      temperature: 0.2,
      response_format: { type: 'json_object' },
    }),
  });
  if (!r.ok) throw new Error('OpenAI error');
  const json = await r.json();
  const content = json.choices?.[0]?.message?.content;
  const out = JSON.parse(content || '{}');

  const band = clampHalf(Number(out.bandOverall ?? 6), 4, 9);
  return {
    bandOverall: band,
    fluency: clampHalf(Number(out.fluency ?? band - 0.5), 4, 9),
    lexical: clampHalf(Number(out.lexical ?? band), 4, 9),
    grammar: clampHalf(Number(out.grammar ?? band - 0.5), 4, 9),
    pronunciation: clampHalf(Number(out.pronunciation ?? band), 4, 9),
    notes: Array.isArray(out.notes) ? out.notes.slice(0, 8) : ['Speak steadily and expand answers.'],
  };
}

const clampHalf = (n: number, min: number, max: number) => Math.max(min, Math.min(max, Math.round(n * 2) / 2));

================================================================================


========== File 4: pages/api/ai/writing/grade.ts ==========
import type { NextApiRequest, NextApiResponse } from 'next';
import { z } from 'zod';

// Optional: service-side Supabase (used only if you pass attemptId to persist)
import { createClient } from '@supabase/supabase-js';

const BodySchema = z.object({
  task1: z.string().min(1, 'task1 required'),
  task2: z.string().min(1, 'task2 required'),
  attemptId: z.string().optional(), // if provided, we'll persist AI feedback to attempts_writing.ai_feedback
});

type AIFeedback = {
  bandOverall: number;
  criteria: {
    taskAchievement: number;
    coherence: number;
    lexical: number;
    grammar: number;
  };
  notes: string[];
};

type Resp =
  | { ok: true; feedback: AIFeedback }
  | { ok: false; error: string };

const openaiModel = process.env.OPENAI_WRITING_MODEL || 'gpt-4o-mini';

export default async function handler(req: NextApiRequest, res: NextApiResponse<Resp>) {
  if (req.method !== 'POST') return res.status(405).json({ ok: false, error: 'Method not allowed' });

  const parse = BodySchema.safeParse(req.body);
  if (!parse.success) {
    return res.status(400).json({ ok: false, error: parse.error.issues.map(i => i.message).join(', ') });
  }
  const { task1, task2, attemptId } = parse.data;

  // Try OpenAI if key present, otherwise use heuristic
  let feedback: AIFeedback;
  try {
    if (process.env.OPENAI_API_KEY) {
      feedback = await gradeWithOpenAI(task1, task2);
    } else {
      feedback = heuristic(task1, task2);
    }
  } catch (e: any) {
    feedback = heuristic(task1, task2);
  }

  // Optional: persist to attempts_writing.ai_feedback if attemptId provided
  if (attemptId && process.env.NEXT_PUBLIC_SUPABASE_URL && (process.env.SUPABASE_SERVICE_ROLE_KEY || process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY)) {
    try {
      const supabase = createClient(
        process.env.NEXT_PUBLIC_SUPABASE_URL!,
        (process.env.SUPABASE_SERVICE_ROLE_KEY || process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY)!,
      );
      await supabase.from('attempts_writing').update({ ai_feedback: feedback }).eq('id', attemptId);
    } catch {
      // ignore persistence errors
    }
  }

  return res.status(200).json({ ok: true, feedback });
}

function heuristic(t1: string, t2: string): AIFeedback {
  const wc = (s: string) => (s.trim() ? s.trim().split(/\s+/).length : 0);
  const w1 = wc(t1), w2 = wc(t2);
  const base = 5.5 + Math.min(1.0, Math.max(0, (w1 - 150) / 300)) + Math.min(1.5, Math.max(0, (w2 - 250) / 500));
  const band = clampHalf(base, 4, 9);
  return {
    bandOverall: band,
    criteria: {
      taskAchievement: clampHalf(5 + (w1 >= 150 ? 1 : 0), 4, 9),
      coherence:  clampHalf(5.5 + (w2 >= 250 ? 0.5 : 0), 4, 9),
      lexical:    clampHalf(5.5, 4, 9),
      grammar:    clampHalf(5.5, 4, 9),
    },
    notes: [
      'Use clear topic sentences and logical paragraphing.',
      'Vary cohesive devices (however, furthermore, consequently).',
      'Aim for precise vocabulary; reduce repetition.',
      'Check complex sentences for agreement and punctuation.',
    ],
  };
}
const clampHalf = (n: number, min: number, max: number) => Math.max(min, Math.min(max, Math.round(n * 2) / 2));

async function gradeWithOpenAI(task1: string, task2: string): Promise<AIFeedback> {
  const prompt = `You are an IELTS examiner. Grade the two essays below. Return ONLY a compact JSON with keys:
  bandOverall (number 4-9, halves allowed),
  criteria { taskAchievement, coherence, lexical, grammar } (numbers with halves),
  notes (array of short coaching bullets).
  Essays:
  [Task 1]
  ${task1}

  [Task 2]
  ${task2}
  `;

  const r = await fetch('https://api.openai.com/v1/chat/completions', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json', Authorization: `Bearer ${process.env.OPENAI_API_KEY}` },
    body: JSON.stringify({
      model: openaiModel,
      messages: [{ role: 'user', content: prompt }],
      temperature: 0.2,
      response_format: { type: 'json_object' },
    }),
  });
  if (!r.ok) throw new Error('OpenAI error');
  const json = await r.json();
  const content = json.choices?.[0]?.message?.content;
  const out = JSON.parse(content);
  // Minimal shape guard
  return {
    bandOverall: clampHalf(Number(out.bandOverall ?? 6), 4, 9),
    criteria: {
      taskAchievement: clampHalf(Number(out?.criteria?.taskAchievement ?? 6), 4, 9),
      coherence: clampHalf(Number(out?.criteria?.coherence ?? 6), 4, 9),
      lexical: clampHalf(Number(out?.criteria?.lexical ?? 6), 4, 9),
      grammar: clampHalf(Number(out?.criteria?.grammar ?? 6), 4, 9),
    },
    notes: Array.isArray(out?.notes) ? out.notes.slice(0, 8) : ['Organize ideas clearly.', 'Use precise vocabulary.', 'Vary sentence structures.'],
  };
}

================================================================================


========== File 5: pages/api/activities/export.ts ==========
// pages/api/activities/export.ts
import { NextApiRequest, NextApiResponse } from 'next';
import { createClient } from '@supabase/supabase-js';
import { parse } from 'json2csv';

const supabaseAdmin = createClient(
  process.env.NEXT_PUBLIC_SUPABASE_URL!,
  process.env.SUPABASE_SERVICE_ROLE_KEY!
);

export default async function handler(req: NextApiRequest, res: NextApiResponse) {
  if (req.method !== 'GET') {
    return res.status(405).json({ error: 'Method not allowed' });
  }

  try {
    // Get user from auth token
    const authHeader = req.headers.authorization;
    if (!authHeader) {
      return res.status(401).json({ error: 'Unauthorized' });
    }

    const token = authHeader.replace('Bearer ', '');
    const { data: { user }, error: authError } = await supabaseAdmin.auth.getUser(token);

    if (authError || !user) {
      return res.status(401).json({ error: 'Unauthorized' });
    }

    // Fetch user activities
    const { data: activities, error } = await supabaseAdmin
      .from('user_activities')
      .select('*')
      .eq('user_id', user.id)
      .order('created_at', { ascending: false });

    if (error) {
      throw error;
    }

    // Format data for CSV
    const formattedActivities = activities.map(activity => ({
      Date: new Date(activity.created_at).toLocaleString(),
      Type: activity.activity_type.replace(/_/g, ' '),
      Description: activity.description,
      IP_Address: activity.ip_address,
      User_Agent: activity.user_agent,
      Metadata: JSON.stringify(activity.metadata),
      Related_Table: activity.related_table,
      Related_ID: activity.related_id,
    }));

    // Convert to CSV
    const csv = parse(formattedActivities);

    // Set headers for CSV download
    res.setHeader('Content-Type', 'text/csv');
    res.setHeader('Content-Disposition', `attachment; filename=gramorx-activities-${user.id}-${new Date().toISOString().split('T')[0]}.csv`);

    return res.status(200).send(csv);
  } catch (error) {
    console.error('Export error:', error);
    return res.status(500).json({ error: 'Failed to export activities' });
  }
}

================================================================================


========== File 6: pages/api/counters/increment.ts ==========
import type { NextApiRequest, NextApiResponse } from 'next';
import { z } from 'zod';
import { createClient } from '@supabase/supabase-js';

const BodySchema = z.object({
  counter: z.enum([
    'listening_attempts',
    'reading_attempts',
    'writing_ai_checks',
    'speaking_minutes',
  ]),
  delta: z.number().int().min(1).max(120),
});

type Resp = {
  ok: true;
  counter: string;
  current: number;
  limit: number;
  blocked: boolean;
} | { ok: false; error: string };

// Default free limits (per day). You can override via env vars later.
const FREE_LIMITS = {
  listening_attempts: Number(process.env.LIMIT_FREE_LISTENING ?? 1),
  reading_attempts: Number(process.env.LIMIT_FREE_READING ?? 1),
  writing_ai_checks: Number(process.env.LIMIT_FREE_WRITING_AI ?? 2),
  speaking_minutes: Number(process.env.LIMIT_FREE_SPEAKING_MIN ?? 10),
};
// Booster/Master limits (examples)
const BOOSTER_LIMITS = {
  listening_attempts: 999,
  reading_attempts: 999,
  writing_ai_checks: 50,
  speaking_minutes: 120,
};
const MASTER_LIMITS = {
  listening_attempts: 999,
  reading_attempts: 999,
  writing_ai_checks: 200,
  speaking_minutes: 240,
};

export default async function handler(req: NextApiRequest, res: NextApiResponse<Resp>) {
  if (req.method !== 'POST') return res.status(405).json({ ok: false, error: 'Method not allowed' });

  const parse = BodySchema.safeParse(req.body);
  if (!parse.success) return res.status(400).json({ ok: false, error: parse.error.issues.map(i => i.message).join(', ') });

  const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL!;
  const supabaseKey = process.env.SUPABASE_SERVICE_ROLE_KEY || process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY;
  if (!supabaseUrl || !supabaseKey) return res.status(503).json({ ok: false, error: 'Supabase env missing' });

  // Auth: require Bearer token so we know the user
  const token = (req.headers.authorization || '').replace(/^Bearer\s+/i, '');
  if (!token) return res.status(401).json({ ok: false, error: 'Missing Authorization bearer token' });

  const supabase = createClient(supabaseUrl, supabaseKey, { global: { headers: { Authorization: `Bearer ${token}` } } });
  const { data: userRes, error: userErr } = await supabase.auth.getUser();
  if (userErr || !userRes.user?.id) return res.status(401).json({ ok: false, error: 'Unauthorized' });
  const userId = userRes.user.id;

  const { counter, delta } = parse.data;

  // Determine plan & limits
  let plan: 'free'|'starter'|'booster'|'master' = 'free';
  try {
    const { data: profile } = await supabase.from('profiles').select('membership_plan').eq('id', userId).single();
    if (profile?.membership_plan) plan = profile.membership_plan as typeof plan;
  } catch { /* ignore */ }

  const limit = plan === 'master' ? MASTER_LIMITS[counter]
    : plan === 'booster' || plan === 'starter' ? BOOSTER_LIMITS[counter]
    : FREE_LIMITS[counter];

  // Read today's current
  const today = new Date().toISOString().slice(0, 10);
  const { data: row } = await supabase
    .from('usage_counters')
    .select('id,current')
    .eq('user_id', userId)
    .eq('counter', counter)
    .eq('date', today)
    .single();

  const current = row?.current ?? 0;
  const proposed = current + delta;
  const blocked = proposed > limit;

  if (!blocked) {
    if (row?.id) {
      await supabase.from('usage_counters').update({ current: proposed }).eq('id', row.id);
    } else {
      await supabase.from('usage_counters').insert({ user_id: userId, counter, date: today, current: proposed });
    }
  }

  return res.status(200).json({ ok: true, counter, current: blocked ? current : proposed, limit, blocked });
}

================================================================================


========== File 7: pages/api/premium/eligibility.ts ==========
// pages/api/premium/eligibility.ts
import type { NextApiRequest, NextApiResponse } from 'next';
import { createClient } from '@supabase/supabase-js';

type Resp = { eligible: boolean; plan: string | null; reason?: string };

export default async function handler(req: NextApiRequest, res: NextApiResponse<Resp>) {
  const token = req.headers.authorization?.split(' ')[1];
  if (!token) return res.status(200).json({ eligible: false, plan: null, reason: 'unauthenticated' });

  const supabase = createClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!
  );

  const { data: { user } } = await supabase.auth.getUser(token);
  if (!user) return res.status(200).json({ eligible: false, plan: null, reason: 'unauthenticated' });

  const { data: prof, error } = await supabase
    .from('profiles')
    .select('plan')
    .eq('id', user.id)
    .single();

  if (error) return res.status(200).json({ eligible: false, plan: null, reason: 'no_profile' });

  const plan = (prof?.plan ?? null) as string | null;
  const eligible = plan === 'premium' || plan === 'master';
  return res.status(200).json({ eligible, plan, reason: eligible ? undefined : 'plan_required' });
}

================================================================================


========== File 8: pages/api/premium/session.ts ==========
// pages/api/premium/session.ts
import type { NextApiRequest, NextApiResponse } from 'next';
import { createClient } from '@supabase/supabase-js';

type Resp = { ok: true; userId: string } | { ok: false; error: string };

export default async function handler(req: NextApiRequest, res: NextApiResponse<Resp>) {
  if (req.method !== 'POST') {
    res.setHeader('Allow', 'POST');
    return res.status(405).json({ ok: false, error: 'method-not-allowed' });
  }

  const token = req.headers.authorization?.split(' ')[1];
  if (!token) return res.status(401).json({ ok: false, error: 'no-token' });

  const supabase = createClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!
  );

  const { data: { user }, error } = await supabase.auth.getUser(token);
  if (error || !user) return res.status(401).json({ ok: false, error: 'invalid-token' });

  return res.status(200).json({ ok: true, userId: user.id });
}

================================================================================


========== File 9: pages/api/premium/status.ts ==========
// pages/api/premium/status.ts
import type { NextApiRequest, NextApiResponse } from 'next';
import { createClient } from '@supabase/supabase-js';

type Resp = {
  pinOk: boolean;
  loggedIn: boolean;
  userId: string | null;
  plan: string | null;
};

export default async function handler(req: NextApiRequest, res: NextApiResponse<Resp>) {
  const pinOk = req.cookies?.pr_pin_ok === '1';

  const token = req.headers.authorization?.split(' ')[1];
  if (!token) {
    return res.status(200).json({ pinOk, loggedIn: false, userId: null, plan: null });
  }

  const supabase = createClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!
  );

  const { data: { user } } = await supabase.auth.getUser(token);
  if (!user) {
    return res.status(200).json({ pinOk, loggedIn: false, userId: null, plan: null });
  }

  const { data: prof } = await supabase
    .from('profiles')
    .select('plan')
    .eq('id', user.id)
    .single();

  return res.status(200).json({
    pinOk,
    loggedIn: true,
    userId: user.id,
    plan: (prof?.plan ?? null) as string | null,
  });
}

================================================================================


========== File 10: pages/api/reading/dashboard.ts ==========
// pages/api/reading/dashboard.ts
import type { NextApiRequest, NextApiResponse } from 'next';

// Prefer your existing helper if present
// import { getServerClient } from '@/lib/supabaseServer';
import { createClient } from '@supabase/supabase-js';

// ---- Adjust these if your env helpers differ
const supabaseAdmin = () =>
  createClient(process.env.NEXT_PUBLIC_SUPABASE_URL as string, process.env.SUPABASE_SERVICE_ROLE_KEY as string, {
    auth: { persistSession: false },
  });

/**
 * Expected minimal columns:
 * reading_attempts: id, user_id, test_id, passage_id, created_at, duration_sec, score (0..1 or 0..100), correct_questions, total_questions
 * attempts_reading: attempt_id, question_id, correct (bool), time_sec
 * reading_questions: id, type ('tfng'|'mcq'|'matching'|'short'|...)
 * reading_passages: id, title, slug
 * reading_tests: id, title, slug
 * reading_user_stats (optional): user_id, streak_days, total_practices
 */

type AttemptRow = {
  id: string;
  user_id: string;
  test_id: string | null;
  passage_id: string | null;
  created_at: string;
  duration_sec: number | null;
  score: number | null; // 0..1 or 0..100
  correct_questions: number | null;
  total_questions: number | null;
};

type AttemptDetailRow = {
  attempt_id: string;
  question_id: string;
  correct: boolean | null;
  time_sec: number | null;
};

type QuestionRow = { id: string; type: string | null };
type PassageRow = { id: string; title: string | null; slug: string | null };
type TestRow = { id: string; title: string | null; slug: string | null };
type UserStatsRow = { user_id: string; streak_days: number | null; total_practices: number | null };

function normScore(a: AttemptRow): number | null {
  if (a == null) return null;
  if (typeof a.score === 'number') {
    // Heuristic: treat >1 as percentage
    return a.score > 1 ? a.score / 100 : a.score;
  }
  if (typeof a.correct_questions === 'number' && typeof a.total_questions === 'number' && a.total_questions > 0) {
    return a.correct_questions / a.total_questions;
  }
  return null;
}

export default async function handler(req: NextApiRequest, res: NextApiResponse) {
  try {
    const sb = supabaseAdmin();

    // ---- Get user from a bearer cookie/session (if you gate with RLS, keep this).
    // Service role is used above for simplicity, but if you prefer per-request auth:
    // const supa = getServerClient(req, res);
    // const { data: { user } } = await supa.auth.getUser();

    // If you want to require auth, flip allowGuest to false
    const allowGuest = true;

    // Try to infer user via a light JWT in Authorization, else treat as guest
    let userId: string | null = null;
    try {
      const auth = req.headers.authorization || '';
      if (auth.startsWith('Bearer ')) {
        const token = auth.slice(7);
        const { data, error } = await sb.auth.getUser(token);
        if (!error && data?.user) userId = data.user.id;
      }
    } catch {
      // ignore; we'll be guest
    }

    if (!userId && !allowGuest) {
      return res.status(401).json({ error: 'not_authenticated' });
    }

    // ---- Fetch attempts (latest first)
    const attemptsQ = sb
      .from('reading_attempts')
      .select('id,user_id,test_id,passage_id,created_at,duration_sec,score,correct_questions,total_questions')
      .order('created_at', { ascending: false })
      .limit(60);

    const { data: attemptsRaw, error: attemptsErr } = await attemptsQ;
    if (attemptsErr) {
      // Don’t explode the UI — return empty, plus an informational hint
      return res.status(200).json({
        kpis: { bandEstimate: null, bandStd: null, accuracy10: null, accuracyDelta10: null, avgSecPerQ: null, streakDays: null, totalPractices: null },
        trend: [],
        byType: [],
        timeVsScore: [],
        weakAreas: [],
        recent: [],
        saved: [],
        queued: [],
        note: 'reading_attempts query failed',
      });
    }

    const attempts: AttemptRow[] = (attemptsRaw ?? []) as any;
    const latest = attempts.slice(0, 20);

    // ---- Batch fetch per-question results for last ~200 details
    const latestIds = latest.map((a) => a.id);
    let details: AttemptDetailRow[] = [];
    if (latestIds.length) {
      const { data: det, error: detErr } = await sb
        .from('attempts_reading')
        .select('attempt_id,question_id,correct,time_sec')
        .in('attempt_id', latestIds)
        .limit(1000);
      if (!detErr && det) details = det as any;
    }

    // ---- Fetch question types for involved questions
    const qIds = Array.from(new Set(details.map((d) => d.question_id)));
    let questions: Record<string, string | null> = {};
    if (qIds.length) {
      const { data: qRows, error: qErr } = await sb
        .from('reading_questions')
        .select('id,type')
        .in('id', qIds)
        .limit(2000);
      if (!qErr && qRows) {
        for (const q of qRows as QuestionRow[]) questions[q.id] = q.type;
      }
    }

    // ---- Simple resource titles (passage/test)
    const passageIds = Array.from(new Set(attempts.map((a) => a.passage_id).filter(Boolean))) as string[];
    const testIds = Array.from(new Set(attempts.map((a) => a.test_id).filter(Boolean))) as string[];

    let passagesById: Record<string, PassageRow> = {};
    if (passageIds.length) {
      const { data: pRows } = await sb.from('reading_passages').select('id,title,slug').in('id', passageIds).limit(2000);
      (pRows ?? []).forEach((p: any) => (passagesById[p.id] = p));
    }

    let testsById: Record<string, TestRow> = {};
    if (testIds.length) {
      const { data: tRows } = await sb.from('reading_tests').select('id,title,slug').in('id', testIds).limit(2000);
      (tRows ?? []).forEach((t: any) => (testsById[t.id] = t));
    }

    // ---- Optional user stats
    let userStats: UserStatsRow | null = null;
    if (userId) {
      const { data: us } = await sb.from('reading_user_stats').select('user_id,streak_days,total_practices').eq('user_id', userId).maybeSingle();
      userStats = (us as any) || null;
    }

    // ---- Compute KPIs
    const last10 = attempts.slice(0, 10);
    const last10Scores = last10.map(normScore).filter((n): n is number => n != null);
    const accuracy10 = last10Scores.length ? avg(last10Scores) : null;

    const prev10 = attempts.slice(10, 20);
    const prev10Scores = prev10.map(normScore).filter((n): n is number => n != null);
    const accuracyPrev10 = prev10Scores.length ? avg(prev10Scores) : null;
    const accuracyDelta10 =
      typeof accuracy10 === 'number' && typeof accuracyPrev10 === 'number' ? accuracy10 - accuracyPrev10 : null;

    const allScores = attempts.map(normScore).filter((n): n is number => n != null);
    const bandEstimate = allScores.length ? toBand(avg(allScores)) : null;
    const bandStd = allScores.length > 1 ? stddev(allScores.map(toBand)) : null;

    // average seconds per question over last 20 with Q data
    const timeDenoms = latest
      .map((a) => {
        const n = typeof a.total_questions === 'number' && a.total_questions > 0 ? a.total_questions : null;
        const dur = typeof a.duration_sec === 'number' ? a.duration_sec : null;
        return { dur, n };
      })
      .filter((x) => x.dur != null && x.n != null);
    const avgSecPerQ =
      timeDenoms.length ? Math.round(avg(timeDenoms.map((x) => (x.dur as number) / (x.n as number)))) : null;

    const streakDays = userStats?.streak_days ?? null;
    const totalPractices = userStats?.total_practices ?? attempts.length;

    // ---- Trend (last 20)
    const trend = latest.map((a) => ({ date: a.created_at, score: normScore(a) ?? 0 }));

    // ---- By type (heatmap) from attempts_reading + reading_questions
    const byTypeAgg: Record<string, { correct: number; total: number }> = {};
    for (const d of details) {
      const t = (questions[d.question_id] || 'unknown')?.toLowerCase();
      if (!byTypeAgg[t]) byTypeAgg[t] = { correct: 0, total: 0 };
      byTypeAgg[t].total += 1;
      if (d.correct) byTypeAgg[t].correct += 1;
    }
    const byType = Object.entries(byTypeAgg)
      .map(([type, v]) => ({
        type,
        accuracy: v.total > 0 ? v.correct / v.total : 0,
        attempts: v.total,
      }))
      .sort((a, b) => a.accuracy - b.accuracy); // weakest first

    // ---- Time vs score (from attempts)
    const timeVsScore = latest
      .map((a) => ({
        id: a.id,
        minutes: Math.max(1, Math.round(((a.duration_sec ?? 0) / 60) * 10) / 10),
        score: normScore(a) ?? 0,
      }))
      .filter((x) => Number.isFinite(x.minutes) && Number.isFinite(x.score));

    // ---- Recent table (last 7)
    const recent = attempts.slice(0, 7).map((a) => {
      const pass = a.passage_id ? passagesById[a.passage_id] : null;
      const test = a.test_id ? testsById[a.test_id] : null;
      const title = pass?.title || test?.title || 'Reading practice';
      const slug = pass?.slug || test?.slug || a.id;
      const hrefReview = pass?.slug
        ? `/reading/${pass.slug}#review`
        : test?.slug
        ? `/reading/${test.slug}#review`
        : `/reading/${slug}#review`;
      return {
        slug: String(slug),
        title: String(title),
        date: a.created_at,
        score: normScore(a) ?? 0,
        minutes: Math.max(1, Math.round(((a.duration_sec ?? 0) / 60) * 10) / 10),
        types: [], // could be filled from details if you want
        hrefReview,
      };
    });

    // ---- Weak areas (top 2 weakest)
    const weakAreas =
      byType.length >= 2
        ? byType.slice(0, 2).map((w) => ({
            label: w.type,
            reason: `Accuracy ${Math.round(w.accuracy * 100)}% over ${w.attempts} Qs`,
            href: `/reading?type=${encodeURIComponent(w.type)}`,
          }))
        : [];

    // ---- Response
    return res.status(200).json({
      kpis: {
        bandEstimate,
        bandStd,
        accuracy10,
        accuracyDelta10,
        avgSecPerQ,
        streakDays,
        totalPractices,
      },
      trend,
      byType,
      timeVsScore,
      weakAreas,
      recent,
      saved: [], // integrate when you add a "saved" table
      queued: [], // integrate with a "queue" table
    });
  } catch (e: any) {
    return res.status(200).json({
      kpis: { bandEstimate: null, bandStd: null, accuracy10: null, accuracyDelta10: null, avgSecPerQ: null, streakDays: null, totalPractices: null },
      trend: [],
      byType: [],
      timeVsScore: [],
      weakAreas: [],
      recent: [],
      saved: [],
      queued: [],
      note: e?.message || 'Unhandled',
    });
  }
}

// ---- helpers
function avg(xs: number[]) {
  return xs.reduce((a, b) => a + b, 0) / Math.max(1, xs.length);
}
function stddev(xs: number[]) {
  const m = avg(xs);
  const v = avg(xs.map((x) => (x - m) ** 2));
  return Math.sqrt(v);
}
function toBand(p: number) {
  // Simple mapping: 0..1 -> 4.0..9.0 (tweak if you have a calibrated curve)
  return 4 + p * 5;
}

================================================================================


========== File 11: pages/api/study-buddy/sessions.ts ==========
// pages/api/study-buddy/sessions.ts
import type { NextApiRequest, NextApiResponse } from 'next';
import { createClient } from '@supabase/supabase-js';
import { v4 as uuidv4, validate as uuidValidate } from 'uuid';
import { z } from 'zod';

type StudySessionItem = { skill: string; minutes: number; topic?: string | null; status?: 'pending' | 'started' | 'completed'; note?: string | null };
type StudySessionRecord = {
  id: string;
  user_id: string | null;
  items: StudySessionItem[];
  state: 'pending' | 'started' | 'completed' | 'cancelled';
  created_at: string;
  updated_at: string;
  started_at: string | null;
  ended_at: string | null;
  duration_minutes: number | null;
  xp_earned: number;
};

const SUPABASE_URL = process.env.SUPABASE_URL;
const SUPABASE_SERVICE_ROLE_KEY = process.env.SUPABASE_SERVICE_ROLE_KEY;

function getAdminClient() {
  if (!SUPABASE_URL || !SUPABASE_SERVICE_ROLE_KEY) {
    throw new Error('Missing SUPABASE_URL / SUPABASE_SERVICE_ROLE_KEY in environment.');
  }
  return createClient(SUPABASE_URL, SUPABASE_SERVICE_ROLE_KEY);
}

function normalizeUserId(raw?: any): string | null {
  if (!raw || typeof raw !== 'string') return null;
  const trimmed = raw.trim();
  if (trimmed.toLowerCase() === 'null') return null;
  return uuidValidate(trimmed) ? trimmed : null;
}

const Body = z.object({
  userId: z.string().uuid().optional().nullable(),
  items: z.array(
    z.object({
      skill: z.string().min(1).max(64),
      minutes: z.number().int().min(1).max(300),
    })
  ).min(1).max(200),
});

export default async function handler(req: NextApiRequest, res: NextApiResponse) {
  if (req.method !== 'POST') {
    res.setHeader('Allow', 'POST');
    return res.status(405).json({ error: 'method_not_allowed' });
  }

  const parsed = Body.safeParse(req.body ?? {});
  if (!parsed.success) {
    return res.status(400).json({ error: 'invalid_body', details: parsed.error.flatten() });
  }

  const { items } = parsed.data;
  const user_id = normalizeUserId(parsed.data.userId ?? undefined);

  let supabaseAdmin;
  try {
    supabaseAdmin = getAdminClient();
  } catch (err: any) {
    console.error('[study-sessions] admin client error', err);
    return res.status(500).json({ error: 'supabase_not_configured' });
  }

  const id = uuidv4();
  const now = new Date().toISOString();

  const normalizedItems = items.map((item) => ({
    skill: item.skill,
    minutes: item.minutes,
    topic: null,
    status: 'pending' as const,
    note: null,
  }));

  const totalMinutes = normalizedItems.reduce((sum, item) => sum + item.minutes, 0);

  const payload: StudySessionRecord = {
    id,
    user_id,
    items: normalizedItems,
    state: 'pending',
    created_at: now,
    updated_at: now,
    started_at: null,
    ended_at: null,
    duration_minutes: totalMinutes,
    xp_earned: 0,
  };

  try {
    const { data, error, status, statusText } = await supabaseAdmin
      .from<StudySessionRecord>('study_buddy_sessions')
      .insert(payload)
      .select('*');

    if (error) {
      console.error('[study-sessions] insert error:', { error, status, statusText });
      const message = (error && (error.message || JSON.stringify(error))) ?? 'db_insert_failed';
      return res.status(500).json({ error: message });
    }

    const inserted = Array.isArray(data) && data.length > 0 ? data[0] : payload;
    return res.status(201).json(inserted);
  } catch (err: any) {
    console.error('[study-sessions] unexpected exception', err);
    const info = (err && err.message) ? String(err.message) : 'unknown_error';
    return res.status(500).json({ error: info });
  }
}

================================================================================


========== File 12: pages/api/check-otp.ts ==========
import type { NextApiRequest, NextApiResponse } from 'next';
import { z } from 'zod';
import Twilio from 'twilio';
import { createClient } from '@supabase/supabase-js';
import { env } from '@/lib/env';
import { rateLimit } from '@/lib/rateLimit';

const client = Twilio(env.TWILIO_ACCOUNT_SID, env.TWILIO_AUTH_TOKEN);
const SERVICE_SID = env.TWILIO_VERIFY_SERVICE_SID;
const supa = createClient(env.SUPABASE_URL, env.SUPABASE_SERVICE_KEY); // server only

const BodySchema = z.object({
  phone: z.string(),
  code: z.string(),
});

export type CheckOtpResponse =
  | { ok: true; message: string }
  | { ok: false; error: string };

export default async function checkOtp(
  req: NextApiRequest,
  res: NextApiResponse<CheckOtpResponse>
) {
  if (req.method !== 'POST') {
    res.setHeader('Allow', 'POST');
    throw new Error('Method Not Allowed');
  }

  if (!(await rateLimit(req, res))) return;

  const result = BodySchema.safeParse(req.body);
  if (!result.success) {
    return res
      .status(400)
      .json({ ok: false, error: 'Invalid request body' });
  }

  const { phone, code } = result.data;
  try {
    const check = await client.verify
      .services(SERVICE_SID)
      .verificationChecks.create({ to: phone, code });
    if (check.status !== 'approved') {
      return res.status(400).json({ ok: false, error: 'Invalid code' });
    }

    const { error: supErr } = await supa
      .from('profiles')
      .upsert({ phone, phone_verified: true, updated_at: new Date() });

    if (supErr) {
      if ((supErr as any).code === 'user_not_found') {
        return res
          .status(404)
          .json({ ok: false, error: 'No account found for that email/phone.' });
      }
      return res.status(500).json({ ok: false, error: (supErr as any).message });
    }

    return res.json({ ok: true, message: 'Phone verified' });
  } catch (err) {
    const message = err instanceof Error ? err.message : 'Unknown error';
    return res.status(500).json({ ok: false, error: message });
  }
}

================================================================================


========== File 13: pages/api/streak.ts ==========
import { NextApiRequest, NextApiResponse } from 'next';
import { createClient, type SupabaseClient } from '@supabase/supabase-js';
import { supabaseService, supabaseServer } from '@/lib/supabaseServer';

const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL!;
const supabaseAnonKey = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!;

export type StreakData = {
  current_streak: number;
  longest_streak: number;
  last_activity_date: string | null; // YYYY-MM-DD
  next_restart_date: string | null;  // not persisted on 'streaks' table
  shields: number;                   // not persisted on 'streaks' table
};

const getDayKey = (d = new Date()) => d.toISOString().split('T')[0];
const ms = (h: number) => h * 60 * 60 * 1000;

export default async function handler(req: NextApiRequest, res: NextApiResponse) {
  let token = req.headers.authorization?.split(' ')[1] ?? null;
  let refreshToken: string | null = null;

  if (!token) {
    try {
      const cookieClient = supabaseServer(req);
      const { data, error } = await cookieClient.auth.getSession();
      if (error) {
        console.error('[API/streak] Cookie session lookup failed:', error);
      }
      token = data?.session?.access_token ?? null;
      refreshToken = data?.session?.refresh_token ?? null;
    } catch (error) {
      console.error('[API/streak] Cookie session client unavailable:', error);
    }
  }

  if (!token) return res.status(401).json({ error: 'No authorization token' });

  // RLS client (acts as the user)
  let supabaseUser: SupabaseClient;
  try {
    supabaseUser = createClient(supabaseUrl, supabaseAnonKey, {
      auth: { autoRefreshToken: false, persistSession: false },
    });
  } catch (error) {
    console.error('[API/streak] User client creation failed:', error);
    return res.status(503).json({ error: 'service_unavailable' });
  }

  try {
    await supabaseUser.auth.setSession({
      access_token: token,
      refresh_token: refreshToken ?? '',
    });
  } catch (error) {
    console.error('[API/streak] User session setup failed:', error);
    return res.status(503).json({ error: 'service_unavailable' });
  }

  let user = null;
  try {
    const { data: { user: authUser }, error: authError } = await supabaseUser.auth.getUser();
    if (authError || !authUser) return res.status(401).json({ error: 'Invalid token' });
    user = authUser;
  } catch (error) {
    console.error('[API/streak] Auth verification failed:', error);
    return res.status(503).json({ error: 'auth_unavailable' });
  }

  try {
    // Read current row (aliases to expected keys)
    let { data: row, error: fetchError } = await supabaseUser
      .from('streaks')
      .select('user_id,current_streak:current,longest_streak:longest,last_activity_date:last_active_date,updated_at')
      .eq('user_id', user.id)
      .maybeSingle();

    if (fetchError && fetchError.code !== 'PGRST116') throw fetchError;

    // If no row, create one
    const baseInsert = { user_id: user.id, current: 0, longest: 0, last_active_date: null, updated_at: null };

    if (!row) {
      const { data: inserted, error: insertError } = await supabaseUser
        .from('streaks')
        .insert(baseInsert)
        .select('user_id,current_streak:current,longest_streak:longest,last_activity_date:last_active_date,updated_at')
        .single();
      if (insertError) {
        console.error('[API/streak] Insert failed:', insertError);

        const shouldRetryWithService =
          insertError?.code === '42501' || insertError?.message?.includes('row-level security');

        if (shouldRetryWithService) {
          try {
            const svc = supabaseService();
            const { data: serviceInserted, error: serviceErr } = await svc
              .from('streaks')
              .insert(baseInsert)
              .select('user_id,current_streak:current,longest_streak:longest,last_activity_date:last_active_date,updated_at')
              .single();

            if (serviceErr) {
              console.error('[API/streak] Service insert failed:', serviceErr);
            } else {
              row = serviceInserted ?? row;
            }
          } catch (serviceClientError) {
            console.error('[API/streak] Service client unavailable for insert:', serviceClientError);
          }
        }

        // Fallback: treat as new streak of 0 when all attempts fail
        if (!row) {
          row = {
            user_id: user.id,
            current_streak: 0,
            longest_streak: 0,
            last_activity_date: null,
            updated_at: null,
          } as typeof row;
        }
      } else {
        row = inserted;
      }
    }

    let shieldTokens = 0;
    try {
      const { data: shieldRow } = await supabaseUser
        .from('streak_shields')
        .select('tokens')
        .eq('user_id', user.id)
        .maybeSingle();
      shieldTokens = shieldRow?.tokens ?? 0;
    } catch (shieldErr) {
      console.warn('[API/streak] Unable to load shields', shieldErr);
      shieldTokens = 0;
    }

    // Build response object (shields/next_restart_date are not stored on this table)
    const asResponse = (r: typeof row, shields = shieldTokens): StreakData => ({
      current_streak: r?.current_streak ?? 0,
      longest_streak: r?.longest_streak ?? r?.current_streak ?? 0,
      last_activity_date: r?.last_activity_date ?? null,
      next_restart_date: null,
      shields,
    });

    if (req.method === 'GET') {
      return res.status(200).json(asResponse(row));
    }

    if (req.method === 'POST') {
      const { action, date } = req.body as { action?: 'use' | 'claim' | 'schedule'; date?: string };

      const now = new Date();
      const today = getDayKey(now);
      const previousCurrent = row.current_streak ?? 0;

      if (action === 'claim') {
        const nextTokens = shieldTokens + 1;
        try {
          const { data: updatedShield, error: shieldErr } = await supabaseUser
            .from('streak_shields')
            .upsert({ user_id: user.id, tokens: nextTokens }, { onConflict: 'user_id' })
            .select('tokens')
            .single();
          if (shieldErr) throw shieldErr;
          shieldTokens = updatedShield?.tokens ?? nextTokens;
          await supabaseUser.from('streak_shield_logs').insert({ user_id: user.id, action: 'claim' });
        } catch (err) {
          console.error('[API/streak] Claim shield failed', err);
          return res.status(500).json({ error: 'Failed to claim shield' });
        }
        return res.status(200).json(asResponse(row, shieldTokens));
      }

      if (action === 'schedule') {
        if (!date) return res.status(400).json({ error: 'Date required for scheduling' });
        return res.status(200).json({ ...asResponse(row, shieldTokens), next_restart_date: date });
      }

      const spentShield = action === 'use';
      if (spentShield && shieldTokens <= 0) {
        return res.status(400).json({ error: 'No shields available' });
      }

      if (!spentShield && row.last_activity_date === today) {
        return res.status(200).json(asResponse(row, shieldTokens));
      }

      const lastTs = row.updated_at ? new Date(row.updated_at) : null;
      const within24h = lastTs ? now.getTime() - lastTs.getTime() <= ms(24) : false;

      let newCurrent = 1;
      if (spentShield) {
        newCurrent = previousCurrent + 1;
      } else if (within24h) {
        newCurrent = previousCurrent + 1;
      } else {
        newCurrent = 1;
      }

      const previousLongest = row.longest_streak ?? row.current_streak ?? 0;
      const newLongest = Math.max(previousLongest, newCurrent);

      const { data: updatedRow, error: upErr } = await supabaseUser
        .from('streaks')
        .update({
          current: newCurrent,
          longest: newLongest,
          last_active_date: today,
          updated_at: now.toISOString(),
        })
        .eq('user_id', user.id)
        .select('user_id,current_streak:current,longest_streak:longest,last_activity_date:last_active_date,updated_at')
        .single();

      if (upErr) {
        console.error('[API/streak] Update failed:', upErr);
        return res.status(200).json(asResponse(row, shieldTokens));
      }

      let tokensDelta = 0;
      if (spentShield) tokensDelta -= 1;
      if (newCurrent > previousCurrent && newCurrent % 7 === 0) tokensDelta += 1;

      let nextTokens = shieldTokens;
      if (tokensDelta !== 0) {
        nextTokens = Math.max(0, shieldTokens + tokensDelta);
        try {
          const { data: shieldRow, error: shieldUpdateErr } = await supabaseUser
            .from('streak_shields')
            .upsert({ user_id: user.id, tokens: nextTokens }, { onConflict: 'user_id' })
            .select('tokens')
            .single();
          if (shieldUpdateErr) {
            console.error('[API/streak] Failed to update shields', shieldUpdateErr);
          } else {
            nextTokens = shieldRow?.tokens ?? nextTokens;
          }
        } catch (shieldUpdateError) {
          console.error('[API/streak] Shield upsert failed', shieldUpdateError);
        }
      }

      if (spentShield) {
        await supabaseUser.from('streak_shield_logs').insert({ user_id: user.id, action: 'use' });
      }
      if (tokensDelta > 0) {
        await supabaseUser.from('streak_shield_logs').insert({ user_id: user.id, action: 'claim' });
      }

      return res.status(200).json(asResponse(updatedRow, nextTokens));
    }

    return res.status(405).json({ error: 'Method not allowed' });
  } catch (err: any) {
    console.error('[API/streak] Error:', err);
    return res.status(500).json({ error: err.message || 'Internal server error' });
  }
}

================================================================================


========== File 14: lib/authServer.ts ==========
import { env } from "@/lib/env";
// lib/authServer.ts
import type { NextApiRequest } from 'next';
import { createClient } from '@supabase/supabase-js';

const URL = env.NEXT_PUBLIC_SUPABASE_URL;
const ANON = env.NEXT_PUBLIC_SUPABASE_ANON_KEY;
const SERVICE = env.SUPABASE_SERVICE_ROLE_KEY || '';

function b64urlToJson(b64: string) {
  const pad = (s:string) => s + '=' * ((4 - (s.length % 4)) % 4);
  const str = Buffer.from(pad(b64).replace(/-/g,'+').replace(/_/g,'/'), 'base64').toString('utf8');
  return JSON.parse(str);
}
function decodeUserId(token: string | null): string | null {
  if (!token) return null;
  try {
    const [_, payload] = token.split('.');
    const p = b64urlToJson(payload);
    return p.sub || p.user_id || null;
  } catch { return null; }
}

export type ServerAuth = {
  user: { id: string; email?: string } | null;
  supabaseDb: ReturnType<typeof createClient>;
  supabaseAuth: ReturnType<typeof createClient>;
  token: string | null;
};

export async function getUserServer(req: NextApiRequest): Promise<ServerAuth> {
  const authHeader = (req.headers.authorization as string) || '';
  const token = authHeader.startsWith('Bearer ') ? authHeader.slice(7) : null;

  // Client used for auth/RLS-aware queries (carries the bearer)
  const supabaseAuth = createClient(URL, ANON, { global: { headers: { Authorization: authHeader } } });

  // Client used for storage/DB writes; prefers service role (bypasses RLS)
  const supabaseDb = SERVICE ? createClient(URL, SERVICE) : supabaseAuth;

  let userId: string | null = null;
  try {
    if (token) {
      const { data } = await supabaseAuth.auth.getUser(token);
      userId = data?.user?.id ?? decodeUserId(token);
    }
  } catch {
    userId = decodeUserId(token);
  }

  return { user: userId ? { id: userId } : null, supabaseDb, supabaseAuth, token };
}

================================================================================


========== File 15: lib/supabaseAdmin.ts ==========
// lib/supabaseAdmin.ts
// Server-only Supabase admin (service-role) client with HMR-safe caching.

import { createClient, type SupabaseClient } from '@supabase/supabase-js';
import { env } from '@/lib/env';

// Accept either server or public URL (both point to the same project)
const url = env.SUPABASE_URL || env.NEXT_PUBLIC_SUPABASE_URL;

// Accept either name for the service key
const serviceRoleKey = env.SUPABASE_SERVICE_ROLE_KEY || env.SUPABASE_SERVICE_KEY;

const isServer = typeof window === 'undefined';
const isProdRuntime =
  typeof process !== 'undefined' &&
  process.env.NODE_ENV === 'production' &&
  process.env.VERCEL_ENV === 'production';

if (isServer && process.env.NODE_ENV !== 'test') {
  if (!url || !serviceRoleKey) {
    if (isProdRuntime) {
      if (!url) {
        throw new Error('Missing SUPABASE_URL (or NEXT_PUBLIC_SUPABASE_URL fallback)');
      }
      if (!serviceRoleKey) {
        throw new Error('Missing SUPABASE_SERVICE_ROLE_KEY (or SUPABASE_SERVICE_KEY)');
      }
    } else {
      console.warn(
        'Supabase admin credentials not fully configured. Falling back to stub admin client.',
      );
    }
  }
}

/** Lightweight test stub for CI/test where keys are intentionally absent */
function makeAdminTestStub(): SupabaseClient<any, 'public', any> {
  const fromHandler = (_table: string) => ({
    async insert(rows: any) {
      const toArr = Array.isArray(rows) ? rows : [rows];
      return { data: toArr.map((r: any, i: number) => ({ id: `stub-${i + 1}`, ...r })), error: null };
    },
    async select(_cols?: string) { return { data: [], error: null }; },
    async update(_rows: any) { return { data: null, error: null }; },
    async delete() { return { data: null, error: null }; },
    eq() { return this; },
    order() { return this; },
  });

  return {
    // @ts-expect-error minimal stub
    from: fromHandler,
    auth: {
      // @ts-expect-error minimal stub
      getUser: async () => ({ data: { user: null }, error: null }),
      // @ts-expect-error minimal stub
      getSession: async () => ({ data: { session: null }, error: null }),
    },
  };
}

declare global {
  // eslint-disable-next-line no-var
  var __supabaseAdmin: SupabaseClient | undefined;
}

export const supabaseAdmin: SupabaseClient =
  globalThis.__supabaseAdmin ??
  (() => {
    if (!isServer) {
      // Never expose service-role credentials in the browser; fall back to stub behaviour.
      // @ts-expect-error test stub used for client fallbacks
      const stub = makeAdminTestStub();
      // @ts-expect-error cache
      globalThis.__supabaseAdmin = stub;
      // @ts-expect-error returning stub client shape
      return stub;
    }

    if ((process.env.NODE_ENV === 'test' || !url || !serviceRoleKey) && !isProdRuntime) {
      // CI/test path
      // @ts-expect-error test stub
      const stub = makeAdminTestStub();
      // @ts-expect-error cache
      globalThis.__supabaseAdmin = stub;
      // @ts-expect-error
      return stub;
    }

    const client = createClient(url!, serviceRoleKey!, {
      auth: { persistSession: false, autoRefreshToken: false, detectSessionInUrl: false },
      global: { fetch: (...args) => fetch(...args) },
    });

    // cache for HMR/dev
    // @ts-expect-error cache
    globalThis.__supabaseAdmin = client;
    return client;
  })();

export default supabaseAdmin;

export function getAdminClient(): SupabaseClient {
  return supabaseAdmin;
}

================================================================================


========== File 16: lib/supabaseSSR.ts ==========
// lib/supabaseSSR.ts (no-SSR version)
// Drop-in replacement so existing API routes keep working without @supabase/ssr.
import type { NextApiRequest, NextApiResponse } from 'next';
import { createClient } from '@supabase/supabase-js';
import cookie from 'cookie';

function bearerFromCookies(req: NextApiRequest): string | undefined {
  const raw = req.headers.cookie;
  if (!raw) return;
  const parsed = cookie.parse(raw);
  const t = parsed['sb-access-token'];
  return t ? `Bearer ${t}` : undefined;
}

export function supabaseServer(req: NextApiRequest, _res: NextApiResponse) {
  const url = process.env.NEXT_PUBLIC_SUPABASE_URL!;
  const anon = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!;
  if (!url || !anon) {
    throw new Error('Missing NEXT_PUBLIC_SUPABASE_URL or NEXT_PUBLIC_SUPABASE_ANON_KEY');
  }

  // Prefer Authorization header; fall back to cookie if present.
  const auth = (req.headers.authorization as string | undefined) || bearerFromCookies(req);

  return createClient(url, anon, {
    global: { headers: auth ? { Authorization: auth } : {} },
  });
}

// Back-compat alias so existing imports keep working
export const createSSRClient = supabaseServer;

================================================================================


========== File 17: functions/activities/index.ts ==========
// /functions/activities/index.ts
import { createClient } from 'https://esm.sh/@supabase/supabase-js@2.39.3'

const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',
}

Deno.serve(async (req) => {
  if (req.method === 'OPTIONS') {
    return new Response('ok', { headers: corsHeaders })
  }

  try {
    const supabaseClient = createClient(
      Deno.env.get('SUPABASE_URL') ?? '',
      Deno.env.get('SUPABASE_ANON_KEY') ?? '',
      {
        global: {
          headers: { Authorization: req.headers.get('Authorization')! },
        },
      }
    )

    const {
      data: { user },
      error: authError,
    } = await supabaseClient.auth.getUser()

    if (authError || !user) {
      return new Response(JSON.stringify({ error: 'Unauthorized' }), {
        status: 401,
        headers: { ...corsHeaders, 'Content-Type': 'application/json' },
      })
    }

    const url = new URL(req.url)
    const path = url.pathname.split('/').pop()

    switch (path) {
      case 'get-activities':
        return await handleGetActivities(req, supabaseClient, user)
      case 'create-task':
        return await handleCreateTask(req, supabaseClient, user)
      case 'get-tasks':
        return await handleGetTasks(req, supabaseClient, user)
      case 'update-task':
        return await handleUpdateTask(req, supabaseClient, user)
      default:
        return new Response(JSON.stringify({ error: 'Not found' }), {
          status: 404,
          headers: { ...corsHeaders, 'Content-Type': 'application/json' },
        })
    }
  } catch (error) {
    return new Response(JSON.stringify({ error: error.message }), {
      status: 500,
      headers: { ...corsHeaders, 'Content-Type': 'application/json' },
    })
  }
})

// Get user activities
async function handleGetActivities(req: Request, supabase: any, user: any) {
  const { searchParams } = new URL(req.url)
  const limit = parseInt(searchParams.get('limit') || '50')
  const offset = parseInt(searchParams.get('offset') || '0')
  const activityType = searchParams.get('type')
  const startDate = searchParams.get('start_date')
  const endDate = searchParams.get('end_date')

  let query = supabase
    .from('user_activities')
    .select('*')
    .eq('user_id', user.id)
    .order('created_at', { ascending: false })
    .range(offset, offset + limit - 1)

  if (activityType) {
    query = query.eq('activity_type', activityType)
  }
  if (startDate) {
    query = query.gte('created_at', startDate)
  }
  if (endDate) {
    query = query.lte('created_at', endDate)
  }

  const { data, error } = await query

  if (error) throw error

  // Format dates for frontend
  const activities = data.map((activity: any) => ({
    ...activity,
    created_at: new Date(activity.created_at).toISOString(),
    formatted_date: new Date(activity.created_at).toLocaleString(),
  }))

  return new Response(JSON.stringify({ activities }), {
    headers: { ...corsHeaders, 'Content-Type': 'application/json' },
  })
}

// Create task for Codex
async function handleCreateTask(req: Request, supabase: any, user: any) {
  const body = await req.json()
  const {
    title,
    description,
    priority = 'medium',
    due_date,
    module,
    task_type,
    reference_id,
    reference_table,
  } = body

  // Find Codex user (assuming Codex has email 'codex@system.com')
  const { data: codexUser, error: codexError } = await supabase
    .from('profiles')
    .select('id, email')
    .eq('email', 'codex@system.com')
    .single()

  if (codexError || !codexUser) {
    throw new Error('Codex user not found. Please create a user with email codex@system.com')
  }

  // Create task using database function
  const { data: taskData, error: taskError } = await supabase.rpc(
    'create_task_with_activity',
    {
      p_title: title,
      p_description: description,
      p_created_by: user.id,
      p_assigned_to: codexUser.id,
      p_priority: priority,
      p_due_date: due_date,
      p_module: module,
      p_task_type: task_type,
      p_reference_id: reference_id,
      p_reference_table: reference_table,
    }
  )

  if (taskError) throw taskError

  return new Response(
    JSON.stringify({
      message: 'Task created successfully',
      task_id: taskData,
      assigned_to: {
        id: codexUser.id,
        email: codexUser.email,
      },
    }),
    {
      headers: { ...corsHeaders, 'Content-Type': 'application/json' },
    }
  )
}

// Get tasks (assigned to user or created by user)
async function handleGetTasks(req: Request, supabase: any, user: any) {
  const { searchParams } = new URL(req.url)
  const status = searchParams.get('status')
  const assigned = searchParams.get('assigned') === 'true'

  let query = supabase
    .from('task_assignments')
    .select(`
      *,
      creator:profiles!task_assignments_created_by_fkey (id, email, full_name, avatar_url),
      assignee:profiles!task_assignments_assigned_to_fkey (id, email, full_name, avatar_url),
      comments:task_comments(count),
      comments_details:task_comments(*, commenter:profiles(id, full_name, avatar_url))
    `)

  if (assigned) {
    query = query.eq('assigned_to', user.id)
  } else {
    query = query.or(`created_by.eq.${user.id},assigned_to.eq.${user.id}`)
  }

  if (status) {
    query = query.eq('status', status)
  }

  query = query.order('created_at', { ascending: false })

  const { data: tasks, error } = await query

  if (error) throw error

  return new Response(JSON.stringify({ tasks }), {
    headers: { ...corsHeaders, 'Content-Type': 'application/json' },
  })
}

// Update task status
async function handleUpdateTask(req: Request, supabase: any, user: any) {
  const { task_id, status, comment } = await req.json()

  // Update task status
  const { data: task, error: updateError } = await supabase
    .from('task_assignments')
    .update({
      status,
      ...(status === 'completed' ? { completed_at: new Date().toISOString() } : {}),
    })
    .eq('id', task_id)
    .select()
    .single()

  if (updateError) throw updateError

  // Add comment if provided
  if (comment) {
    const { error: commentError } = await supabase
      .from('task_comments')
      .insert({
        task_id,
        user_id: user.id,
        comment,
        metadata: { status_change: status },
      })

    if (commentError) throw commentError
  }

  // Log activity
  await supabase.rpc('log_user_activity', {
    p_user_id: user.id,
    p_activity_type: 'task_updated',
    p_description: `Updated task "${task.title}" status to ${status}`,
    p_metadata: {
      task_id,
      old_status: task.status,
      new_status: status,
      comment: comment || null,
    },
    p_related_table: 'task_assignments',
    p_related_id: task_id,
  })

  return new Response(
    JSON.stringify({
      message: 'Task updated successfully',
      task,
    }),
    {
      headers: { ...corsHeaders, 'Content-Type': 'application/json' },
    }
  )
}

================================================================================


