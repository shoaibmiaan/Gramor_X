────────────────────────────────────────────────
[1] FILE: pages/writing/index.tsx
────────────────────────────────────────────────
export { default, getServerSideProps } from './overview';



────────────────────────────────────────────────
[2] FILE: pages/writing/progress.tsx
────────────────────────────────────────────────
import { useMemo } from 'react';
import type { GetServerSideProps } from 'next';

import { Badge } from '@/components/design-system/Badge';
import { Button } from '@/components/design-system/Button';
import { Card } from '@/components/design-system/Card';
import { EmptyState } from '@/components/design-system/EmptyState';
import { WritingLayout } from '@/layouts/WritingLayout';
import { withPlanPage } from '@/lib/withPlanPage';
import { getServerClient } from '@/lib/supabaseServer';
import type { Database } from '@/types/supabase';
import type { PlanId } from '@/types/pricing';
import type { AttemptSummary } from '@/types/writing-dashboard';
import { mapAttemptRow } from '@/lib/writing/mappers';

const statusLabel: Record<AttemptSummary['status'], string> = {
  draft: 'Draft in progress',
  submitted: 'Scoring pending',
  scored: 'Scored',
};

const formatDateTime = (value: string) =>
  new Intl.DateTimeFormat(undefined, { dateStyle: 'medium', timeStyle: 'short' }).format(new Date(value));

interface ProgressPageProps {
  drafts: AttemptSummary[];
  recent: AttemptSummary[];
  __plan: PlanId;
}

const WritingProgress = ({ drafts, recent, __plan }: ProgressPageProps) => {
  const totalWords = useMemo(() => recent.reduce((sum, attempt) => sum + attempt.wordCount, 0), [recent]);
  const scoredAttempts = useMemo(() => recent.filter((attempt) => attempt.status === 'scored'), [recent]);
  const averageBand = useMemo(() => {
    const scoredBands = scoredAttempts.map((attempt) => attempt.overallBand ?? 0).filter((band) => band > 0);
    if (scoredBands.length === 0) return null;
    const avg = scoredBands.reduce((sum, band) => sum + band, 0) / scoredBands.length;
    return avg;
  }, [scoredAttempts]);

  return (
    <WritingLayout plan={__plan} current="progress">
      <Card className="card-surface flex flex-col gap-6 p-6 sm:p-8">
        <div className="flex flex-col gap-2 sm:flex-row sm:items-start sm:justify-between">
          <div className="space-y-1">
            <h2 className="text-2xl font-semibold text-foreground">Attempt insights</h2>
            <p className="text-sm text-muted-foreground">
              Track drafts in progress, revisit recent submissions, and spot opportunities for the next rewrite.
            </p>
          </div>
          <Badge variant="soft" tone="default" size="sm">
            {recent.length} recent · {drafts.length} active drafts
          </Badge>
        </div>
        <div className="grid gap-4 sm:grid-cols-3">
          <div className="rounded-2xl border border-border/60 bg-muted/40 p-4">
            <p className="text-xs uppercase tracking-[0.16em] text-muted-foreground">Words logged</p>
            <p className="text-2xl font-semibold text-foreground">{totalWords.toLocaleString()}</p>
            <p className="text-xs text-muted-foreground">Across the last {recent.length} attempts</p>
          </div>
          <div className="rounded-2xl border border-border/60 bg-muted/40 p-4">
            <p className="text-xs uppercase tracking-[0.16em] text-muted-foreground">Scored attempts</p>
            <p className="text-2xl font-semibold text-foreground">{scoredAttempts.length}</p>
            <p className="text-xs text-muted-foreground">{scoredAttempts.length > 0 ? 'Ready for deeper review' : 'Submit drafts for scoring'}</p>
          </div>
          <div className="rounded-2xl border border-border/60 bg-muted/40 p-4">
            <p className="text-xs uppercase tracking-[0.16em] text-muted-foreground">Average band</p>
            <p className="text-2xl font-semibold text-foreground">
              {averageBand ? averageBand.toFixed(1) : '—'}
            </p>
            <p className="text-xs text-muted-foreground">
              {averageBand ? 'Based on scored attempts in the last 90 days' : 'Complete scored attempts to unlock band trends'}
            </p>
          </div>
        </div>
      </Card>

      <section className="grid gap-6 lg:grid-cols-2">
        <Card className="card-surface flex flex-col gap-6 p-6 sm:p-8">
          <div className="flex items-center justify-between gap-3">
            <div>
              <h3 className="text-xl font-semibold text-foreground">Continue drafts</h3>
              <p className="text-sm text-muted-foreground">Pick up where you left off with autosaved work.</p>
            </div>
            <Badge variant="soft" tone="default" size="sm">
              {drafts.length} active
            </Badge>
          </div>
          {drafts.length === 0 ? (
            <EmptyState
              title="No active drafts"
              description="Start a new attempt or revisit a scored attempt to launch a redraft."
            />
          ) : (
            <ul className="space-y-4">
              {drafts.map((attempt) => (
                <li
                  key={attempt.id}
                  className="flex flex-col gap-3 rounded-2xl border border-border/60 bg-card/70 p-5 shadow-sm transition-all hover:-translate-y-0.5"
                >
                  <div className="flex flex-wrap items-center justify-between gap-2">
                    <div>
                      <p className="text-sm font-medium text-foreground">{attempt.promptTopic}</p>
                      <p className="text-xs text-muted-foreground">Updated {formatDateTime(attempt.updatedAt)}</p>
                    </div>
                    <Badge variant="soft" tone="info" size="sm" className="capitalize">
                      {attempt.taskType === 'task1' ? 'Task 1' : 'Task 2'}
                    </Badge>
                  </div>
                  <div className="flex flex-wrap items-center justify-between gap-3 text-sm text-muted-foreground">
                    <span>{attempt.wordCount} words saved</span>
                    <span>{statusLabel[attempt.status]}</span>
                  </div>
                  <div className="flex flex-wrap gap-2">
                    <Button size="sm" variant="primary" href={`/writing/${attempt.promptSlug}?attemptId=${attempt.id}`}>
                      Resume draft
                    </Button>
                    <Button size="sm" variant="ghost" href={`/writing/${attempt.promptSlug}`}>
                      View prompt
                    </Button>
                  </div>
                </li>
              ))}
            </ul>
          )}
        </Card>

        <Card className="card-surface flex flex-col gap-6 p-6 sm:p-8">
          <div className="flex items-center justify-between gap-3">
            <div>
              <h3 className="text-xl font-semibold text-foreground">Recent attempts</h3>
              <p className="text-sm text-muted-foreground">See what you submitted recently and track your scores.</p>
            </div>
            <Badge variant="soft" tone="default" size="sm">
              Last {recent.length}
            </Badge>
          </div>
          {recent.length === 0 ? (
            <EmptyState
              title="No attempts yet"
              description="Submit an essay to unlock AI feedback and trend tracking."
            />
          ) : (
            <ul className="space-y-4">
              {recent.map((attempt) => (
                <li
                  key={attempt.id}
                  className="flex flex-col gap-3 rounded-2xl border border-border/60 bg-card/70 p-5 shadow-sm transition-all hover:-translate-y-0.5"
                >
                  <div className="flex flex-wrap items-center justify-between gap-2">
                    <div>
                      <p className="text-sm font-medium text-foreground">{attempt.promptTopic}</p>
                      <p className="text-xs text-muted-foreground">{formatDateTime(attempt.updatedAt)}</p>
                    </div>
                    <Badge variant="soft" tone={attempt.status === 'scored' ? 'success' : 'info'} size="sm">
                      {statusLabel[attempt.status]}
                    </Badge>
                  </div>
                  <div className="flex flex-wrap items-center justify-between gap-3 text-sm text-muted-foreground">
                    <span>{attempt.wordCount} words</span>
                    {attempt.overallBand ? (
                      <span className="font-semibold text-foreground">Band {attempt.overallBand.toFixed(1)}</span>
                    ) : (
                      <span>Awaiting score</span>
                    )}
                  </div>
                  <div className="flex flex-wrap gap-2">
                    <Button size="sm" variant="outline" href={`/writing/${attempt.promptSlug}?attemptId=${attempt.id}`}>
                      View details
                    </Button>
                    {attempt.hasFeedback && (
                      <Button size="sm" variant="ghost" href={`/writing/review/${attempt.id}`}>
                        Review feedback
                      </Button>
                    )}
                  </div>
                </li>
              ))}
            </ul>
          )}
        </Card>
      </section>

      <Card className="card-surface flex flex-col gap-6 p-6 sm:p-8">
        <div className="flex flex-col gap-3 sm:flex-row sm:items-center sm:justify-between">
          <div>
            <h3 className="text-xl font-semibold text-foreground">Upgrade your analysis</h3>
            <p className="text-sm text-muted-foreground">
              Export writing history, compare drafts side-by-side, and unlock AI prompt generation with Owl.
            </p>
          </div>
          <Badge variant="soft" tone="info" size="sm">
            Keep improving
          </Badge>
        </div>
        <div className="grid gap-4 md:grid-cols-3">
          <Button href="/writing/library" variant="outline">
            Explore prompt library
          </Button>
          <Button href="/writing/reviews" variant="ghost">
            Analyse AI feedback
          </Button>
          <Button href="/pricing?need=master" variant="primary">
            See Owl benefits
          </Button>
        </div>
      </Card>
    </WritingLayout>
  );
};

export const getServerSideProps: GetServerSideProps<ProgressPageProps> = withPlanPage('starter')(async (ctx) => {
  const supabase = getServerClient(ctx.req as any, ctx.res as any);
  const {
    data: { user },
  } = await supabase.auth.getUser();

  if (!user) {
    return {
      redirect: {
        destination: '/welcome?from=/writing',
        permanent: false,
      },
    };
  }

  const { data: attemptRows } = await supabase
    .from('writing_attempts')
    .select('id, prompt_id, status, updated_at, word_count, overall_band, task_type, feedback_json, writing_prompts (slug, topic)')
    .eq('user_id', user.id)
    .order('updated_at', { ascending: false })
    .limit(30);

  const attempts = (attemptRows ?? []).map((row) =>
    mapAttemptRow({
      ...row,
      prompt: row.writing_prompts as Pick<Database['public']['Tables']['writing_prompts']['Row'], 'slug' | 'topic'> | null,
    }),
  );

  const drafts = attempts.filter((attempt) => attempt.status !== 'scored');
  const recent = attempts.slice(0, 20);

  return {
    props: {
      drafts,
      recent,
    },
  } as any;
});

export default WritingProgress;



────────────────────────────────────────────────
[3] FILE: pages/writing/mock/index.tsx
────────────────────────────────────────────────
import React, { useMemo, useState } from 'react';
import type { GetServerSideProps } from 'next';

import { Card } from '@/components/design-system/Card';
import { Badge } from '@/components/design-system/Badge';
import { Button } from '@/components/design-system/Button';
import { ModuleMockShell, ModuleMockShellSection } from '@/components/mock-tests/ModuleMockShell';
import { Tabs, TabsList, TabsTrigger, TabsContent } from '@/components/design-system/Tabs';
import { writingExamSummaries } from '@/data/writing/exam-index';
import { getServerClient } from '@/lib/supabaseServer';

const formatDate = (iso: string) => {
  try {
    return new Intl.DateTimeFormat(undefined, {
      dateStyle: 'medium',
      timeStyle: 'short',
    }).format(new Date(iso));
  } catch {
    return iso;
  }
};

const formatBand = (value: number | null | undefined) => {
  if (typeof value !== 'number' || Number.isNaN(value)) return '—';
  return value.toFixed(1);
};

type AttemptStatus = 'in_progress' | 'completed' | 'reviewed';

type AttemptHistory = {
  attemptId: string;
  mockId: string | null;
  title: string;
  taskLabel: string;
  startedAt: string;
  status: AttemptStatus;
  aiBand: number | null;
  teacherBand: number | null;
};

interface PageProps {
  history: AttemptHistory[];
}

const tabOrder = ['full', 'task1', 'task2'] as const;
type TabKey = (typeof tabOrder)[number];

const tabs: Record<TabKey, { label: string; helper: string }> = {
  full: {
    label: 'Full Mock',
    helper: 'Complete Task 1 and Task 2 together with a 60 minute timer.',
  },
  task1: {
    label: 'Task 1',
    helper: 'Focus on visuals, letters, and data commentary prompts.',
  },
  task2: {
    label: 'Task 2',
    helper: 'Essay questions covering opinion, discussion, and problem/solution styles.',
  },
};

const summaryMap = new Map(writingExamSummaries.map((paper) => [paper.id, paper]));

const filterSummaries = (key: TabKey) => {
  switch (key) {
    case 'task1':
      return writingExamSummaries.filter((paper) => paper.task1Focus);
    case 'task2':
      return writingExamSummaries.filter((paper) => paper.task2Focus);
    case 'full':
    default:
      return writingExamSummaries;
  }
};

const statusBadgeTone: Record<AttemptStatus, 'info' | 'neutral' | 'success'> = {
  in_progress: 'info',
  completed: 'neutral',
  reviewed: 'success',
};

const statusLabelText: Record<AttemptStatus, string> = {
  in_progress: 'In progress',
  completed: 'Completed',
  reviewed: 'Reviewed',
};

const actionCopy: Record<AttemptStatus, { label: string; href: (attemptId: string, mockId: string | null) => string }> = {
  in_progress: {
    label: 'Resume',
    href: (attemptId) => `/writing/mock/${attemptId}/workspace`,
  },
  completed: {
    label: 'View results',
    href: (attemptId) => `/writing/mock/${attemptId}/results`,
  },
  reviewed: {
    label: 'Open review',
    href: (attemptId) => `/writing/mock/${attemptId}/review`,
  },
};

const WritingMockIndexPage: React.FC<PageProps> = ({ history }) => {
  const [tab, setTab] = useState<TabKey>('full');

  const activeSummaries = useMemo(() => filterSummaries(tab), [tab]);
  const primarySummary = activeSummaries[0] ?? writingExamSummaries[0] ?? null;
  const moduleDuration = writingExamSummaries[0]?.durationMinutes ?? 60;

  return (
    <ModuleMockShell
      title="IELTS Writing Mock Tests"
      description="Simulate the full 60-minute module with autosave, idle detection, and AI band scoring across Task Achievement, Coherence, Lexical Resource, and Grammar."
      heroVariant="split"
      badges={
        <>
          <Badge variant="neutral" size="sm">Autosave every 10s</Badge>
          <Badge variant="neutral" size="sm">Focus guard enabled</Badge>
          <Badge variant="neutral" size="sm">Instant band breakdown</Badge>
        </>
      }
      actions={
        primarySummary ? (
          <Button
            href={`/writing/mock/${primarySummary.id}/start`}
            variant="primary"
            size="lg"
            className="rounded-ds"
          >
            Start new test
          </Button>
        ) : null
      }
      stats={[
        {
          label: 'Module duration',
          value: `${moduleDuration} mins`,
          helper: 'Full Task 1 + Task 2 timing',
        },
        {
          label: 'Mock library',
          value: `${writingExamSummaries.length} sets`,
          helper: 'Academic & General Training prompts',
        },
        {
          label: 'Feedback coverage',
          value: '4 band criteria',
          helper: 'Task • Coherence • Lexical • Grammar',
        },
      ]}
    >
      <ModuleMockShellSection>
        <Tabs defaultValue="full" value={tab} onValueChange={(value) => setTab(value as TabKey)}>
          <TabsList>
            {tabOrder.map((key) => (
              <TabsTrigger key={key} value={key}>
                {tabs[key].label}
              </TabsTrigger>
            ))}
          </TabsList>

          {tabOrder.map((key) => (
            <TabsContent key={key} value={key}>
              <p className="text-sm text-muted-foreground">{tabs[key].helper}</p>
              <div className="mt-6 grid gap-6 md:grid-cols-2 xl:grid-cols-3">
                {filterSummaries(key).map((paper) => (
                  <Card key={paper.id} className="card-surface h-full rounded-ds-2xl p-6">
                    <div className="flex flex-col gap-3">
                      <div className="flex flex-wrap items-center gap-2">
                        <h2 className="text-lg font-semibold text-foreground">{paper.title}</h2>
                        <Badge variant="info" size="sm">{paper.task1Type}</Badge>
                        {paper.register ? <Badge variant="outline" size="sm">{paper.register}</Badge> : null}
                      </div>
                      <p className="text-sm text-muted-foreground">{paper.description}</p>
                      <div className="flex flex-wrap gap-2 text-xs text-muted-foreground">
                        {key !== 'task2' ? (
                          <Badge variant="neutral" size="sm">Task 1: {paper.task1Focus}</Badge>
                        ) : null}
                        {key !== 'task1' ? (
                          <Badge variant="secondary" size="sm">Task 2: {paper.task2Focus}</Badge>
                        ) : null}
                        <Badge variant="ghost" size="sm">{paper.durationMinutes} minutes</Badge>
                      </div>
                      <Button href={`/writing/mock/${paper.id}/start`} variant="primary" className="mt-2 w-fit rounded-ds">
                        {key === 'task1' ? 'Practice Task 1' : key === 'task2' ? 'Practice Task 2' : 'Start full mock'}
                      </Button>
                    </div>
                  </Card>
                ))}
              </div>
            </TabsContent>
          ))}
        </Tabs>
      </ModuleMockShellSection>

      <ModuleMockShellSection as="section" className="space-y-4">
        <div className="flex items-center justify-between">
          <div>
            <h2 className="text-h3 font-semibold text-foreground">Recent attempts</h2>
            <p className="text-sm text-muted-foreground">Track submissions, AI scores, and review progress.</p>
          </div>
          <Button href="/writing/progress" variant="ghost" size="sm" className="rounded-ds">
            View analytics
          </Button>
        </div>

        <Card className="card-surface rounded-ds-2xl p-0">
          {history.length === 0 ? (
            <div className="p-6 text-sm text-muted-foreground">
              No attempts yet. Start a mock to see your scores and feedback here.
            </div>
          ) : (
            <div className="overflow-x-auto">
              <table className="min-w-full divide-y divide-border/60 text-left text-sm">
                <thead className="bg-muted/40">
                  <tr>
                    <th className="px-4 py-3 font-medium text-muted-foreground">Test</th>
                    <th className="px-4 py-3 font-medium text-muted-foreground">Started</th>
                    <th className="px-4 py-3 font-medium text-muted-foreground">Status</th>
                    <th className="px-4 py-3 font-medium text-muted-foreground">AI band</th>
                    <th className="px-4 py-3 font-medium text-muted-foreground">Teacher band</th>
                    <th className="px-4 py-3 text-right font-medium text-muted-foreground">Action</th>
                  </tr>
                </thead>
                <tbody className="divide-y divide-border/40">
                  {history.map((entry) => {
                    const action = actionCopy[entry.status];
                    const statusTone = statusBadgeTone[entry.status];
                    return (
                      <tr key={entry.attemptId} className="bg-background/80">
                        <td className="px-4 py-3">
                          <div className="flex flex-col">
                            <span className="font-medium text-foreground">{entry.title}</span>
                            <span className="text-xs text-muted-foreground">{entry.taskLabel}</span>
                          </div>
                        </td>
                        <td className="px-4 py-3 text-sm text-muted-foreground">{formatDate(entry.startedAt)}</td>
                        <td className="px-4 py-3">
                          <Badge variant={statusTone} size="sm">{statusLabelText[entry.status]}</Badge>
                        </td>
                        <td className="px-4 py-3 text-sm text-foreground">{formatBand(entry.aiBand)}</td>
                        <td className="px-4 py-3 text-sm text-foreground">{formatBand(entry.teacherBand)}</td>
                        <td className="px-4 py-3 text-right">
                          <Button
                            href={action.href(entry.attemptId, entry.mockId)}
                            size="sm"
                            variant="secondary"
                            className="rounded-ds"
                          >
                            {action.label}
                          </Button>
                        </td>
                      </tr>
                    );
                  })}
                </tbody>
              </table>
            </div>
          )}
        </Card>
      </ModuleMockShellSection>
    </ModuleMockShell>
  );
};

export const getServerSideProps: GetServerSideProps<PageProps> = async (ctx) => {
  const supabase = getServerClient(ctx.req as any, ctx.res as any);
  const {
    data: { user },
  } = await supabase.auth.getUser();

  if (!user) {
    return {
      redirect: {
        destination: '/welcome',
        permanent: false,
      },
    };
  }

  const { data: attempts } = await supabase
    .from('exam_attempts')
    .select('id, user_id, status, started_at, submitted_at, updated_at, metadata')
    .eq('user_id', user.id)
    .eq('exam_type', 'writing')
    .order('created_at', { ascending: false })
    .limit(20);

  const attemptRows = attempts ?? [];
  const attemptIds = attemptRows.map((row) => row.id);

  const { data: responseRows } = attemptIds.length
    ? await supabase
        .from('writing_responses')
        .select('exam_attempt_id, overall_band')
        .in('exam_attempt_id', attemptIds)
    : { data: [] };

  const { data: reviewRows } = attemptIds.length
    ? await supabase
        .from('writing_reviews')
        .select('attempt_id, scores_json, created_at')
        .in('attempt_id', attemptIds)
    : { data: [] };

  const history: AttemptHistory[] = attemptRows.map((row) => {
    const metadata = (row.metadata as Record<string, unknown> | null) ?? null;
    const mockId = typeof metadata?.mockId === 'string' ? (metadata.mockId as string) : null;
    const summary = mockId ? summaryMap.get(mockId) : undefined;

    const responses = (responseRows ?? []).filter((resp) => resp.exam_attempt_id === row.id);
    const aiBand = responses.length
      ? Number(
          (
            responses.reduce((total, resp) => total + Number(resp.overall_band ?? 0), 0) /
            responses.length
          ).toFixed(1),
        )
      : null;

    const reviews = (reviewRows ?? [])
      .filter((review) => review.attempt_id === row.id)
      .sort((a, b) => new Date(b.created_at ?? '').getTime() - new Date(a.created_at ?? '').getTime());

    let teacherBand: number | null = null;
    if (reviews.length > 0) {
      const latest = reviews[0];
      const scores = (latest.scores_json as Record<string, number> | null) ?? null;
      if (scores) {
        const values = Object.values(scores)
          .map((value) => Number(value))
          .filter((value) => Number.isFinite(value));
        if (values.length > 0) {
          teacherBand = Number((values.reduce((total, value) => total + value, 0) / values.length).toFixed(1));
        }
      }
    }

    let status: AttemptStatus = 'in_progress';
    if (reviews.length > 0) {
      status = 'reviewed';
    } else if (aiBand !== null || row.status === 'completed' || row.status === 'submitted') {
      status = 'completed';
    }

    const title = summary?.title ?? 'Writing mock attempt';
    const taskLabel = summary?.task1Type ? `${summary.task1Type} · ${summary?.register ?? 'Neutral'}` : 'Custom attempt';
    const startedAt = row.started_at ?? row.submitted_at ?? row.updated_at ?? new Date().toISOString();

    return {
      attemptId: row.id,
      mockId,
      title,
      taskLabel,
      startedAt,
      status,
      aiBand,
      teacherBand,
    };
  });

  return { props: { history } };
};

export default WritingMockIndexPage;



────────────────────────────────────────────────
[4] FILE: pages/writing/mock/[mockId]/results.tsx
────────────────────────────────────────────────
import React, { useCallback, useEffect, useMemo, useRef, useState } from 'react';
import type { GetServerSideProps } from 'next';
import Link from 'next/link';
import dynamic from 'next/dynamic';

import { Button } from '@/components/design-system/Button';
import { Container } from '@/components/design-system/Container';
import { Badge } from '@/components/design-system/Badge';
import BandDiffView from '@/components/writing/BandDiffView';
import BandProgressChart from '@/components/writing/BandProgressChart';
import WritingResultCard from '@/components/writing/WritingResultCard';
import AccessibilityHints from '@/components/writing/AccessibilityHints';
import ExportButton from '@/components/writing/ExportButton';
import ReferralCard from '@/components/account/ReferralCard';
import { UpgradeDialog } from '@/components/billing/UpgradeDialog';
import { Variant, useVariantConversion } from '@/components/exp/Variant';
import { computeWritingSummary } from '@/lib/analytics/writing';
import {
  logWritingCoachEntry,
  logWritingResultsAnalyticsClick,
  logWritingResultsShare,
  logWritingResultsView,
} from '@/lib/analytics/writing-events';
import { getServerClient } from '@/lib/supabaseServer';
import { computeCriterionDeltas, trimProgressPoints } from '@/lib/writing/progress';
import { calculateWritingXp, type WritingAchievement } from '@/lib/gamification/xp';
import type { CriterionDelta, WritingProgressPoint } from '@/types/analytics';
import type { WritingFeedback, WritingScorePayload, WritingTaskType } from '@/types/writing';
import type { PlanId } from '@/types/pricing';
import { resolveFlags } from '@/lib/flags';
import { track } from '@/lib/analytics/track';
import { evaluateQuota, nextPlanForQuota, type QuotaKey } from '@/lib/plan/quotas';
import { planAllows } from '@/lib/plan/gates';
import { KeyboardAwareSheet } from '@/components/mobile/KeyboardAwareSheet';
import { PushOptInCard } from '@/components/mobile/PushOptInCard';
import { InstallBanner } from '@/components/mobile/InstallBanner';
import { useInstallPrompt } from '@/hooks/useInstallPrompt';
import { useInstalledApp } from '@/hooks/useInstalledApp';

interface HighlightSection {
  task: WritingTaskType;
  essay: string;
  feedback: WritingFeedback;
}

interface PageProps {
  plan: PlanId;
  featureFlags: {
    writingExports: boolean;
    writingCertificates: boolean;
  };
  attemptId: string;
  results: Array<{ task: WritingTaskType; essay: string; score: WritingScorePayload }>;
  averageBand: number;
  highlight?: HighlightSection | null;
  progressPoints: WritingProgressPoint[];
  progressDeltas: CriterionDelta[];
  xp: {
    points: number;
    reason: string;
    achievements: WritingAchievement[];
    improvement: number;
    durationSeconds: number | null;
  };
  quota: { key: QuotaKey; used: number } | null;
  referralCode?: string | null;
}

const CoachDock = dynamic(() => import('@/components/writing/CoachDock'), {
  ssr: false,
  loading: () => (
    <div className="rounded-ds-xl border border-dashed border-border/60 bg-muted/20 p-4 text-sm text-muted-foreground">
      Loading coach…
    </div>
  ),
});

const quotaCopy: Record<QuotaKey, { title: string; helper: string }> = {
  dailyMocks: {
    title: 'Daily mock limit reached',
    helper: 'Upgrade to unlock more daily attempts and keep your streak going.',
  },
  aiEvaluationsPerDay: {
    title: 'AI feedback limit reached',
    helper: 'Upgrade to increase your daily writing evaluations.',
  },
  storageGB: {
    title: 'Storage limit reached',
    helper: 'Upgrade to expand your library for essays and speaking recordings.',
  },
};

const formatPlanLabel = (id: PlanId) => id.charAt(0).toUpperCase() + id.slice(1);

const quotaLimitText = (key: QuotaKey, limit: number) => {
  const isUnlimited = !Number.isFinite(limit);
  switch (key) {
    case 'dailyMocks':
      return isUnlimited ? 'unlimited daily mock tests' : `${limit} daily mock test${limit === 1 ? '' : 's'}`;
    case 'aiEvaluationsPerDay':
      return isUnlimited
        ? 'unlimited daily AI evaluations'
        : `${limit} daily AI evaluation${limit === 1 ? '' : 's'}`;
    case 'storageGB':
      return isUnlimited ? 'unlimited storage' : `${limit} GB of storage`;
    default:
      return isUnlimited ? 'unlimited usage' : `${limit}`;
  }
};

type QuotaUpgradeNoticeProps = {
  plan: PlanId;
  quota: { key: QuotaKey; used: number } | null;
  evaluation: ReturnType<typeof evaluateQuota> | null;
  onUpgrade: () => void;
};

function QuotaUpgradeNotice({ plan, quota, evaluation, onUpgrade }: QuotaUpgradeNoticeProps) {
  if (!quota || !evaluation || !evaluation.exceeded) return null;
  const copy = quotaCopy[quota.key];
  const limitText = evaluation.isUnlimited ? 'unlimited' : evaluation.limit;
  const currentPlanLabel = formatPlanLabel(plan);
  const nextPlanId = nextPlanForQuota(plan, quota.key);
  const nextPlanLimit = nextPlanId ? evaluateQuota(nextPlanId, quota.key, 0).limit : null;
  const nextPlanCopy =
    nextPlanId && nextPlanLimit !== null
      ? ` ${formatPlanLabel(nextPlanId)} unlocks ${quotaLimitText(quota.key, nextPlanLimit)}.`
      : '';

  return (
    <section className="rounded-ds-xl border border-destructive/40 bg-destructive/10 p-5">
      <div className="flex flex-col gap-4 md:flex-row md:items-center md:justify-between">
        <div>
          <h2 className="text-base font-semibold text-destructive">{copy.title}</h2>
          <p className="mt-1 text-sm text-muted-foreground">
            You have used {quota.used} of {limitText} available today on the {currentPlanLabel} plan. {copy.helper}
            {nextPlanCopy}
          </p>
        </div>
        <Button size="sm" variant="primary" onClick={onUpgrade}>
          Upgrade plan
        </Button>
      </div>
    </section>
  );
}

type ReferralVariantSlotProps = { source?: string };

function ReferralVariantSlot({ source = 'writing-results' }: ReferralVariantSlotProps) {
  const trackConversion = useVariantConversion();

  const handleCodeGenerated = useCallback(
    (code: string) => {
      void trackConversion({ action: 'referral-code', codeLength: code.length });
    },
    [trackConversion],
  );

  const handleShare = useCallback(
    (mode: 'copy' | 'share' | 'error') => {
      if (mode === 'error') return;
      void trackConversion({ action: 'referral-share', method: mode });
    },
    [trackConversion],
  );

  return (
    <ReferralCard
      className="mt-6"
      source={source}
      onCodeGenerated={handleCodeGenerated}
      onShare={handleShare}
    />
  );
}

const WritingResultsPage: React.FC<PageProps> = ({
  plan,
  featureFlags,
  attemptId,
  results,
  averageBand,
  highlight,
  progressPoints,
  progressDeltas,
  xp,
  quota,
  referralCode,
}) => {
  const [shareStatus, setShareStatus] = useState<'idle' | 'copied' | 'shared' | 'error'>('idle');
  const [upgradeOpen, setUpgradeOpen] = useState(false);
  const { isInstalled } = useInstalledApp();
  const { promptEvent, clearPrompt } = useInstallPrompt();
  const [sheetOpen, setSheetOpen] = useState(false);
  const [installDismissed, setInstallDismissed] = useState(false);
  const [pushDismissed, setPushDismissed] = useState(false);
  const [pushStatus, setPushStatus] = useState<NotificationPermission>(() => {
    if (typeof window === 'undefined' || typeof Notification === 'undefined') return 'default';
    return Notification.permission;
  });

  useEffect(() => {
    if (typeof window === 'undefined' || typeof Notification === 'undefined') return;
    setPushStatus(Notification.permission);
  }, []);

  const supportsPush = typeof window !== 'undefined' && typeof Notification !== 'undefined';

  const shouldShowInstall = useMemo(() => {
    if (!planAllows(plan, 'writing.install.prompt')) return false;
    if (isInstalled || installDismissed) return false;
    return Boolean(promptEvent);
  }, [installDismissed, isInstalled, plan, promptEvent]);

  const shouldShowPush = useMemo(() => {
    if (!planAllows(plan, 'writing.push.optin')) return false;
    if (!supportsPush) return false;
    if (pushStatus === 'granted' || pushDismissed) return false;
    return true;
  }, [plan, pushDismissed, pushStatus, supportsPush]);

  const hasEngagementPrompts = shouldShowInstall || shouldShowPush;

  useEffect(() => {
    if (!hasEngagementPrompts) {
      setSheetOpen(false);
    }
  }, [hasEngagementPrompts]);

  const handleInstallComplete = (outcome: 'accepted' | 'dismissed') => {
    setInstallDismissed(true);
    clearPrompt();
    if (outcome === 'accepted') {
      setSheetOpen(false);
    }
  };

  const handlePushGranted = () => {
    setPushStatus('granted');
    setSheetOpen(false);
  };

  const handlePushDismiss = () => {
    setPushDismissed(true);
  };

  const quotaEvaluation = useMemo(() => {
    if (!quota) return null;
    return evaluateQuota(plan, quota.key, quota.used);
  }, [plan, quota?.key, quota?.used]);

  const paywallTrackedRef = useRef(false);
  useEffect(() => {
    if (!quota || !quotaEvaluation?.exceeded || paywallTrackedRef.current) return;
    paywallTrackedRef.current = true;
    track('paywall_view', { source: 'writing_results', quota: quota.key, plan });
  }, [plan, quota, quotaEvaluation?.exceeded]);

  useEffect(() => {
    logWritingCoachEntry({ attemptId, tasks: results.length, averageBand });
    logWritingResultsView({ attemptId, tasks: results.length, averageBand });
  }, [attemptId, results.length, averageBand]);

  const shareLabel = useMemo(() => {
    if (shareStatus === 'copied') return 'Link copied!';
    if (shareStatus === 'shared') return 'Shared — nice!';
    if (shareStatus === 'error') return 'Sharing unavailable';
    return 'Share results';
  }, [shareStatus]);

  const shareFeedback = useMemo(() => {
    if (shareStatus === 'copied') return 'Share link copied to clipboard';
    if (shareStatus === 'shared') return 'Shared successfully';
    if (shareStatus === 'error') return 'Sharing failed';
    return 'Ready to share';
  }, [shareStatus]);

  const handleShare = useCallback(async () => {
    const shareText = `I just logged a band ${averageBand.toFixed(1)} IELTS writing mock on GramorX!`;
    const shareUrl =
      typeof window !== 'undefined'
        ? `${window.location.origin}/writing/mock/${attemptId}/results`
        : 'https://gramorx.com/writing/mock';

    try {
      if (typeof navigator !== 'undefined' && navigator.share) {
        await navigator.share({
          title: 'GramorX Writing Results',
          text: shareText,
          url: shareUrl,
        });
        setShareStatus('shared');
        logWritingResultsShare({ attemptId, method: 'web-share', status: 'shared' });
        return;
      }

      if (typeof navigator !== 'undefined' && navigator.clipboard) {
        await navigator.clipboard.writeText(shareUrl);
        setShareStatus('copied');
        logWritingResultsShare({ attemptId, method: 'clipboard', status: 'copied' });
        return;
      }

      throw new Error('Sharing not supported');
    } catch (error) {
      console.warn('[writing/results] share failed', error);
      setShareStatus('error');
      logWritingResultsShare({ attemptId, method: 'fallback', status: 'error' });
    }
  }, [attemptId, averageBand]);

  const handleAnalyticsClick = useCallback(() => {
    logWritingResultsAnalyticsClick({ attemptId });
  }, [attemptId]);

  const openUpgrade = useCallback(() => setUpgradeOpen(true), []);
  const closeUpgrade = useCallback(() => setUpgradeOpen(false), []);

  const referralVariant = (
    <Variant
      experiment="writing_results_referral"
      context={{ plan, attemptId, quota: quota?.key ?? null }}
      fallback={null}
      variants={{
        control: null,
        referral: <ReferralVariantSlot source="writing-results" />,
      }}
    />
  );

  return (
    <Container className="py-12">
      {quota ? (
        <UpgradeDialog
          open={upgradeOpen}
          onClose={closeUpgrade}
          plan={plan}
          quota={quota}
          referralCode={referralCode ?? undefined}
          source="writing-results"
        />
      ) : null}
      <div className="mx-auto flex max-w-4xl flex-col gap-8">
        <header className="flex flex-col gap-3">
          <h1 className="text-3xl font-semibold text-foreground">Mock writing results</h1>
          <p className="text-sm text-muted-foreground">Attempt ID: {attemptId}</p>
          <div className="flex flex-wrap items-center gap-3 text-sm text-muted-foreground">
            <span className="rounded-full border border-border px-3 py-1 font-medium text-foreground">
              Average band {averageBand.toFixed(1)}
            </span>
            <Badge variant="success" size="sm">
              +{xp.points} XP
            </Badge>
            <Link href={`/writing/mock/${attemptId}/review`}>
              <Button size="sm" variant="secondary">
                Detailed review
              </Button>
            </Link>
          </div>
          <div className="flex flex-wrap items-center gap-3">
            <Button size="sm" variant="primary" onClick={handleShare} aria-describedby="share-status">
              {shareLabel}
            </Button>
            <span id="share-status" className="sr-only" aria-live="polite">
              {shareFeedback}
            </span>
            {featureFlags.writingExports ? (
              <ExportButton attemptId={attemptId} />
            ) : null}
            {featureFlags.writingCertificates ? (
              <Button
                size="sm"
                variant="outline"
                onClick={() => {
                  track('cert.view', { attemptId, plan });
                  window.open(`/cert/writing/${attemptId}`, '_blank');
                }}
              >
                Certificate
              </Button>
            ) : null}
            <Link href="/analytics/writing" onClick={handleAnalyticsClick} className="inline-flex">
              <Button size="sm" variant="secondary">
                Open analytics
              </Button>
            </Link>
          </div>
        </header>

        {hasEngagementPrompts ? (
          <div className="hidden gap-4 md:grid md:grid-cols-2">
            {shouldShowInstall ? (
              <InstallBanner promptEvent={promptEvent} onComplete={handleInstallComplete} onDismiss={handleInstallComplete} />
            ) : null}
            {shouldShowPush ? (
              <PushOptInCard onGranted={handlePushGranted} onDismiss={handlePushDismiss} />
            ) : null}
          </div>
        ) : null}

        {hasEngagementPrompts ? (
          <div className="flex justify-center md:hidden">
            <Button size="lg" variant="secondary" onClick={() => setSheetOpen(true)}>
              Stay connected
            </Button>
          </div>
        ) : null}

        {xp.achievements.length > 0 ? (
          <section className="rounded-ds-xl border border-border/60 bg-muted/20 p-5">
            <div className="flex flex-wrap items-center justify-between gap-3">
              <h2 className="text-base font-semibold text-foreground">Achievements unlocked</h2>
              <Badge variant="success" size="sm">
                +{xp.points} XP total
              </Badge>
            </div>
            <div className="mt-4 grid gap-3 md:grid-cols-2">
              {xp.achievements.map((achievement) => (
                <div
                  key={`${achievement.id}-${achievement.label}`}
                  className="rounded-lg border border-border/50 bg-background/80 p-4 shadow-sm"
                >
                  <div className="flex items-baseline justify-between gap-2">
                    <p className="text-sm font-medium text-foreground">{achievement.label}</p>
                    <span className="text-sm font-semibold text-primary">+{achievement.points} XP</span>
                  </div>
                  {achievement.description ? (
                    <p className="mt-1 text-xs text-muted-foreground">{achievement.description}</p>
                  ) : null}
                </div>
              ))}
            </div>
          </section>
        ) : null}

        <AccessibilityHints />

        {results.length === 0 ? (
          <p className="text-sm text-muted-foreground">Scores are still processing. Refresh this page in a few seconds.</p>
        ) : (
          results.map((result) => (
            <WritingResultCard key={result.task} task={result.task} result={result.score} essay={result.essay} />
          ))
        )}

        {highlight ? (
          <BandDiffView essay={highlight.essay} feedback={highlight.feedback} />
        ) : (
          <div className="rounded-ds-xl border border-border/60 bg-muted/30 p-6 text-sm text-muted-foreground">
            Detailed highlights will appear once AI feedback is ready.
          </div>
        )}

        <BandProgressChart points={progressPoints} deltas={progressDeltas} />

        <QuotaUpgradeNotice plan={plan} quota={quota} evaluation={quotaEvaluation} onUpgrade={openUpgrade} />

        {referralVariant}

        <section className="space-y-4">
          <h2 className="text-lg font-semibold text-foreground">Need a next step?</h2>
          <p className="text-sm text-muted-foreground">
            Chat with the AI writing coach to plan rewrites, upgrade paragraphs, or build lexical drills using this attempt.
          </p>
          <CoachDock attemptId={attemptId} />
        </section>
      </div>

      <KeyboardAwareSheet
        open={sheetOpen && hasEngagementPrompts}
        title="Stay connected"
        description="Install the app or enable notifications to follow your progress on the go."
        onClose={() => setSheetOpen(false)}
      >
        {shouldShowInstall ? (
          <InstallBanner promptEvent={promptEvent} onComplete={handleInstallComplete} onDismiss={handleInstallComplete} />
        ) : null}
        {shouldShowPush ? (
          <PushOptInCard onGranted={handlePushGranted} onDismiss={handlePushDismiss} />
        ) : null}
      </KeyboardAwareSheet>
    </Container>
  );
};

export const getServerSideProps: GetServerSideProps<PageProps> = async (ctx) => {
  const supabase = getServerClient(ctx.req as any, ctx.res as any);
  const {
    data: { user },
  } = await supabase.auth.getUser();
  if (!user) {
    return {
      redirect: {
        destination: '/welcome',
        permanent: false,
      },
    };
  }

  const { mockId: attemptId } = ctx.params as { mockId: string };

  const { data: attempt, error } = await supabase
    .from('exam_attempts')
    .select('*')
    .eq('id', attemptId)
    .maybeSingle();

  if (error || !attempt || attempt.user_id !== user.id) {
    return { notFound: true };
  }

  const { data: profileRow } = await supabase
    .from('profiles')
    .select('plan, role')
    .eq('id', user.id)
    .maybeSingle();

  const plan = (profileRow?.plan as PlanId | undefined) ?? 'free';
  const role = (profileRow?.role as string | null) ?? null;

  const todayStart = new Date();
  todayStart.setUTCHours(0, 0, 0, 0);
  const todayIso = todayStart.toISOString();

  const [{ count: dailyMocksCount }, { count: aiEvaluationsCount }] = await Promise.all([
    supabase
      .from('exam_attempts')
      .select('id', { count: 'exact', head: true })
      .eq('user_id', user.id)
      .eq('exam_type', 'writing')
      .gte('started_at', todayIso),
    supabase
      .from('writing_responses')
      .select('id', { count: 'exact', head: true })
      .eq('user_id', user.id)
      .gte('created_at', todayIso),
  ]);

  const quotaCandidates: Array<{ key: QuotaKey; used: number }> = [
    { key: 'dailyMocks', used: dailyMocksCount ?? 0 },
    { key: 'aiEvaluationsPerDay', used: aiEvaluationsCount ?? 0 },
    { key: 'storageGB', used: 0 },
  ];

  const quotaHit =
    quotaCandidates.find((candidate) => evaluateQuota(plan, candidate.key, candidate.used).exceeded) ?? null;

  const flagSnapshot = await resolveFlags({ plan, role, userId: user.id });

  const { data: responses } = await supabase
    .from('writing_responses')
    .select('id, task, answer_text, word_count, overall_band, band_scores, feedback, duration_seconds, evaluation_version, submitted_at, created_at')
    .eq('exam_attempt_id', attemptId);

  const responseIds = (responses ?? []).map((row) => row.id).filter(Boolean);
  const { data: feedbackRows } = responseIds.length
    ? await supabase
        .from('writing_feedback')
        .select('attempt_id, band9_rewrite, errors, blocks')
        .in('attempt_id', responseIds as string[])
    : { data: [] };

  const scores = (responses ?? [])
    .filter((row) => row.task === 'task1' || row.task === 'task2')
    .map((row) => ({
      task: row.task as WritingTaskType,
      essay: row.answer_text ?? '',
      score: {
        version: (row.evaluation_version as string) ?? 'baseline-v1',
        overallBand: row.overall_band ?? 0,
        bandScores: (row.band_scores as any) ?? {
          task_response: 0,
          coherence_and_cohesion: 0,
          lexical_resource: 0,
          grammatical_range: 0,
        },
        feedback:
          (row.feedback as any) ?? {
            summary: 'No feedback recorded yet.',
            strengths: [],
            improvements: [],
            perCriterion: {
              task_response: { band: 0, feedback: '' },
              coherence_and_cohesion: { band: 0, feedback: '' },
              lexical_resource: { band: 0, feedback: '' },
              grammatical_range: { band: 0, feedback: '' },
            },
          },
        wordCount: row.word_count ?? 0,
        durationSeconds: row.duration_seconds ?? undefined,
        tokensUsed: undefined,
      } satisfies WritingScorePayload,
      id: row.id as string,
    }));

  const summary = computeWritingSummary(
    scores.map((entry) => ({
      id: `${attemptId}-${entry.task}`,
      attemptId,
      examAttemptId: attemptId,
      promptId: undefined,
      task: entry.task,
      answerText: entry.essay,
      wordCount: entry.score.wordCount,
      overallBand: entry.score.overallBand,
      bandScores: entry.score.bandScores,
      feedback: entry.score.feedback,
      durationSeconds: entry.score.durationSeconds,
      evaluationVersion: entry.score.version,
      tokensUsed: entry.score.tokensUsed,
      createdAt: attempt.created_at,
      submittedAt: attempt.submitted_at ?? attempt.updated_at ?? attempt.created_at,
      metadata: null,
    })),
  );

  const progress = await loadProgress(supabase, user.id, attemptId);

  const sortedPoints = [...progress.points].sort(
    (a, b) => new Date(a.createdAt).getTime() - new Date(b.createdAt).getTime(),
  );
  const currentPoint = sortedPoints.find((point) => point.attemptId === attemptId) ?? null;
  const previousPoint = sortedPoints.filter((point) => point.attemptId !== attemptId).pop() ?? null;

  const xpSummary = calculateWritingXp({
    currentOverall: currentPoint?.overallBand ?? summary.averageBand ?? 0,
    previousOverall: previousPoint?.overallBand ?? null,
    submittedAt: attempt.submitted_at ?? attempt.updated_at ?? attempt.created_at ?? null,
    startedAt: attempt.started_at ?? attempt.created_at ?? null,
    durationSeconds: attempt.duration_seconds ?? null,
  });

  const referralCode = typeof ctx.query.code === 'string' ? ctx.query.code : null;

  return {
    props: {
      plan,
      featureFlags: {
        writingExports: Boolean(flagSnapshot.writingExports),
        writingCertificates: Boolean(flagSnapshot.writingCertificates),
      },
      attemptId,
      results: scores.map(({ id: _id, ...rest }) => rest),
      averageBand: summary.averageBand || 0,
      highlight:
        scores.length > 0
          ? (() => {
              const primary = scores.find((entry) => entry.task === 'task2') ?? scores[0];
              const feedbackRow = feedbackRows?.find((row) => row.attempt_id === primary.id);
              const combinedFeedback: WritingFeedback = {
                ...primary.score.feedback,
                band9Rewrite: feedbackRow?.band9_rewrite ?? primary.score.feedback.band9Rewrite,
                errors: (feedbackRow?.errors as WritingFeedback['errors']) ?? primary.score.feedback.errors,
                blocks: (feedbackRow?.blocks as WritingFeedback['blocks']) ?? primary.score.feedback.blocks,
              };
              return {
                task: primary.task,
                essay: primary.essay,
                feedback: combinedFeedback,
              } satisfies HighlightSection;
            })()
          : null,
      progressPoints: progress.points,
      progressDeltas: progress.deltas,
      xp: {
        points: xpSummary.points,
        reason: xpSummary.reason,
        achievements: xpSummary.achievements,
        improvement: xpSummary.improvement,
        durationSeconds: xpSummary.effectiveDuration,
      },
      quota: quotaHit,
      referralCode,
    },
  };
};

async function loadProgress(
  supabase: ReturnType<typeof getServerClient>,
  userId: string,
  currentAttemptId: string,
) {
  const { data: rows } = await supabase
    .from('writing_responses')
    .select('exam_attempt_id, overall_band, band_scores, submitted_at, created_at')
    .eq('user_id', userId)
    .order('submitted_at', { ascending: false })
    .limit(10);

  const attempts = new Map<string, { total: number; count: number; createdAt: string } & WritingProgressPoint>();

  for (const row of rows ?? []) {
    const examId = row.exam_attempt_id as string | null;
    if (!examId) continue;
    const point =
      attempts.get(examId) ?? {
        attemptId: examId,
        createdAt: row.submitted_at ?? row.created_at ?? new Date().toISOString(),
        overallBand: 0,
        bandScores: {
          task_response: 0,
          coherence_and_cohesion: 0,
          lexical_resource: 0,
          grammatical_range: 0,
        },
        total: 0,
        count: 0,
      };
    point.total += Number(row.overall_band ?? 0);
    point.count += 1;
    const bands = (row.band_scores as Record<string, number> | null) ?? {};
    point.bandScores.task_response += Number(bands.task_response ?? 0);
    point.bandScores.coherence_and_cohesion += Number(bands.coherence_and_cohesion ?? 0);
    point.bandScores.lexical_resource += Number(bands.lexical_resource ?? 0);
    point.bandScores.grammatical_range += Number(bands.grammatical_range ?? 0);
    attempts.set(examId, point);
  }

  const rawPoints: WritingProgressPoint[] = Array.from(attempts.values()).map((point) => {
    const divisor = point.count === 0 ? 1 : point.count;
    return {
      attemptId: point.attemptId,
      createdAt: point.createdAt,
      overallBand: Number((point.total / divisor).toFixed(1)),
      bandScores: {
        task_response: Number((point.bandScores.task_response / divisor).toFixed(1)),
        coherence_and_cohesion: Number((point.bandScores.coherence_and_cohesion / divisor).toFixed(1)),
        lexical_resource: Number((point.bandScores.lexical_resource / divisor).toFixed(1)),
        grammatical_range: Number((point.bandScores.grammatical_range / divisor).toFixed(1)),
      },
    };
  });

  const trimmed = trimProgressPoints(rawPoints, 3);
  const deltas = computeCriterionDeltas(trimmed);

  if (!trimmed.find((point) => point.attemptId === currentAttemptId)) {
    const current = rawPoints.find((point) => point.attemptId === currentAttemptId);
    if (current) {
      trimmed.push(current);
    }
  }

  return { points: trimProgressPoints(trimmed, 3), deltas };
}

export default WritingResultsPage;



────────────────────────────────────────────────
[5] FILE: pages/writing/mock/[mockId]/review.tsx
────────────────────────────────────────────────
import React from 'react';
import type { GetServerSideProps } from 'next';

import { Container } from '@/components/design-system/Container';
import WritingResultCard from '@/components/writing/WritingResultCard';
import AccessibilityHints from '@/components/writing/AccessibilityHints';
import { getServerClient } from '@/lib/supabaseServer';
import type { WritingScorePayload, WritingTaskType } from '@/types/writing';

interface PageProps {
  attemptId: string;
  results: Array<{ task: WritingTaskType; essay: string; score: WritingScorePayload }>;
}

const WritingReviewPage: React.FC<PageProps> = ({ attemptId, results }) => {
  return (
    <Container className="py-12">
      <div className="mx-auto flex max-w-4xl flex-col gap-8">
        <header>
          <h1 className="text-3xl font-semibold text-foreground">Attempt review</h1>
          <p className="text-sm text-muted-foreground">Attempt ID: {attemptId}</p>
        </header>
        <AccessibilityHints />
        {results.length === 0 ? (
          <p className="text-sm text-muted-foreground">No AI feedback available yet. Submit your responses to generate scores.</p>
        ) : (
          results.map((result) => (
            <WritingResultCard key={result.task} task={result.task} result={result.score} essay={result.essay} />
          ))
        )}
      </div>
    </Container>
  );
};

export const getServerSideProps: GetServerSideProps<PageProps> = async (ctx) => {
  const supabase = getServerClient(ctx.req as any, ctx.res as any);
  const {
    data: { user },
  } = await supabase.auth.getUser();
  if (!user) {
    return {
      redirect: {
        destination: '/welcome',
        permanent: false,
      },
    };
  }

  const { mockId: attemptId } = ctx.params as { mockId: string };

  const { data: attempt, error: attemptError } = await supabase
    .from('exam_attempts')
    .select('*')
    .eq('id', attemptId)
    .maybeSingle();

  if (attemptError || !attempt || attempt.user_id !== user.id) {
    return { notFound: true };
  }

  const { data: responses } = await supabase
    .from('writing_responses')
    .select('task, answer_text, word_count, overall_band, band_scores, feedback, duration_seconds, evaluation_version')
    .eq('exam_attempt_id', attemptId);

  const results = (responses ?? [])
    .filter((row) => row.task === 'task1' || row.task === 'task2')
    .map((row) => ({
      task: row.task as WritingTaskType,
      essay: row.answer_text ?? '',
      score: {
        version: (row.evaluation_version as string) ?? 'baseline-v1',
        overallBand: row.overall_band ?? 0,
        bandScores: (row.band_scores as any) ?? {
          task_response: 0,
          coherence_and_cohesion: 0,
          lexical_resource: 0,
          grammatical_range: 0,
        },
        feedback:
          (row.feedback as any) ?? {
            summary: 'No feedback recorded yet.',
            strengths: [],
            improvements: [],
            perCriterion: {
              task_response: { band: 0, feedback: '' },
              coherence_and_cohesion: { band: 0, feedback: '' },
              lexical_resource: { band: 0, feedback: '' },
              grammatical_range: { band: 0, feedback: '' },
            },
          },
        wordCount: row.word_count ?? 0,
        durationSeconds: row.duration_seconds ?? undefined,
        tokensUsed: undefined,
      } satisfies WritingScorePayload,
    }));

  return {
    props: {
      attemptId,
      results,
    },
  };
};

export default WritingReviewPage;



────────────────────────────────────────────────
[6] FILE: pages/writing/mock/[mockId]/workspace.tsx
────────────────────────────────────────────────
import React, { useEffect, useMemo, useState } from 'react';
import type { GetServerSideProps } from 'next';
import { useRouter } from 'next/router';

import WritingExamRoom from '@/components/writing/WritingExamRoom';
import { Button } from '@/components/design-system/Button';
import { KeyboardAwareSheet } from '@/components/mobile/KeyboardAwareSheet';
import { PushOptInCard } from '@/components/mobile/PushOptInCard';
import { InstallBanner } from '@/components/mobile/InstallBanner';
import { getServerClient } from '@/lib/supabaseServer';
import type { WritingExamPrompts } from '@/types/writing';
import type { PlanId } from '@/types/pricing';
import { planAllows, writingMockLimit } from '@/lib/plan/gates';
import { withPlanPage } from '@/lib/withPlanPage';
import { useInstalledApp } from '@/hooks/useInstalledApp';
import { useInstallPrompt } from '@/hooks/useInstallPrompt';
import { clearMockAttemptId } from '@/lib/mock/state';

type PageProps = {
  attemptId: string;
  durationSeconds: number;
  prompts: WritingExamPrompts;
  initialDraft: {
    task1?: { essay: string; wordCount: number };
    task2?: { essay: string; wordCount: number };
    updatedAt?: string | null;
  } | null;
  mockId?: string | null;
};

const mapPrompt = (row: any) => {
  const topic: string | null =
    (typeof row.topic === 'string' && row.topic) ? row.topic : null;

  const promptText: string | null =
    (typeof row.prompt_text === 'string' && row.prompt_text) ? row.prompt_text
    : (row?.outline_json?.outline_summary ? String(row.outline_json.outline_summary) : null) ||
      topic || null;

  const taskType: string =
    (typeof row.task_type === 'string' && row.task_type) ? row.task_type : 'task2';

  return {
    id: row.id,
    slug: row.slug ?? row.id,
    title: topic ?? 'Untitled',
    promptText,                         // may be null — never undefined
    taskType,
    module: row.module ?? 'academic',
    difficulty: row.difficulty ?? null,
    source: row.source ?? null,
    tags: row.tags ?? null,
    estimatedMinutes: row.estimated_minutes ?? null,
    wordTarget: row.word_target ?? null,
    metadata: row.metadata ?? null,
  };
};

const WritingMockWorkspacePage: React.FC<PageProps & { __plan?: PlanId }> = ({
  __plan = 'starter',
  attemptId,
  prompts,
  durationSeconds,
  initialDraft,
  mockId = null,
}) => {
  const router = useRouter();
  const plan = __plan;
  const mockLimit = writingMockLimit(plan);
  const boosterMockLimit = writingMockLimit('booster');
  const masterMockLimit = writingMockLimit('master');
  const formatMockLimit = (limit: number) => `${limit} daily writing mock test${limit === 1 ? '' : 's'}`;
  const { isInstalled } = useInstalledApp();
  const { promptEvent, clearPrompt } = useInstallPrompt();
  const [sheetOpen, setSheetOpen] = useState(false);
  const [installDismissed, setInstallDismissed] = useState(false);
  const [pushDismissed, setPushDismissed] = useState(false);
  const [pushStatus, setPushStatus] = useState<NotificationPermission>(() => {
    if (typeof window === 'undefined' || typeof Notification === 'undefined') return 'default';
    return Notification.permission;
  });

  useEffect(() => {
    if (typeof window === 'undefined' || typeof Notification === 'undefined') return;
    setPushStatus(Notification.permission);
  }, []);

  const supportsPush = typeof window !== 'undefined' && typeof Notification !== 'undefined';

  const shouldShowInstall = useMemo(() => {
    if (!planAllows(plan, 'writing.install.prompt')) return false;
    if (isInstalled || installDismissed) return false;
    return Boolean(promptEvent);
  }, [installDismissed, isInstalled, plan, promptEvent]);

  const shouldShowPush = useMemo(() => {
    if (!planAllows(plan, 'writing.push.optin')) return false;
    if (!supportsPush) return false;
    if (pushStatus === 'granted' || pushDismissed) return false;
    return true;
  }, [plan, pushDismissed, pushStatus, supportsPush]);

  const hasEngagementPrompts = shouldShowInstall || shouldShowPush;

  useEffect(() => {
    if (!hasEngagementPrompts) setSheetOpen(false);
  }, [hasEngagementPrompts]);

  const handleInstallComplete = (outcome: 'accepted' | 'dismissed') => {
    setInstallDismissed(true);
    clearPrompt();
    if (outcome === 'accepted') setSheetOpen(false);
  };

  const handlePushGranted = () => {
    setPushStatus('granted');
    setSheetOpen(false);
  };

  const handlePushDismiss = () => setPushDismissed(true);

  return (
    <>
      {plan !== 'booster' && plan !== 'master' ? (
        <div className="mb-4 rounded-2xl border border-border/50 bg-muted/30 p-4 text-sm text-muted-foreground">
          Starter plans include {formatMockLimit(mockLimit)}. Upgrade to Booster for {formatMockLimit(boosterMockLimit)} and
          advanced analytics, or go Master for {formatMockLimit(masterMockLimit)} plus exportable reports and printable
          certificates.
        </div>
      ) : null}
      {hasEngagementPrompts ? (
        <div className="mb-4 hidden gap-4 md:grid md:grid-cols-2">
          {shouldShowInstall ? (
            <InstallBanner promptEvent={promptEvent} onComplete={handleInstallComplete} onDismiss={handleInstallComplete} />
          ) : null}
          {shouldShowPush ? <PushOptInCard onGranted={handlePushGranted} onDismiss={handlePushDismiss} /> : null}
        </div>
      ) : null}
      {hasEngagementPrompts ? (
        <div className="mb-4 flex justify-center md:hidden">
          <Button size="lg" variant="secondary" onClick={() => setSheetOpen(true)}>
            Stay connected
          </Button>
        </div>
      ) : null}
      <WritingExamRoom
        attemptId={attemptId}
        prompts={prompts}
        durationSeconds={durationSeconds}
        initialDraft={initialDraft ?? undefined}
        onSubmitSuccess={(result) => {
          if (mockId) clearMockAttemptId('writing', mockId);
          void router.push(`/writing/mock/${result.attemptId}/evaluating`);
        }}
      />
      <KeyboardAwareSheet
        open={sheetOpen && hasEngagementPrompts}
        title="Stay connected"
        description="Install the app or enable notifications so you never miss feedback."
        onClose={() => setSheetOpen(false)}
      >
        {shouldShowInstall ? (
          <InstallBanner promptEvent={promptEvent} onComplete={handleInstallComplete} onDismiss={handleInstallComplete} />
        ) : null}
        {shouldShowPush ? <PushOptInCard onGranted={handlePushGranted} onDismiss={handlePushDismiss} /> : null}
      </KeyboardAwareSheet>
    </>
  );
};

export const getServerSideProps: GetServerSideProps<PageProps> = withPlanPage('starter')(async (ctx) => {
  const supabase = getServerClient(ctx.req as any, ctx.res as any);
  const {
    data: { user },
  } = await supabase.auth.getUser();
  if (!user) {
    return {
      redirect: { destination: '/welcome', permanent: false },
    };
  }

  const params = ctx.params as { mockId: string };
  const queryAttemptId = typeof ctx.query.attemptId === 'string' ? ctx.query.attemptId : null;
  const attemptId = queryAttemptId ?? params.mockId;
  if (!attemptId) {
    return { notFound: true };
  }

  const { data: attempt, error } = await supabase
    .from('exam_attempts')
    .select('*')
    .eq('id', attemptId)
    .maybeSingle();

  if (error || !attempt || attempt.user_id !== user.id) {
    return { notFound: true };
  }

  const metadata = (attempt.metadata as any) ?? {};
  const mockIdFromMetadata = typeof metadata.mockId === 'string' ? metadata.mockId : null;
  const fallbackMockId = queryAttemptId ? params.mockId : null;
  const mockId = mockIdFromMetadata ?? fallbackMockId;
  const promptIds = metadata.promptIds ?? {};

  const { data: promptRows } = await supabase
    .from('writing_prompts')
    .select('*')
    .in('id', [promptIds.task1, promptIds.task2].filter(Boolean));

  const task1Row = promptRows?.find((row) => row.id === promptIds.task1) ?? null;
  const task2Row = promptRows?.find((row) => row.id === promptIds.task2) ?? null;

  if (!task1Row || !task2Row) {
    return { notFound: true };
  }

  const prompts: WritingExamPrompts = {
    task1: mapPrompt(task1Row),
    task2: mapPrompt(task2Row),
  };

  const { data: autosaveEvent } = await supabase
    .from('exam_events')
    .select('payload, occurred_at')
    .eq('attempt_id', attemptId)
    .eq('event_type', 'autosave')
    .order('occurred_at', { ascending: false })
    .limit(1)
    .maybeSingle();

  let initialDraft: PageProps['initialDraft'] = null;

  if (autosaveEvent?.payload) {
    const payload = autosaveEvent.payload as any;
    initialDraft = {
      updatedAt: autosaveEvent.occurred_at ?? null,
      task1: payload?.tasks?.task1
        ? { essay: payload.tasks.task1.content ?? '', wordCount: payload.tasks.task1.wordCount ?? 0 }
        : undefined,
      task2: payload?.tasks?.task2
        ? { essay: payload.tasks.task2.content ?? '', wordCount: payload.tasks.task2.wordCount ?? 0 }
        : undefined,
    };
  } else {
    const { data: responseRows } = await supabase
      .from('writing_responses')
      .select('task, answer_text, word_count')
      .eq('exam_attempt_id', attemptId);

    if (responseRows && responseRows.length > 0) {
      const draft: Record<string, { essay: string; wordCount: number }> = {};
      responseRows.forEach((row) => {
        if (row.task === 'task1' || row.task === 'task2') {
          draft[row.task] = {
            essay: row.answer_text ?? '',
            wordCount: row.word_count ?? 0,
          };
        }
      });
      if (Object.keys(draft).length > 0) {
        initialDraft = {
          task1: draft.task1,
          task2: draft.task2,
          updatedAt: attempt.updated_at ?? attempt.created_at ?? null,
        };
      }
    }
  }

  return {
    props: {
      attemptId,
      durationSeconds: attempt.duration_seconds ?? 60 * 60,
      prompts,
      initialDraft: initialDraft ?? null,
      mockId,
    },
  };
});

export default WritingMockWorkspacePage;



────────────────────────────────────────────────
[7] FILE: pages/writing/mock/[mockId]/start.tsx
────────────────────────────────────────────────
import React, { useCallback, useState } from 'react';
import type { GetServerSideProps } from 'next';
import Link from 'next/link';
import { useRouter } from 'next/router';

import { Container } from '@/components/design-system/Container';
import { Card } from '@/components/design-system/Card';
import { Button } from '@/components/design-system/Button';
import { Badge } from '@/components/design-system/Badge';
import { writingExamSummaries, type WritingExamSummary } from '@/data/writing/exam-index';
import { getServerClient } from '@/lib/supabaseServer';
import { setMockAttemptId } from '@/lib/mock/state';

interface LatestAttempt {
  attemptId: string;
  status: string;
  startedAt: string | null;
}

interface PageProps {
  mockId: string;
  summary: WritingExamSummary;
  latestAttempt: LatestAttempt | null;
}

const formatAttemptStatus = (status: string) => {
  switch (status) {
    case 'in_progress':
      return 'In progress';
    case 'submitted':
    case 'completed':
      return 'Submitted';
    default:
      return status.replace(/_/g, ' ');
  }
};

const formatTimestamp = (iso: string | null) => {
  if (!iso) return 'Not available';
  try {
    return new Intl.DateTimeFormat(undefined, {
      dateStyle: 'medium',
      timeStyle: 'short',
    }).format(new Date(iso));
  } catch {
    return iso;
  }
};

const WritingMockStartPage: React.FC<PageProps> = ({ mockId, summary, latestAttempt }) => {
  const router = useRouter();
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const handleBegin = useCallback(async () => {
    setLoading(true);
    setError(null);
    try {
      const response = await fetch('/api/mock/writing/start', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ promptId: mockId, mockId }),
      });

      if (!response.ok) {
        const payload = await response.json().catch(() => ({}));
        throw new Error(payload?.error ?? 'Failed to start mock test');
      }

      const data = (await response.json()) as {
        attempt: { id: string };
      };

      setMockAttemptId('writing', mockId, data.attempt.id);
      await router.push(`/writing/mock/${data.attempt.id}/workspace`);
    } catch (err: any) {
      setError(err?.message ?? 'Unexpected error while starting the mock test');
    } finally {
      setLoading(false);
    }
  }, [mockId, router]);

  const handleResume = useCallback(async () => {
    if (!latestAttempt) return;
    setMockAttemptId('writing', mockId, latestAttempt.attemptId);
    await router.push(`/writing/mock/${latestAttempt.attemptId}/workspace`);
  }, [latestAttempt, mockId, router]);

  return (
    <Container className="py-16">
      <div className="mx-auto flex max-w-3xl flex-col gap-6">
        <div className="space-y-3">
          <Link href="/writing/mock" className="text-sm text-primary underline">
            ← Back to writing mock library
          </Link>
          <h1 className="text-3xl font-semibold text-foreground">{summary.title}</h1>
          <p className="text-sm text-muted-foreground">{summary.description}</p>
          <div className="flex flex-wrap items-center gap-2 text-xs text-muted-foreground">
            <Badge variant="info" size="sm">{summary.task1Type}</Badge>
            <Badge variant="secondary" size="sm">Task 1: {summary.task1Focus}</Badge>
            <Badge variant="secondary" size="sm">Task 2: {summary.task2Focus}</Badge>
            <Badge variant="ghost" size="sm">{summary.durationMinutes} minutes</Badge>
            {summary.register ? <Badge variant="outline" size="sm">{summary.register}</Badge> : null}
          </div>
        </div>

        {latestAttempt ? (
          <Card className="rounded-ds-2xl border border-info/40 bg-info/10 p-5">
            <div className="flex flex-col gap-2 md:flex-row md:items-center md:justify-between">
              <div>
                <p className="text-sm font-semibold text-info">Last attempt</p>
                <p className="text-sm text-muted-foreground">
                  Status: {formatAttemptStatus(latestAttempt.status)} · Started {formatTimestamp(latestAttempt.startedAt)}
                </p>
              </div>
              {latestAttempt.status === 'in_progress' ? (
                <Button onClick={handleResume} variant="secondary" className="rounded-ds">
                  Resume attempt
                </Button>
              ) : (
                <Button
                  href={`/writing/mock/${latestAttempt.attemptId}/results`}
                  variant="secondary"
                  className="rounded-ds"
                >
                  View last results
                </Button>
              )}
            </div>
          </Card>
        ) : null}

        <Card className="card-surface rounded-ds-2xl p-6 space-y-6">
          <div className="space-y-2">
            <h2 className="text-xl font-semibold text-foreground">Before you begin</h2>
            <p className="text-sm text-muted-foreground">
              You&apos;ll complete Task 1 and Task 2 in one sitting. Autosave keeps your work safe every few seconds and focus guard pauses the timer if you leave the tab.
            </p>
          </div>

          <div className="grid gap-4 md:grid-cols-2">
            <Card className="rounded-ds-xl border border-border/50 bg-background/80 p-4 text-sm">
              <p className="font-medium text-foreground">Timing &amp; word targets</p>
              <ul className="mt-2 list-disc pl-5 text-muted-foreground">
                <li>60 minutes total (20 for Task 1, 40 for Task 2)</li>
                <li>Minimum 150 words for Task 1</li>
                <li>Minimum 250 words for Task 2</li>
              </ul>
            </Card>
            <Card className="rounded-ds-xl border border-border/50 bg-background/80 p-4 text-sm">
              <p className="font-medium text-foreground">Scoring criteria</p>
              <ul className="mt-2 list-disc pl-5 text-muted-foreground">
                <li>Task achievement / response</li>
                <li>Coherence and cohesion</li>
                <li>Lexical resource</li>
                <li>Grammatical range and accuracy</li>
              </ul>
            </Card>
          </div>

          <div className="rounded-ds-xl border border-muted/60 bg-muted/30 p-4 text-sm text-muted-foreground">
            <p>
              Stay in full-screen if possible, close extra tabs, and keep notifications off. We track focus to mirror exam conditions and let you review idle time after submitting.
            </p>
          </div>

          {error ? <p className="text-sm text-destructive">{error}</p> : null}

          <div className="flex flex-wrap items-center gap-3">
            <Button onClick={handleBegin} disabled={loading} variant="primary" className="rounded-ds">
              {loading ? 'Preparing...' : 'Begin test'}
            </Button>
            <Button href="/writing/mock" variant="ghost" className="rounded-ds">
              Cancel
            </Button>
          </div>
        </Card>
      </div>
    </Container>
  );
};

export const getServerSideProps: GetServerSideProps<PageProps> = async (ctx) => {
  const supabase = getServerClient(ctx.req as any, ctx.res as any);
  const {
    data: { user },
  } = await supabase.auth.getUser();

  if (!user) {
    return {
      redirect: {
        destination: '/welcome',
        permanent: false,
      },
    };
  }

  const { mockId } = ctx.params as { mockId: string };
  const summary = writingExamSummaries.find((paper) => paper.id === mockId);
  if (!summary) {
    return { notFound: true };
  }

  const { data: latest } = await supabase
    .from('exam_attempts')
    .select('id, status, started_at, metadata')
    .eq('user_id', user.id)
    .eq('exam_type', 'writing')
    .order('created_at', { ascending: false })
    .limit(5);

  const latestAttempt = (latest ?? []).find((row) => {
    const metadata = (row.metadata as Record<string, unknown> | null) ?? null;
    return typeof metadata?.mockId === 'string' && metadata.mockId === mockId;
  });

  return {
    props: {
      mockId,
      summary,
      latestAttempt: latestAttempt
        ? {
            attemptId: latestAttempt.id,
            status: latestAttempt.status ?? 'in_progress',
            startedAt: latestAttempt.started_at ?? null,
          }
        : null,
    },
  };
};

export default WritingMockStartPage;



────────────────────────────────────────────────
[8] FILE: pages/writing/mock/[mockId]/evaluating.tsx
────────────────────────────────────────────────
import React, { useEffect, useMemo, useState } from 'react';
import { useRouter } from 'next/router';

import { Container } from '@/components/design-system/Container';
import { Card } from '@/components/design-system/Card';
import { Button } from '@/components/design-system/Button';

interface StatusPayload {
  ok: true;
  attemptId: string;
  status: string;
  submittedAt: string | null;
  aiReady: boolean;
  responses: number;
}

const POLL_INTERVAL = 5000;

const EvaluatingPage: React.FC = () => {
  const router = useRouter();
  const { mockId } = router.query as { mockId?: string };
  const [status, setStatus] = useState<string>('submitted');
  const [responses, setResponses] = useState<number>(0);
  const [submittedAt, setSubmittedAt] = useState<string | null>(null);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    if (!mockId) return;
    let active = true;
    let timeout: NodeJS.Timeout | null = null;

    const poll = async () => {
      try {
        const res = await fetch(`/api/mock/writing/status?attemptId=${mockId}`);
        if (!res.ok) {
          const payload = await res.json().catch(() => ({}));
          throw new Error(payload?.error ?? 'Status check failed');
        }
        const data = (await res.json()) as StatusPayload;
        if (!active) return;
        setStatus(data.status);
        setResponses(data.responses);
        setSubmittedAt(data.submittedAt);
        if (data.aiReady) {
          await router.replace(`/writing/mock/${mockId}/results`);
          return;
        }
        timeout = setTimeout(poll, POLL_INTERVAL);
      } catch (err: any) {
        if (!active) return;
        setError(err?.message ?? 'Unable to check status');
        timeout = setTimeout(poll, POLL_INTERVAL * 2);
      }
    };

    void poll();

    return () => {
      active = false;
      if (timeout) clearTimeout(timeout);
    };
  }, [mockId, router]);

  const submittedLabel = useMemo(() => {
    if (!submittedAt) return 'Just now';
    try {
      return new Intl.DateTimeFormat(undefined, {
        dateStyle: 'medium',
        timeStyle: 'short',
      }).format(new Date(submittedAt));
    } catch {
      return submittedAt;
    }
  }, [submittedAt]);

  const handleViewResults = () => {
    if (!mockId) return;
    void router.push(`/writing/mock/${mockId}/results`);
  };

  const handleReturn = () => {
    void router.push('/writing/mock');
  };

  if (!mockId) {
    return null;
  }

  return (
    <Container className="py-16">
      <div className="mx-auto flex max-w-2xl flex-col gap-6 text-center">
        <div className="space-y-3">
          <h1 className="text-3xl font-semibold text-foreground">We&apos;re grading your attempt</h1>
          <p className="text-sm text-muted-foreground">
            Hang tight while our AI examiners process your essays. This usually takes less than a minute.
          </p>
        </div>

        <Card className="rounded-ds-2xl border border-border/60 bg-background/80 p-6 text-left">
          <dl className="grid gap-4 text-sm text-muted-foreground">
            <div>
              <dt className="font-medium text-foreground">Attempt ID</dt>
              <dd className="font-mono text-xs text-muted-foreground">{mockId}</dd>
            </div>
            <div>
              <dt className="font-medium text-foreground">Status</dt>
              <dd className="capitalize">{status.replace(/_/g, ' ')}</dd>
            </div>
            <div>
              <dt className="font-medium text-foreground">Responses received</dt>
              <dd>{responses}</dd>
            </div>
            <div>
              <dt className="font-medium text-foreground">Submitted</dt>
              <dd>{submittedLabel}</dd>
            </div>
          </dl>
          {error ? <p className="mt-4 text-sm text-destructive">{error}</p> : null}
        </Card>

        <div className="flex flex-wrap justify-center gap-3">
          <Button onClick={handleViewResults} variant="primary" className="rounded-ds">
            Check results
          </Button>
          <Button onClick={handleReturn} variant="ghost" className="rounded-ds">
            Back to library
          </Button>
        </div>
      </div>
    </Container>
  );
};

export default EvaluatingPage;



────────────────────────────────────────────────
[9] FILE: pages/writing/library.tsx
────────────────────────────────────────────────
import { useCallback, useEffect, useMemo, useState } from 'react';
import type { GetServerSideProps } from 'next';

import { Badge } from '@/components/design-system/Badge';
import { Button } from '@/components/design-system/Button';
import { Card } from '@/components/design-system/Card';
import { EmptyState } from '@/components/design-system/EmptyState';
import { Icon } from '@/components/design-system/Icon';
import { Input } from '@/components/design-system/Input';
import { Select } from '@/components/design-system/Select';
import { Separator } from '@/components/design-system/Separator';
import { WritingLayout } from '@/layouts/WritingLayout';
import { withPlanPage } from '@/lib/withPlanPage';
import { getServerClient } from '@/lib/supabaseServer';
import type { PlanId } from '@/types/pricing';
import { hasPlan } from '@/lib/planAccess';
import type { PromptCard } from '@/types/writing-dashboard';
import { mapPromptRow } from '@/lib/writing/mappers';
import type { WritingTaskType } from '@/lib/writing/schemas';

const difficultyLabel = (value: number) => {
  if (value <= 1) return 'Beginner';
  if (value === 2) return 'Intermediate';
  if (value === 3) return 'Upper-intermediate';
  if (value === 4) return 'Advanced';
  return 'Band 8+';
};

const difficultyOptions = [1, 2, 3, 4, 5] as const;
const countOptions = [1, 3, 5] as const;

const sortPromptCards = (items: PromptCard[]) =>
  [...items].sort((a, b) => {
    const aTime = a.createdAt ? new Date(a.createdAt).getTime() : 0;
    const bTime = b.createdAt ? new Date(b.createdAt).getTime() : 0;
    if (aTime !== bTime) {
      return bTime - aTime;
    }
    const diffDelta = a.difficulty - b.difficulty;
    if (diffDelta !== 0) {
      return diffDelta;
    }
    return a.topic.localeCompare(b.topic);
  });

const planLibraryLimit: Record<PlanId, number> = {
  free: 12,
  starter: 100,
  booster: 500,
  master: 500,
};

const planLibraryCopy: Record<PlanId, string> = {
  free: 'Preview a handful of prompts and upgrade to unlock full filters and AI tools.',
  starter: 'Seedling members access the latest 100 prompts with full filtering.',
  booster: 'Rocket unlocks 500 prompts with detailed outlines and metadata.',
  master: 'Owl includes the full 500 prompt vault and on-demand AI generation.',
};

interface LibraryPageProps {
  prompts: PromptCard[];
  total: number;
  __plan: PlanId;
}

const WritingPromptLibrary = ({ prompts, total, __plan }: LibraryPageProps) => {
  const [promptLibrary, setPromptLibrary] = useState<PromptCard[]>(() =>
    sortPromptCards(prompts.map((prompt) => ({ ...prompt, source: prompt.source ?? 'library' }))),
  );
  useEffect(() => {
    setPromptLibrary(sortPromptCards(prompts.map((prompt) => ({ ...prompt, source: prompt.source ?? 'library' }))));
  }, [prompts]);

  const [searchTerm, setSearchTerm] = useState('');
  const [taskFilter, setTaskFilter] = useState<'all' | WritingTaskType>('all');
  const [difficultyFilter, setDifficultyFilter] = useState<'all' | number>('all');
  const [libraryError, setLibraryError] = useState<string | null>(null);
  const [isRefreshing, setIsRefreshing] = useState(false);
  const [announcement, setAnnouncement] = useState('');
  const [generatorMessage, setGeneratorMessage] = useState<string | null>(null);
  const [generatorError, setGeneratorError] = useState<string | null>(null);
  const [generatorLoading, setGeneratorLoading] = useState(false);
  const [generatorOptions, setGeneratorOptions] = useState({
    count: 3 as 1 | 3 | 5,
    task: 'task2' as WritingTaskType,
    difficulty: 3,
    theme: '',
    style: '',
  });

  const maxPrompts = planLibraryLimit[__plan] ?? 100;
  const aiUnlocked = hasPlan(__plan, 'master');
  const rocketUnlocked = hasPlan(__plan, 'booster');
  const planCopy = planLibraryCopy[__plan] ?? planLibraryCopy.free;

  const filteredPrompts = useMemo(() => {
    const query = searchTerm.trim().toLowerCase();
    return promptLibrary.filter((prompt) => {
      if (taskFilter !== 'all' && prompt.taskType !== taskFilter) {
        return false;
      }
      if (difficultyFilter !== 'all' && prompt.difficulty !== difficultyFilter) {
        return false;
      }
      if (query) {
        const haystack = `${prompt.topic} ${prompt.outlineSummary ?? ''} ${(prompt.outlineItems ?? []).join(' ')}`.toLowerCase();
        if (!haystack.includes(query)) {
          return false;
        }
      }
      return true;
    });
  }, [difficultyFilter, promptLibrary, searchTerm, taskFilter]);

  const hasFiltersActive = searchTerm.trim().length > 0 || taskFilter !== 'all' || difficultyFilter !== 'all';

  const resetFilters = useCallback(() => {
    setSearchTerm('');
    setTaskFilter('all');
    setDifficultyFilter('all');
  }, []);

  const handleRefreshPrompts = useCallback(async () => {
    setIsRefreshing(true);
    setLibraryError(null);
    setAnnouncement('Refreshing prompt library…');
    try {
      const response = await fetch(`/api/writing/prompts?limit=${maxPrompts}`);
      const payload = (await response.json()) as
        | { ok: true; prompts: PromptCard[] }
        | { ok: false; error: string };

      if (!response.ok || !('ok' in payload) || !payload.ok) {
        const reason = 'error' in payload ? payload.error : 'Unable to refresh prompts';
        throw new Error(reason);
      }

      const mapped = payload.prompts.map((prompt) => ({
        ...prompt,
        source: prompt.source ?? 'library',
      }));
      setPromptLibrary(sortPromptCards(mapped));
      setAnnouncement(`Prompt library refreshed. Showing ${mapped.length} prompt${mapped.length === 1 ? '' : 's'}.`);
    } catch (err) {
      const message = err instanceof Error ? err.message : 'Unable to refresh prompts';
      setLibraryError(message);
      setAnnouncement(message);
    } finally {
      setIsRefreshing(false);
    }
  }, [maxPrompts]);

  const handleGeneratePrompts = useCallback(
    async (event?: React.FormEvent<HTMLFormElement>) => {
      event?.preventDefault();
      if (!aiUnlocked) {
        setGeneratorError('Upgrade to Owl to generate new prompts on demand.');
        return;
      }
      setGeneratorError(null);
      setGeneratorMessage(null);
      setGeneratorLoading(true);
      setAnnouncement('Generating new prompts…');
      try {
        const response = await fetch('/api/ai/writing/prompts', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            count: generatorOptions.count,
            task: generatorOptions.task,
            difficulty: generatorOptions.difficulty,
            theme: generatorOptions.theme.trim() || undefined,
            style: generatorOptions.style.trim() || undefined,
          }),
        });
        const payload = (await response.json()) as
          | { ok: true; prompts: PromptCard[] }
          | { ok: false; error: string };
        if (!response.ok || !('ok' in payload) || !payload.ok) {
          const reason = 'error' in payload ? payload.error : 'Unable to generate prompts';
          throw new Error(reason);
        }

        const generated = payload.prompts.map((prompt) => ({
          ...prompt,
          source: prompt.source ?? 'generated',
        }));

        setPromptLibrary((prev) => {
          const existingIds = new Set(prev.map((item) => item.id));
          const deduped = generated.filter((item) => !existingIds.has(item.id));
          const merged = [...deduped, ...prev];
          return sortPromptCards(merged).slice(0, maxPrompts);
        });

        const addedCount = generated.length;
        setGeneratorMessage(`Added ${addedCount} new prompt${addedCount === 1 ? '' : 's'} to your library.`);
        setAnnouncement(`Added ${addedCount} new prompt${addedCount === 1 ? '' : 's'} to your library.`);
      } catch (err) {
        const message = err instanceof Error ? err.message : 'Unable to generate prompts';
        setGeneratorError(message);
        setAnnouncement(message);
      } finally {
        setGeneratorLoading(false);
      }
    },
    [aiUnlocked, generatorOptions, maxPrompts],
  );

  return (
    <WritingLayout plan={__plan} current="library">
      <div aria-live="polite" role="status" className="sr-only">
        {announcement}
      </div>
      <Card className="card-surface flex flex-col gap-6 p-6 sm:p-8">
        <div className="flex flex-col gap-2 sm:flex-row sm:items-start sm:justify-between">
          <div className="space-y-1">
            <h2 className="text-2xl font-semibold text-foreground">Prompt library</h2>
            <p className="text-sm text-muted-foreground">
              Filter writing prompts by task and difficulty, then jump straight into the studio.
            </p>
          </div>
          <Badge variant="soft" tone="default" size="sm">
            {filteredPrompts.length} shown · cap {maxPrompts}
          </Badge>
        </div>

        <div className="flex flex-col gap-4 lg:flex-row lg:items-end lg:justify-between">
          <div className="grid gap-4 sm:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4">
            <Input
              label="Search"
              variant="subtle"
              size="sm"
              placeholder="Find a topic"
              value={searchTerm}
              onChange={(event) => setSearchTerm(event.target.value)}
              leftSlot={<Icon name="search" size={16} />}
            />
            <Select
              label="Task"
              value={taskFilter}
              onChange={(event) => setTaskFilter(event.target.value as 'all' | WritingTaskType)}
              size="sm"
              variant="subtle"
            >
              <option value="all">All tasks</option>
              <option value="task1">Task 1</option>
              <option value="task2">Task 2</option>
            </Select>
            <Select
              label="Difficulty"
              value={difficultyFilter === 'all' ? 'all' : String(difficultyFilter)}
              onChange={(event) => {
                const value = event.target.value;
                setDifficultyFilter(value === 'all' ? 'all' : Number(value));
              }}
              size="sm"
              variant="subtle"
            >
              <option value="all">All levels</option>
              {difficultyOptions.map((option) => (
                <option key={option} value={option}>
                  {difficultyLabel(option)}
                </option>
              ))}
            </Select>
          </div>
          <div className="flex flex-wrap gap-2">
            <Button type="button" variant="ghost" size="sm" onClick={resetFilters} disabled={!hasFiltersActive}>
              Clear
            </Button>
            <Button
              type="button"
              variant="outline"
              size="sm"
              onClick={handleRefreshPrompts}
              loading={isRefreshing}
              leadingIcon={<Icon name="refresh-ccw" size={16} />}
            >
              Refresh
            </Button>
          </div>
        </div>

        {libraryError && <p className="text-sm text-danger">{libraryError}</p>}

        <p className="text-xs text-muted-foreground">{planCopy}</p>

        {filteredPrompts.length > 0 ? (
          <div className="grid gap-4 sm:grid-cols-2 xl:grid-cols-3">
            {filteredPrompts.map((prompt) => (
              <Card
                key={prompt.id}
                className="flex h-full flex-col gap-5 rounded-2xl border border-border/70 bg-card/80 p-5 shadow-sm transition-all duration-200 hover:-translate-y-1 hover:border-primary/50"
              >
                <div className="flex flex-wrap items-center justify-between gap-2 text-xs uppercase tracking-[0.18em] text-muted-foreground">
                  <div className="flex items-center gap-2">
                    <Badge variant="soft" tone="info" size="sm" className="capitalize">
                      {prompt.taskType === 'task1' ? 'Task 1' : 'Task 2'}
                    </Badge>
                    {prompt.source === 'generated' && (
                      <Badge variant="soft" tone="primary" size="sm">
                        AI
                      </Badge>
                    )}
                  </div>
                  <Badge variant="soft" tone="default" size="sm">
                    {difficultyLabel(prompt.difficulty)}
                  </Badge>
                </div>
                <div className="space-y-2">
                  <h3 className="text-lg font-semibold text-foreground">{prompt.topic}</h3>
                  {prompt.outlineSummary && <p className="line-clamp-4 text-sm text-muted-foreground">{prompt.outlineSummary}</p>}
                  {rocketUnlocked && prompt.outlineItems && prompt.outlineItems.length > 0 && (
                    <ul className="space-y-1 text-xs text-muted-foreground">
                      {prompt.outlineItems.slice(0, 3).map((item, index) => (
                        <li key={`${prompt.id}-outline-${index}`} className="flex items-start gap-2">
                          <Icon name="check" size={12} className="mt-0.5 text-primary" />
                          <span>{item}</span>
                        </li>
                      ))}
                    </ul>
                  )}
                  {rocketUnlocked && prompt.createdAt && (
                    <p className="text-xs text-muted-foreground">
                      Updated {new Intl.DateTimeFormat(undefined, { dateStyle: 'medium' }).format(new Date(prompt.createdAt))}
                    </p>
                  )}
                </div>
                <div className="mt-auto flex flex-wrap gap-2">
                  <Button size="sm" variant="primary" href={`/writing/${prompt.slug}`}>
                    Start
                  </Button>
                  <Button size="sm" variant="outline" href={`/writing/${prompt.slug}?preview=1`}>
                    View
                  </Button>
                </div>
              </Card>
            ))}
          </div>
        ) : (
          <EmptyState
            title="No prompts match"
            description="Try adjusting your filters or clearing the search to browse the full library."
          />
        )}
      </Card>

      <Card className="card-surface flex flex-col gap-6 p-6 sm:p-8">
        <div className="flex flex-col gap-2 sm:flex-row sm:items-start sm:justify-between">
          <div className="space-y-1">
            <h2 className="text-2xl font-semibold text-foreground">AI prompt generator</h2>
            <p className="text-sm text-muted-foreground">
              Craft fresh prompts tailored to your focus area. New prompts appear at the top of your library instantly.
            </p>
          </div>
          <Badge variant="soft" tone={aiUnlocked ? 'success' : 'default'} size="sm">
            {aiUnlocked ? 'Owl unlocked' : 'Owl upgrade required'}
          </Badge>
        </div>
        {!aiUnlocked && (
          <div className="rounded-2xl border border-dashed border-border/60 bg-muted/40 p-4 text-sm text-muted-foreground">
            Upgrade to Owl for unlimited prompt generation with Groq/OpenAI models and curated fallbacks.
          </div>
        )}
        <form className="grid gap-4 md:grid-cols-2" onSubmit={handleGeneratePrompts}>
          <Select
            label="How many prompts?"
            value={generatorOptions.count}
            onChange={(event) => setGeneratorOptions((prev) => ({ ...prev, count: Number(event.target.value) as 1 | 3 | 5 }))}
            disabled={!aiUnlocked}
          >
            {countOptions.map((option) => (
              <option key={option} value={option}>
                {option}
              </option>
            ))}
          </Select>
          <Select
            label="Task"
            value={generatorOptions.task}
            onChange={(event) => setGeneratorOptions((prev) => ({ ...prev, task: event.target.value as WritingTaskType }))}
            disabled={!aiUnlocked}
          >
            <option value="task1">Task 1</option>
            <option value="task2">Task 2</option>
          </Select>
          <Select
            label="Difficulty"
            value={String(generatorOptions.difficulty)}
            onChange={(event) =>
              setGeneratorOptions((prev) => ({ ...prev, difficulty: Number(event.target.value) as typeof prev.difficulty }))
            }
            disabled={!aiUnlocked}
          >
            {difficultyOptions.map((option) => (
              <option key={option} value={option}>
                {difficultyLabel(option)}
              </option>
            ))}
          </Select>
          <Input
            label="Theme (optional)"
            placeholder="Sustainability, public health, …"
            value={generatorOptions.theme}
            onChange={(event) => setGeneratorOptions((prev) => ({ ...prev, theme: event.target.value }))}
            disabled={!aiUnlocked}
          />
          <Input
            label="Style hints (optional)"
            placeholder="Formal tone, emphasise comparisons, …"
            value={generatorOptions.style}
            onChange={(event) => setGeneratorOptions((prev) => ({ ...prev, style: event.target.value }))}
            className="md:col-span-2"
            disabled={!aiUnlocked}
          />
          <div className="md:col-span-2 flex flex-wrap gap-3">
            <Button type="submit" variant="primary" disabled={!aiUnlocked} loading={generatorLoading}>
              Generate prompts
            </Button>
            <Button
              type="button"
              variant="ghost"
              onClick={() =>
                setGeneratorOptions({
                  count: 3 as 1 | 3 | 5,
                  task: 'task2',
                  difficulty: 3,
                  theme: '',
                  style: '',
                })
              }
              disabled={!aiUnlocked || generatorLoading}
            >
              Reset form
            </Button>
          </div>
        </form>
        {generatorError && <p className="text-sm text-danger">{generatorError}</p>}
        {generatorMessage && <p className="text-sm text-success">{generatorMessage}</p>}
        <Separator />
        <p className="text-xs text-muted-foreground">
          Generated prompts are stored in your personal library. Refresh above to ensure filters include the latest additions.
        </p>
      </Card>
    </WritingLayout>
  );
};

export const getServerSideProps: GetServerSideProps<LibraryPageProps> = withPlanPage('starter')(async (ctx) => {
  const supabase = getServerClient(ctx.req as any, ctx.res as any);
  const {
    data: { user },
  } = await supabase.auth.getUser();

  if (!user) {
    return {
      redirect: {
        destination: '/welcome?from=/writing',
        permanent: false,
      },
    };
  }

  const { data: profileRow } = await supabase
    .from('profiles')
    .select('plan_id')
    .eq('id', user.id)
    .maybeSingle();

  const planId = (profileRow?.plan_id as PlanId | undefined) ?? 'free';
  const limit = planLibraryLimit[planId] ?? 100;

  const { data: promptRows, count } = await supabase
    .from('writing_prompts')
    .select('id, slug, topic, task_type, difficulty, outline_json, created_at', { count: 'exact' })
    .order('created_at', { ascending: false })
    .limit(limit);

  const prompts = (promptRows ?? []).map(mapPromptRow);

  return {
    props: {
      prompts,
      total: Math.min(count ?? prompts.length, limit),
    },
  } as any;
});

export default WritingPromptLibrary;



────────────────────────────────────────────────
[10] FILE: pages/writing/overview.tsx
────────────────────────────────────────────────
import React, { useCallback, useMemo, useState } from 'react';
import type { GetServerSideProps } from 'next';
import Link from 'next/link';

import { Badge } from '@/components/design-system/Badge';
import { Button } from '@/components/design-system/Button';
import { Card } from '@/components/design-system/Card';
import { EmptyState } from '@/components/design-system/EmptyState';
import { ProgressBar } from '@/components/design-system/ProgressBar';
import { Separator } from '@/components/design-system/Separator';
import { WritingLayout } from '@/layouts/WritingLayout';
import { withPlanPage } from '@/lib/withPlanPage';
import { getServerClient } from '@/lib/supabaseServer';
import type { Database } from '@/types/supabase';
import type { PlanId } from '@/types/pricing';
import type { AttemptSummary, ReadinessSummary } from '@/types/writing-dashboard';
import { mapAttemptRow } from '@/lib/writing/mappers';
import {
  buildRetakeReminder,
  ensureNotificationChannels,
  getDailyMicroPrompt,
  shouldSendMicroPromptToday,
} from '@/lib/writing/notifications';

/*
  This file centralises lightweight UI primitives that wrap your existing DS components.
  It's intentionally placed so you can later split each primitive into its own file under
  `@/components/ui` and re-export from the design-system barrel.

  If you prefer, move `ActionButton`, `OverviewCard`, `StatItem`, and `AttemptCard` to:
  - components/ui/ActionButton.tsx
  - components/ui/OverviewCard.tsx
  - components/ui/StatItem.tsx
  - components/ui/AttemptCard.tsx

  Then export them from `@/components/ui/index.ts` and update imports in this page to:
  `import { ActionButton, OverviewCard, StatItem, AttemptCard } from '@/components/ui';`
*/

/* --------------------------- Design-system wrappers (thin) --------------------------- */

// ActionButton wraps the DS Button and centralises how we render links vs buttons.
export type ActionButtonProps = React.ComponentProps<typeof Button> & { to?: string };
export const ActionButton = ({ to, children, ...rest }: ActionButtonProps) =>
  to ? (
    <Button {...(rest as any)} href={to}>
      {children}
    </Button>
  ) : (
    <Button {...(rest as any)}>{children}</Button>
  );

// OverviewCard provides a single place to change card surface for overview pages.
export const OverviewCard: React.FC<React.PropsWithChildren<{ className?: string }>> = ({ children, className = '' }) => (
  <Card className={`card-surface p-6 sm:p-8 ${className}`}>{children}</Card>
);

export const StatItem: React.FC<{
  label: string;
  value: string | number;
  meta?: string | React.ReactNode;
  progress?: number; // 0..100
}> = ({ label, value, meta, progress }) => {
  return (
    <div className="space-y-2">
      <div className="flex items-center justify-between text-xs uppercase tracking-wider text-muted-foreground">
        <span>{label}</span>
        <span className="font-semibold text-foreground">{value}</span>
      </div>
      {typeof progress === 'number' && <ProgressBar value={progress} tone="info" ariaLabel={`${label} progress`} />}
      {meta && <div className="text-xs text-muted-foreground">{meta}</div>}
    </div>
  );
};

export const AttemptCard: React.FC<{ attempt: AttemptSummary; compact?: boolean }> = ({ attempt, compact = false }) => {
  return (
    <li className={`flex flex-col gap-3 rounded-2xl border border-border/60 bg-card/70 p-5 shadow-sm transition-transform ${compact ? 'sm:flex-row sm:items-center' : ''}`}>
      <div className="flex-1">
        <p className="text-sm font-medium text-foreground">{attempt.promptTopic}</p>
        <p className="text-xs text-muted-foreground">Updated {new Intl.DateTimeFormat(undefined, { dateStyle: 'medium', timeStyle: 'short' }).format(new Date(attempt.updatedAt))}</p>
      </div>

      <div className="mt-3 flex items-center gap-3 text-sm text-muted-foreground sm:mt-0 sm:flex-col sm:items-end">
        <span>{attempt.wordCount} words</span>
        {attempt.overallBand ? <span className="font-semibold text-foreground">Band {attempt.overallBand.toFixed(1)}</span> : <span>Awaiting score</span>}
      </div>

      <div className="mt-3 flex gap-2 sm:mt-0">
        <ActionButton size="sm" variant="outline" to={`/writing/${attempt.promptSlug}?attemptId=${attempt.id}`}>
          View
        </ActionButton>
        {attempt.hasFeedback && (
          <ActionButton size="sm" variant="ghost" to={`/writing/review/${attempt.id}`}>
            Review
          </ActionButton>
        )}
      </div>
    </li>
  );
};

/* --------------------------- Page implementation (uses the wrappers above) --------------------------- */

const RETAKE_PLAN_TARGETS = { redrafts: 6, drills: 8, mocks: 2 } as const;

const progressPercentage = (value: number, target: number) => {
  if (target <= 0) return value > 0 ? 100 : 0;
  return Math.max(0, Math.min(100, Math.round((value / target) * 100)));
};

const formatDate = (value: string) => new Intl.DateTimeFormat(undefined, { dateStyle: 'medium' }).format(new Date(value));
const formatDateTime = (value: string) =>
  new Intl.DateTimeFormat(undefined, { dateStyle: 'medium', timeStyle: 'short' }).format(new Date(value));

const statusLabel: Record<AttemptSummary['status'], string> = {
  draft: 'Draft in progress',
  submitted: 'Scoring pending',
  scored: 'Scored',
};

const planLimitCopy: Record<PlanId, { label: string; description: string }> = {
  free: {
    label: 'Explorer preview',
    description: 'Upgrade to Seedling to unlock the full library with filters and drill recommendations.',
  },
  starter: {
    label: '100 prompts unlocked',
    description: 'Browse the 100 most recent prompts curated for Seedling plans with smart filters.',
  },
  booster: {
    label: '500 detailed prompts',
    description: 'Rocket members unlock 500 prompts with deeper outlines and historical metadata.',
  },
  master: {
    label: '500 prompts + AI',
    description: 'Owl unlocks the full 500 prompt vault plus on-demand AI prompt generation.',
  },
};

interface OverviewPageProps {
  readiness: ReadinessSummary | null;
  planSummary: {
    windowStart: string;
    windowEnd: string | null;
    redraftsCompleted: number;
    drillsCompleted: number;
    mocksCompleted: number;
  };
  microPrompt: {
    message: string;
    lastSentAt: string | null;
    channels: string[];
    canSendWhatsApp: boolean;
    alreadySentToday: boolean;
    retakeReminder: {
      message: string;
      completion: number;
      missing: string[];
    } | null;
  };
  stats: {
    activeDrafts: number;
    recentAttempts: AttemptSummary[];
  };
  __plan: PlanId;
}

const WritingOverview = ({ readiness, planSummary, microPrompt, stats, __plan }: OverviewPageProps) => {
  const [microPromptState, setMicroPromptState] = useState(microPrompt);
  const [microPromptLoading, setMicroPromptLoading] = useState(false);
  const [microPromptError, setMicroPromptError] = useState<string | null>(null);
  const [announcement, setAnnouncement] = useState('');

  const passReadiness = readiness?.pass ?? false;
  const missingSummary = readiness?.missing ?? [];

  const planTargets = RETAKE_PLAN_TARGETS;

  const planProgressItems = useMemo(
    () => [
      { key: 'redrafts', label: 'Redrafts completed', value: planSummary.redraftsCompleted, target: planTargets.redrafts },
      { key: 'drills', label: 'Micro-drills logged', value: planSummary.drillsCompleted, target: planTargets.drills },
      { key: 'mocks', label: 'Mock attempts reviewed', value: planSummary.mocksCompleted, target: planTargets.mocks },
    ] as const,
    [planSummary.drillsCompleted, planSummary.mocksCompleted, planSummary.redraftsCompleted, planTargets.drills, planTargets.mocks, planTargets.redrafts],
  );

  const refreshMicroPrompt = useCallback(async () => {
    try {
      const response = await fetch('/api/writing/notifications/micro-prompt');
      const payload = (await response.json()) as
        | ({ ok: true; message: string; lastSentAt: string | null; channels: string[]; canSendWhatsApp: boolean; alreadySentToday: boolean; retakeReminder: OverviewPageProps['microPrompt']['retakeReminder'] })
        | ({ ok: false; error: string });

      if (!response.ok || !payload || !('ok' in payload) || !payload.ok) {
        const reason = !payload || !('error' in payload) ? 'Unable to refresh micro prompt' : payload.error;
        throw new Error(reason);
      }

      setMicroPromptState({
        message: payload.message,
        lastSentAt: payload.lastSentAt,
        channels: payload.channels,
        canSendWhatsApp: payload.canSendWhatsApp,
        alreadySentToday: payload.alreadySentToday,
        retakeReminder: payload.retakeReminder,
      });
      setMicroPromptError(null);
      setAnnouncement('Daily micro prompt refreshed.');
    } catch (err) {
      const message = err instanceof Error ? err.message : 'Unable to refresh micro prompt';
      setMicroPromptError(message);
      setAnnouncement(message);
    }
  }, []);

  const handleSendMicroPrompt = useCallback(async () => {
    setMicroPromptLoading(true);
    setMicroPromptError(null);
    setAnnouncement('Sending micro prompt…');
    try {
      const response = await fetch('/api/writing/notifications/micro-prompt', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ channels: ['in_app', 'whatsapp'], source: 'dashboard' }),
      });
      const payload = (await response.json()) as { ok: boolean; error?: string };
      if (!response.ok || !payload.ok) {
        throw new Error(payload.error ?? 'Unable to send micro prompt');
      }
      await refreshMicroPrompt();
    } catch (err) {
      setMicroPromptError(err instanceof Error ? err.message : 'Unable to send micro prompt');
      setAnnouncement('Unable to send micro prompt');
    } finally {
      setMicroPromptLoading(false);
    }
  }, [refreshMicroPrompt]);

  const currentPlanCopy = planLimitCopy[__plan];

  return (
    <WritingLayout plan={__plan} current="overview">
      <div aria-live="polite" role="status" className="sr-only">
        {announcement}
      </div>

      {/* Primary overview hero */}
      <OverviewCard className="relative overflow-hidden border border-border/50 bg-gradient-to-br from-primary/10 via-background/80 to-background/95 shadow-xl">
        <div className="flex flex-col gap-8 lg:flex-row lg:items-start lg:justify-between">
          <div className="max-w-2xl space-y-4">
            <Badge variant="default" tone={passReadiness ? 'success' : 'info'} size="sm">
              {passReadiness ? 'Redraft unlocked' : 'Stay consistent'}
            </Badge>

            <div className="space-y-3">
              <h2 className="text-3xl font-semibold text-foreground sm:text-4xl">Your writing overview</h2>
              <p className="text-base leading-relaxed text-muted-foreground sm:text-lg">
                Track readiness, review reminders, and hop into focused drills. Use the navigation above to explore the full prompt library and analyze your history.
              </p>
            </div>

            <div className="flex flex-wrap gap-3">
              <ActionButton variant="primary" size="lg" to="/writing/library">
                Browse prompt library
              </ActionButton>
              <ActionButton variant="outline" size="lg" to="/writing/progress">
                View drafts &amp; feedback
              </ActionButton>
              <ActionButton variant="ghost" size="lg" to="/writing/drills">
                Jump into drills
              </ActionButton>
            </div>

            {!passReadiness && missingSummary.length > 0 && (
              <p className="text-sm text-muted-foreground">Unlock redrafts by completing: {missingSummary.join(', ')}</p>
            )}
          </div>

          <div className="flex w-full flex-col gap-4 rounded-2xl border border-border/60 bg-background/70 p-5 text-sm text-muted-foreground shadow-inner lg:max-w-xs">
            <div className="flex items-center justify-between">
              <span className="font-medium text-foreground">Study window</span>
              <Badge variant="default" tone="info" size="sm">
                {formatDate(planSummary.windowStart)} &ndash; {planSummary.windowEnd ? formatDate(planSummary.windowEnd) : 'TBD'}
              </Badge>
            </div>

            <Separator />

            <ul className="space-y-3">
              {planProgressItems.map((item) => (
                <li key={item.key} className="space-y-2">
                  <StatItem label={item.label} value={`${item.value}/${item.target}`} progress={progressPercentage(item.value, item.target)} />
                </li>
              ))}
            </ul>
          </div>
        </div>
      </OverviewCard>

      {/* Prompt access + Micro prompt */}
      <section className="grid gap-6 lg:grid-cols-[minmax(0,1.4fr)_minmax(0,1fr)] mt-6">
        <OverviewCard>
          <div className="flex items-start justify-between gap-3">
            <div>
              <h3 className="text-2xl font-semibold text-foreground">Prompt access</h3>
              <p className="text-sm text-muted-foreground">{currentPlanCopy.description}</p>
            </div>
            <Badge variant="default" tone="default" size="sm">
              {currentPlanCopy.label}
            </Badge>
          </div>

          <div className="mt-4 rounded-2xl border border-dashed border-border/50 bg-muted/40 p-4 text-sm text-muted-foreground">
            <p>{currentPlanCopy.description}</p>
          </div>

          <div className="mt-4 flex flex-wrap gap-3">
            <ActionButton variant="primary" to="/writing/library">Open prompt library</ActionButton>
            <ActionButton variant="ghost" to="/pricing?need=starter">Upgrade plans</ActionButton>
          </div>
        </OverviewCard>

        <OverviewCard>
          <div className="flex items-start justify-between gap-3">
            <div>
              <h3 className="text-xl font-semibold text-foreground">Daily micro prompt</h3>
              <p className="text-sm text-muted-foreground">A quick nudge to sharpen today&apos;s session.</p>
            </div>
            <Badge variant="default" tone="info" size="sm">Updated daily</Badge>
          </div>

          <div className="mt-3 rounded-2xl border border-dashed border-border/50 bg-muted/50 p-3 text-sm text-foreground">{microPromptState.message}</div>

          {microPromptState.retakeReminder && (
            <div className="mt-3 rounded-2xl border border-dashed border-border/40 bg-card/60 p-3 text-xs text-muted-foreground">{microPromptState.retakeReminder.message}</div>
          )}

          {microPromptError && <p className="mt-2 text-sm text-danger">{microPromptError}</p>}

          <div className="mt-3 flex items-center justify-between gap-3 text-xs text-muted-foreground">
            <span>{microPromptState.lastSentAt ? `Last nudged ${formatDateTime(microPromptState.lastSentAt)}` : 'Not delivered yet today'}</span>
            {!microPromptState.canSendWhatsApp && (
              <span>
                WhatsApp nudges require opt-in &mdash; manage in{' '}
                <Link href="/notifications" className="text-primary underline underline-offset-4">
                  notification settings
                </Link>
                .
              </span>
            )}
          </div>

          <div className="mt-3 flex flex-wrap items-center gap-3">
            <ActionButton size="sm" variant="primary" onClick={handleSendMicroPrompt} disabled={microPromptState.alreadySentToday && !microPromptLoading} loading={microPromptLoading}>
              {microPromptState.alreadySentToday ? 'Sent for today' : 'Send reminder now'}
            </ActionButton>
            <ActionButton size="sm" variant="ghost" onClick={refreshMicroPrompt}>Refresh tip</ActionButton>
          </div>

          {microPromptState.alreadySentToday && <p className="mt-2 text-xs text-muted-foreground">Tip already delivered today &mdash; check back tomorrow for a fresh cue.</p>}
        </OverviewCard>
      </section>

      {/* Drafts & Submissions */}
      <section className="grid gap-6 lg:grid-cols-2 mt-6">
        <OverviewCard>
          <div className="flex items-center justify-between gap-3">
            <div>
              <h3 className="text-xl font-semibold text-foreground">Active drafts</h3>
              <p className="text-sm text-muted-foreground">Pick up where you left off with autosaved work.</p>
            </div>
            <Badge variant="default" tone="default" size="sm">{stats.activeDrafts} active</Badge>
          </div>

          <div className="mt-4">
            {stats.recentAttempts.filter((a) => a.status !== 'scored').length === 0 ? (
              <EmptyState title="No active drafts" description="Start a new attempt or revisit a scored attempt to launch a redraft." />
            ) : (
              <ul className="space-y-4">
                {stats.recentAttempts.filter((a) => a.status !== 'scored').slice(0, 3).map((attempt) => (
                  <AttemptCard key={attempt.id} attempt={attempt} />
                ))}
              </ul>
            )}
          </div>

          <div className="mt-4">
            <ActionButton variant="ghost" to="/writing/progress">View full progress</ActionButton>
          </div>
        </OverviewCard>

        <OverviewCard>
          <div className="flex items-center justify-between gap-3">
            <div>
              <h3 className="text-xl font-semibold text-foreground">Recent submissions</h3>
              <p className="text-sm text-muted-foreground">See what you submitted recently and track your scores.</p>
            </div>
            <Badge variant="default" tone="default" size="sm">Last {Math.min(stats.recentAttempts.length, 6)}</Badge>
          </div>

          <div className="mt-4">
            {stats.recentAttempts.length === 0 ? (
              <EmptyState title="No attempts yet" description="Submit an essay to unlock AI feedback and trend tracking." />
            ) : (
              <ul className="space-y-4">{stats.recentAttempts.slice(0, 6).map((attempt) => <AttemptCard key={attempt.id} attempt={attempt} />)}</ul>
            )}
          </div>

          <div className="mt-4">
            <ActionButton variant="ghost" to="/writing/progress">View all attempts</ActionButton>
          </div>
        </OverviewCard>
      </section>

      {/* Resources / Boost */}
      <OverviewCard className="mt-6">
        <div className="flex flex-col gap-3 sm:flex-row sm:items-center sm:justify-between">
          <div>
            <h3 className="text-xl font-semibold text-foreground">Boost your next attempt</h3>
            <p className="text-sm text-muted-foreground">Layer drills, reviews, and mock feedback to sharpen your routine.</p>
          </div>
          <Badge variant="default" tone="info" size="sm">Curated resources</Badge>
        </div>

        <div className="mt-4 grid gap-4 md:grid-cols-3">
          <Link href="/writing/drills" className="group block rounded-2xl border border-border/60 bg-card/60 p-4 transition hover:border-primary/60 hover:bg-card">
            <div className="flex flex-col h-full">
              <span className="text-sm font-semibold text-foreground">Skill drills</span>
              <span className="mt-2 text-sm text-muted-foreground">Target coherence, task achievement, and grammar with 10-minute micro drills.</span>
              <span className="mt-auto text-sm font-medium text-primary group-hover:underline">Visit drills</span>
            </div>
          </Link>

          <Link href="/writing/reviews" className="group block rounded-2xl border border-border/60 bg-card/60 p-4 transition hover:border-primary/60 hover:bg-card">
            <div className="flex flex-col h-full">
              <span className="text-sm font-semibold text-foreground">AI reviews</span>
              <span className="mt-2 text-sm text-muted-foreground">Compare attempts, highlight improvements, and plan your next rewrite.</span>
              <span className="mt-auto text-sm font-medium text-primary group-hover:underline">Open reviews</span>
            </div>
          </Link>

          <Link href="/writing/drills?tab=mocks" className="group block rounded-2xl border border-border/60 bg-card/60 p-4 transition hover:border-primary/60 hover:bg-card">
            <div className="flex flex-col h-full">
              <span className="text-sm font-semibold text-foreground">Mock library</span>
              <span className="mt-2 text-sm text-muted-foreground">Revisit scored mocks, analyse feedback themes, and schedule your next redraft.</span>
              <span className="mt-auto text-sm font-medium text-primary group-hover:underline">Browse mocks</span>
            </div>
          </Link>
        </div>
      </OverviewCard>
    </WritingLayout>
  );
};

export const getServerSideProps: GetServerSideProps<OverviewPageProps> = withPlanPage('starter')(async (ctx) => {
  const supabase = getServerClient(ctx.req as any, ctx.res as any);
  const {
    data: { user },
  } = await supabase.auth.getUser();

  if (!user) {
    return {
      redirect: {
        destination: '/welcome?from=/writing',
        permanent: false,
      },
    };
  }

  const [{ data: attemptRows }, { data: readinessRow }] = await Promise.all([
    supabase
      .from('writing_attempts')
      .select('id, prompt_id, status, updated_at, word_count, overall_band, task_type, feedback_json, writing_prompts (slug, topic)')
      .eq('user_id', user.id)
      .order('updated_at', { ascending: false })
      .limit(12),
    supabase
      .from('writing_readiness')
      .select('status, gates_json, window_start, window_end')
      .eq('user_id', user.id)
      .order('window_start', { ascending: false })
      .limit(1)
      .maybeSingle(),
  ]);

  const attempts = (attemptRows ?? []).map((row) =>
    mapAttemptRow({
      ...row,
      prompt: row.writing_prompts as Pick<Database['public']['Tables']['writing_prompts']['Row'], 'slug' | 'topic'> | null,
    }),
  );

  const draftsActive = attempts.filter((attempt) => attempt.status !== 'scored').length;

  const gates = (readinessRow?.gates_json ?? null) as { missing?: unknown } | null;
  const readiness: ReadinessSummary | null = readinessRow
    ? {
        pass: readinessRow.status === 'pass',
        missing:
          readinessRow.status === 'pass'
            ? []
            : Array.isArray(gates?.missing)
            ? ((gates?.missing as string[]) ?? [])
            : [],
      }
    : null;

  const planWindowStart = readinessRow?.window_start ?? new Date(Date.now() - 14 * 24 * 60 * 60 * 1000).toISOString();
  const planWindowEnd = readinessRow?.window_end ?? null;

  const [{ count: planDrillsCount }, { count: redraftCount }, { count: mockCount }] = await Promise.all([
    supabase
      .from('writing_drill_events')
      .select('*', { count: 'exact', head: true })
      .eq('user_id', user.id)
      .gte('completed_at', planWindowStart),
    supabase
      .from('writing_attempts')
      .select('*', { count: 'exact', head: true })
      .eq('user_id', user.id)
      .not('version_of', 'is', null)
      .gte('created_at', planWindowStart),
    supabase
      .from('writing_attempts')
      .select('*', { count: 'exact', head: true })
      .eq('user_id', user.id)
      .is('version_of', null)
      .eq('status', 'scored')
      .gte('created_at', planWindowStart),
  ]);

  const [{ data: profileRow }, { data: lastMicroPrompt }] = await Promise.all([
    supabase
      .from('profiles')
      .select('notification_channels, whatsapp_opt_in')
      .eq('id', user.id)
      .maybeSingle(),
    supabase
      .from('writing_notification_events')
      .select('created_at, channel')
      .eq('user_id', user.id)
      .eq('type', 'micro_prompt')
      .order('created_at', { ascending: false })
      .limit(1)
      .maybeSingle(),
  ]);

  const microPromptSeed = getDailyMicroPrompt();
  const microChannels = ensureNotificationChannels(profileRow?.notification_channels ?? []);
  const microAlreadySent = !shouldSendMicroPromptToday(lastMicroPrompt?.created_at ?? null);
  const retakeReminder = buildRetakeReminder(
    {
      windowStart: planWindowStart,
      windowEnd: planWindowEnd,
      redraftsCompleted: redraftCount ?? 0,
      drillsCompleted: planDrillsCount ?? 0,
      mocksCompleted: mockCount ?? 0,
    },
    RETAKE_PLAN_TARGETS,
  );

  return {
    props: {
      readiness,
      planSummary: {
        windowStart: planWindowStart,
        windowEnd: planWindowEnd,
        redraftsCompleted: redraftCount ?? 0,
        drillsCompleted: planDrillsCount ?? 0,
        mocksCompleted: mockCount ?? 0,
      },
      microPrompt: {
        message: microPromptSeed.message,
        lastSentAt: lastMicroPrompt?.created_at ?? null,
        channels: microChannels,
        canSendWhatsApp: microChannels.includes('whatsapp') && Boolean(profileRow?.whatsapp_opt_in),
        alreadySentToday: microAlreadySent,
        retakeReminder,
      },
      stats: {
        activeDrafts: draftsActive,
        recentAttempts: attempts,
      },
      __plan: ctx.__plan ?? 'starter',
    },
  } as any;
});

export default WritingOverview;


────────────────────────────────────────────────
[11] FILE: pages/writing/review/[attemptId].tsx
────────────────────────────────────────────────
import { useMemo, useState } from 'react';
import type { GetServerSideProps } from 'next';
import Head from 'next/head';

import { Badge } from '@/components/design-system/Badge';
import { Button } from '@/components/design-system/Button';
import { Card } from '@/components/design-system/Card';
import { Container } from '@/components/design-system/Container';
import {
  CriteriaMeters,
  DiffViewer,
  DrillChecklist,
  type DrillChecklistItem,
  FeedbackPanel,
  RetakeGuard,
  type ReadinessState,
} from '@/components/writing/studio';
import { withPlanPage } from '@/lib/withPlanPage';
import { getServerClient } from '@/lib/supabaseServer';
import type { FeedbackJson, ScoresJson, WritingTaskType } from '@/lib/writing/schemas';
import type { Database } from '@/types/supabase';
import { recommendDrills } from '@/lib/writing/drills';

interface ReviewProps {
  attempt: {
    id: string;
    status: Database['public']['Enums']['writing_attempt_status'];
    promptSlug: string;
    promptTopic: string;
    taskType: WritingTaskType;
    draftText: string;
    previousDraft: string | null;
    wordCount: number;
    timeSpentMs: number;
    overallBand: number | null;
    scores: ScoresJson | null;
    feedback: FeedbackJson | null;
    metrics: {
      ttr: number | null;
      wpm: number | null;
      cohesionDensity: number | null;
      templateOveruse: number | null;
      originalityScore: number | null;
    } | null;
    submittedAt: string;
    updatedAt: string;
    readiness: ReadinessState | null;
  };
  reviews: {
    id: string;
    role: Database['public']['Enums']['writing_review_role'];
    reviewerId: string;
    scores: Record<string, number> | null;
    comments: { path: string; note: string }[] | null;
    createdAt: string;
  }[];
  recommendedDrills: {
    slug: string;
    title: string;
    criterion: string;
    takeaway: string;
  }[];
  completedDrills: string[];
}

const slugify = (value: string) =>
  value
    .toLowerCase()
    .replace(/[^a-z0-9]+/g, '-')
    .replace(/^-+|-+$/g, '');

const buildDrillChecklist = (
  attempt: ReviewProps['attempt'],
  recommended: ReviewProps['recommendedDrills'],
  completed: Set<string>,
): DrillChecklistItem[] => {
  const items: DrillChecklistItem[] = [];
  const seen = new Set<string>();

  const addItem = (id: string, label: string, hint?: string, completed = false, href?: string) => {
    if (seen.has(id)) return;
    seen.add(id);
    items.push({ id, label, hint, completed, href });
  };

  attempt.feedback?.fixes?.forEach((fix) => {
    addItem(`fix-${slugify(fix.title)}`, fix.title, fix.why);
  });

  const metrics = attempt.metrics;
  if (metrics) {
    const wpm = metrics.wpm ?? null;
    const lexicalThreshold = 0.5;
    const cohesionThreshold = 0.4;
    const templateThreshold = 0.2;
    const originalityThreshold = 0.7;
    const wpmFloor = attempt.taskType === 'task1' ? 7 : 6;

    if (wpm !== null && wpm < wpmFloor) {
      addItem('metric-wpm', 'Build timed drafting stamina', `Current words per minute: ${wpm}`);
    }
    if (metrics.ttr !== null && metrics.ttr < lexicalThreshold) {
      addItem('metric-ttr', 'Increase lexical variety', `Type-token ratio: ${metrics.ttr}`);
    }
    if (metrics.cohesionDensity !== null && metrics.cohesionDensity < cohesionThreshold) {
      addItem('metric-cohesion', 'Practise cohesive devices', `Cohesion density: ${metrics.cohesionDensity}`);
    }
    if (metrics.templateOveruse !== null && metrics.templateOveruse > templateThreshold) {
      addItem('metric-template', 'Refresh introductions & templates', `Template reuse score: ${metrics.templateOveruse}`);
    }
    if (metrics.originalityScore !== null && metrics.originalityScore < originalityThreshold) {
      addItem('metric-originality', 'Diversify examples & evidence', `Originality score: ${metrics.originalityScore}`);
    }
  }

  attempt.readiness?.missing?.forEach((item, index) => {
    addItem(`gate-${index}`, item);
  });

  recommended.forEach((drill) => {
    addItem(
      `recommended-${drill.slug}`,
      drill.title,
      drill.takeaway,
      completed.has(drill.slug.toLowerCase()),
      `/writing/drills/${drill.slug}`,
    );
  });

  return items;
};

const formatDate = (value: string) => new Intl.DateTimeFormat(undefined, { dateStyle: 'medium', timeStyle: 'short' }).format(new Date(value));

const ReviewPage = ({ attempt, reviews, recommendedDrills, completedDrills }: ReviewProps) => {
  const [redraftLoading, setRedraftLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const completedSet = useMemo(() => new Set(completedDrills.map((value) => value.toLowerCase())), [completedDrills]);
  const drillItems = useMemo(
    () => buildDrillChecklist(attempt, recommendedDrills, completedSet),
    [attempt, recommendedDrills, completedSet],
  );
  const hasCalibration = completedSet.has('calibration_passed');

  const handleRedraft = async (refreshReadiness?: () => Promise<void>) => {
    setRedraftLoading(true);
    setError(null);
    try {
      const response = await fetch('/api/writing/attempts/redraft', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ sourceAttemptId: attempt.id }),
      });
      if (!response.ok) {
        const payload = (await response.json().catch(() => ({}))) as {
          error?: string;
          details?: { missing?: string[] };
        };
        const missing = Array.isArray(payload?.details?.missing)
          ? payload.details?.missing?.join(', ')
          : null;
        const messageBase = payload?.error ?? 'Unable to create redraft';
        const message = missing ? `${messageBase}: ${missing}` : messageBase;
        if (response.status === 403 && refreshReadiness) {
          await refreshReadiness();
        }
        throw new Error(message);
      }
      const payload = (await response.json()) as { attemptId: string };
      window.location.assign(`/writing/${attempt.promptSlug}?attemptId=${payload.attemptId}`);
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Failed to create redraft');
    } finally {
      setRedraftLoading(false);
    }
  };

  return (
    <>
      <Head>
        <title>Writing review • {attempt.promptTopic}</title>
      </Head>
      <Container className="py-12">
        <div className="mx-auto flex max-w-5xl flex-col gap-8">
          <header className="flex flex-col gap-2">
            <Badge variant="soft" tone="info" size="sm" className="capitalize">
              {attempt.taskType === 'task1' ? 'Task 1' : 'Task 2'}
            </Badge>
            <h1 className="text-3xl font-semibold text-foreground">{attempt.promptTopic}</h1>
            <p className="text-sm text-muted-foreground">Submitted {formatDate(attempt.submittedAt)}</p>
            {error && <p className="text-sm text-danger">{error}</p>}
          </header>

        <section className="grid gap-4 lg:grid-cols-[2fr_1fr]">
          <div className="flex flex-col gap-4">
            <Card className="space-y-4" padding="lg">
              <div className="flex flex-wrap items-center justify-between gap-3">
                <div className="flex flex-col">
                  <span className="text-sm text-muted-foreground">Overall band</span>
                  <span className="text-3xl font-semibold text-foreground">
                    {attempt.overallBand ? attempt.overallBand.toFixed(1) : 'Pending'}
                  </span>
                </div>
                <div className="flex items-center gap-3 text-sm text-muted-foreground">
                  <span>{attempt.wordCount} words</span>
                  <span>{Math.round(attempt.timeSpentMs / 60000)} min</span>
                  <Badge variant="soft" tone={attempt.status === 'scored' ? 'success' : 'info'} size="sm">
                    {attempt.status === 'scored' ? 'Scored' : 'Scoring'}
                  </Badge>
                </div>
              </div>
            </Card>

            <CriteriaMeters scores={attempt.scores} />
            <FeedbackPanel feedback={attempt.feedback} />
            <DiffViewer previous={attempt.previousDraft} current={attempt.draftText} />

            <Card className="space-y-3" padding="lg">
              <h2 className="text-lg font-semibold text-foreground">Submitted essay</h2>
              <div className="rounded-2xl border border-border/60 bg-muted/10 p-4">
                <p className="whitespace-pre-line text-sm text-muted-foreground">{attempt.draftText}</p>
              </div>
            </Card>
          </div>

          <div className="flex flex-col gap-4">
            <Card className="space-y-3" padding="lg">
              <h2 className="text-lg font-semibold text-foreground">Metrics</h2>
              {attempt.metrics ? (
                <ul className="space-y-2 text-sm text-muted-foreground">
                  <li>Words per minute: <span className="text-foreground">{attempt.metrics.wpm ?? '—'}</span></li>
                  <li>Type-token ratio: <span className="text-foreground">{attempt.metrics.ttr ?? '—'}</span></li>
                  <li>Cohesion density: <span className="text-foreground">{attempt.metrics.cohesionDensity ?? '—'}</span></li>
                  <li>Template overuse: <span className="text-foreground">{attempt.metrics.templateOveruse ?? '—'}</span></li>
                  <li>Originality score: <span className="text-foreground">{attempt.metrics.originalityScore ?? '—'}</span></li>
                </ul>
              ) : (
                <p className="text-sm text-muted-foreground">Metrics will appear once analysis finishes.</p>
              )}
            </Card>

            <Card className="space-y-3" padding="lg">
              <h2 className="text-lg font-semibold text-foreground">Next steps</h2>
              <p className="text-sm text-muted-foreground">
                Lock in improvements by running targeted drills, then start a redraft attempt.
              </p>
              <RetakeGuard initial={attempt.readiness} onRefreshError={(err) => setError(err.message)}>
                {({ canRedraft, loading, refresh }) => (
                  <div className="space-y-3">
                    <Button
                      onClick={() => handleRedraft(refresh)}
                      loading={redraftLoading || loading}
                      disabled={attempt.status !== 'scored' || !canRedraft}
                    >
                      Start redraft
                    </Button>
                    <Button variant="outline" href="/writing">
                      Back to writing studio
                    </Button>
                  </div>
                )}
              </RetakeGuard>
            </Card>

            <DrillChecklist items={drillItems} />

          <Card className="space-y-4" padding="lg">
            <h2 className="text-lg font-semibold text-foreground">Peer &amp; teacher reviews</h2>
            {!hasCalibration && (
              <div className="rounded-2xl border border-border/60 bg-muted/20 p-3 text-sm text-muted-foreground">
                <p className="font-medium text-foreground">Calibrate with two anchored essays to unlock peer reviews.</p>
                <Button size="xs" variant="ghost" href="/writing/reviews/calibrate" className="mt-2">
                  Start calibration
                </Button>
              </div>
            )}
            {reviews.length === 0 ? (
              <p className="text-sm text-muted-foreground">No human reviews yet. Invite a peer or coach to review this attempt.</p>
            ) : (
                <ul className="space-y-3">
                  {reviews.map((review) => (
                    <li key={review.id} className="rounded-2xl border border-border/60 bg-card p-4">
                      <div className="flex items-center justify-between text-sm text-muted-foreground">
                        <span className="capitalize">{review.role}</span>
                        <span>{formatDate(review.createdAt)}</span>
                      </div>
                      {review.scores && (
                        <div className="mt-2 grid gap-2 text-sm text-muted-foreground">
                          {Object.entries(review.scores).map(([criterion, value]) => (
                            <div key={criterion} className="flex justify-between">
                              <span className="capitalize">{criterion}</span>
                              <span className="text-foreground">{value.toFixed(1)}</span>
                            </div>
                          ))}
                        </div>
                      )}
                      {review.comments && review.comments.length > 0 && (
                        <ul className="mt-3 space-y-2 text-sm text-muted-foreground">
                          {review.comments.map((comment) => (
                            <li key={`${review.id}-${comment.path}`} className="rounded-xl bg-muted/20 p-3">
                              <p className="text-xs uppercase tracking-wide text-muted-foreground">{comment.path}</p>
                              <p>{comment.note}</p>
                            </li>
                          ))}
                        </ul>
                      )}
                    </li>
                  ))}
                </ul>
              )}
            </Card>
          </div>
        </section>
        </div>
      </Container>
    </>
  );
};

export const getServerSideProps: GetServerSideProps<ReviewProps> = withPlanPage('free')(async (ctx) => {
  const { attemptId } = ctx.params as { attemptId: string };
  const supabase = getServerClient(ctx.req as any, ctx.res as any);
  const {
    data: { user },
  } = await supabase.auth.getUser();

  if (!user) {
    return {
      redirect: {
        destination: '/welcome?from=/writing',
        permanent: false,
      },
    };
  }

  const { data: attemptRow } = await supabase
    .from('writing_attempts')
    .select(
      'id, status, draft_text, word_count, time_spent_ms, overall_band, scores_json, feedback_json, created_at, updated_at, task_type, version_of, writing_prompts (slug, topic), writing_metrics (ttr, wpm, cohesion_density, template_overuse, originality_score)'
    )
    .eq('id', attemptId)
    .eq('user_id', user.id)
    .maybeSingle();

  if (!attemptRow) {
    return { notFound: true };
  }

  let previousDraft: string | null = null;
  if (attemptRow.version_of) {
    const { data: previousRow } = await supabase
      .from('writing_attempts')
      .select('draft_text')
      .eq('id', attemptRow.version_of as string)
      .eq('user_id', user.id)
      .maybeSingle();
    previousDraft = previousRow?.draft_text ?? null;
  }

  const { data: readinessRow } = await supabase
    .from('writing_readiness')
    .select('status, gates_json')
    .eq('user_id', user.id)
    .order('window_start', { ascending: false })
    .limit(1)
    .maybeSingle();

  const attempt: ReviewProps['attempt'] = {
    id: attemptRow.id,
    status: attemptRow.status,
    promptSlug: (attemptRow.writing_prompts as { slug: string } | null)?.slug ?? '',
    promptTopic: (attemptRow.writing_prompts as { topic: string } | null)?.topic ?? 'Writing prompt',
    taskType: attemptRow.task_type as WritingTaskType,
    draftText: attemptRow.draft_text ?? '',
    previousDraft,
    wordCount: attemptRow.word_count ?? 0,
    timeSpentMs: attemptRow.time_spent_ms ?? 0,
    overallBand: attemptRow.overall_band,
    scores: (attemptRow.scores_json ?? null) as ScoresJson | null,
    feedback: (attemptRow.feedback_json ?? null) as FeedbackJson | null,
    metrics: attemptRow.writing_metrics
      ? {
          ttr: (attemptRow.writing_metrics as { ttr: number | null }).ttr ?? null,
          wpm: (attemptRow.writing_metrics as { wpm: number | null }).wpm ?? null,
          cohesionDensity: (attemptRow.writing_metrics as { cohesion_density: number | null }).cohesion_density ?? null,
          templateOveruse: (attemptRow.writing_metrics as { template_overuse: number | null }).template_overuse ?? null,
          originalityScore: (attemptRow.writing_metrics as { originality_score: number | null }).originality_score ?? null,
        }
      : null,
    submittedAt: attemptRow.created_at,
    updatedAt: attemptRow.updated_at,
    readiness: readinessRow
      ? {
          pass: readinessRow.status === 'pass',
          missing:
            readinessRow.status === 'pass'
              ? []
              : (Array.isArray((readinessRow.gates_json as { missing?: string[] })?.missing)
                  ? ((readinessRow.gates_json as { missing?: string[] }).missing ?? [])
                  : []),
        }
      : null,
  };

  const { data: reviewRows } = await supabase
    .from('writing_reviews')
    .select('id, role, reviewer_id, scores_json, comments_json, created_at')
    .eq('attempt_id', attemptId)
    .order('created_at', { ascending: false });

  const reviews = (reviewRows ?? []).map((row) => ({
    id: row.id,
    role: row.role,
    reviewerId: row.reviewer_id,
    scores: (row.scores_json as Record<string, number> | null) ?? null,
    comments: Array.isArray(row.comments_json)
      ? (row.comments_json as { path: string; note: string }[])
      : null,
    createdAt: row.created_at,
  }));

  const weakCriteria: string[] = [];
  if (attempt.scores) {
    (['TR', 'CC', 'LR', 'GRA'] as const).forEach((criterion) => {
      const value = attempt.scores?.[criterion];
      if (typeof value === 'number' && value < 7) {
        weakCriteria.push(criterion);
      }
    });
  }

  const tagHints = new Set<string>();
  attempt.feedback?.fixes?.forEach((fix) => {
    tagHints.add(fix.title.toLowerCase());
  });
  if (attempt.taskType) {
    tagHints.add(attempt.taskType);
  }

  const recommended = recommendDrills({ weakCriteria, tags: Array.from(tagHints), limit: 4 }).map((drill) => ({
    slug: drill.slug,
    title: drill.title,
    criterion: drill.criterion,
    takeaway: drill.takeaway,
  }));

  const since = new Date(Date.now() - 14 * 24 * 60 * 60 * 1000).toISOString();
  const { data: drillEvents } = await supabase
    .from('writing_drill_events')
    .select('tags')
    .eq('user_id', user.id)
    .gte('completed_at', since);

  const completedDrills = new Set<string>();
  (drillEvents ?? []).forEach((event) => {
    (event.tags ?? []).forEach((tag) => {
      completedDrills.add(String(tag).toLowerCase());
    });
  });

  return {
    props: {
      attempt,
      reviews,
      recommendedDrills: recommended,
      completedDrills: Array.from(completedDrills),
    },
  };
});

export default ReviewPage;



────────────────────────────────────────────────
[12] FILE: pages/writing/[slug].tsx
────────────────────────────────────────────────
import { useCallback, useEffect, useRef, useState } from 'react';
import dynamic from 'next/dynamic';
import type { GetServerSideProps } from 'next';
import Head from 'next/head';
import { useRouter } from 'next/router';

import { Alert } from '@/components/design-system/Alert';
import { Badge } from '@/components/design-system/Badge';
import { Button } from '@/components/design-system/Button';
import { Card } from '@/components/design-system/Card';
import { Container } from '@/components/design-system/Container';
import { WritingEditor } from '@/components/writing/studio';
import type { EvidenceSuggestion, HedgingSuggestion } from '@/lib/writing/crossModule';
import {
  trackClientAttemptSaved,
  trackClientAttemptStarted,
  trackClientAttemptSubmitted,
  trackClientEvidenceViewed,
  trackClientHandwritingUploaded,
  trackClientHedgingViewed,
} from '@/lib/analytics/writing-events';
import { enqueueOfflineDraft, flushOfflineDrafts } from '@/lib/writing/offlineQueue';
import { withPlanPage } from '@/lib/withPlanPage';
import { getServerClient } from '@/lib/supabaseServer';
import { countWords } from '@/lib/storage/drafts';
import { splitParagraphs, type LiveSuggestion } from '@/lib/writing/languageTools';
import type { SaveDraftBody, WritingTaskType } from '@/lib/writing/schemas';
import type { Database } from '@/types/supabase';

const LanguageToolsDock = dynamic(
  () => import('@/components/writing/studio/LanguageToolsDock').then((mod) => mod.LanguageToolsDock),
  { ssr: false, loading: () => <div className="h-24 rounded-2xl bg-muted/40" /> },
);

interface PromptPageProps {
  prompt: {
    id: string;
    slug: string;
    topic: string;
    taskType: WritingTaskType;
    difficulty: number;
    band9Sample: string | null;
    outline: string[];
    createdAt: string;
  };
  attempt: {
    id: string;
    draftText: string;
    wordCount: number;
    timeSpentMs: number;
    status: Database['public']['Enums']['writing_attempt_status'];
    updatedAt: string;
  } | null;
}

const WritingPromptPage = ({ prompt, attempt }: PromptPageProps) => {
  const router = useRouter();
  const [attemptId, setAttemptId] = useState<string | null>(attempt?.id ?? null);
  const [draftText, setDraftText] = useState<string>(attempt?.draftText ?? '');
  const [wordCount, setWordCount] = useState<number>(attempt?.wordCount ?? 0);
  const [timeSpentMs, setTimeSpentMs] = useState<number>(attempt?.timeSpentMs ?? 0);
  const [status, setStatus] = useState<Database['public']['Enums']['writing_attempt_status']>(attempt?.status ?? 'draft');
  const [saveState, setSaveState] = useState<'idle' | 'saving' | 'saved' | 'error'>('idle');
  const [submitState, setSubmitState] = useState<'idle' | 'submitting'>('idle');
  const [error, setError] = useState<string | null>(null);
  const [offlineQueued, setOfflineQueued] = useState(false);
  const [copyAlert, setCopyAlert] = useState<string | null>(null);
  const [bulkPasteDetected, setBulkPasteDetected] = useState(false);
  const [evidence, setEvidence] = useState<EvidenceSuggestion[]>([]);
  const [evidenceLoading, setEvidenceLoading] = useState(false);
  const [hedging, setHedging] = useState<HedgingSuggestion[]>([]);
  const lastSavedDraft = useRef<string>(attempt?.draftText ?? '');
  const isMounted = useRef<boolean>(false);
  const isTask2 = prompt.taskType === 'task2';

  const sendDraft = useCallback(
    async (payload: SaveDraftBody) => {
      const response = await fetch('/api/writing/attempts/save-draft', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(payload),
      });
      if (!response.ok) {
        const details = await response.json().catch(() => ({}));
        throw new Error((details as { error?: string })?.error ?? 'Failed to save draft');
      }
      trackClientAttemptSaved({ attemptId: payload.attemptId, wordCount: payload.wordCount, bulkPaste: bulkPasteDetected });
      setBulkPasteDetected(false);
    },
    [bulkPasteDetected],
  );

  const syncOfflineDrafts = useCallback(async () => {
    await flushOfflineDrafts(async (payload) => {
      try {
        await sendDraft(payload);
        if (payload.attemptId === attemptId) {
          lastSavedDraft.current = payload.draftText;
          if (isMounted.current) {
            setSaveState('saved');
            setError(null);
            setOfflineQueued(false);
          }
        }
        return true;
      } catch {
        return false;
      }
    });
  }, [attemptId, sendDraft]);

  useEffect(() => {
    isMounted.current = true;
    return () => {
      isMounted.current = false;
    };
  }, []);

  const loadEvidence = useCallback(async () => {
    if (!attemptId || !isTask2) return;
    setEvidenceLoading(true);
    try {
      const response = await fetch('/api/writing/cross/evidence', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ promptId: prompt.id, topic: prompt.topic }),
      });
      if (!response.ok) {
        return;
      }
      const payload = (await response.json()) as { evidence: EvidenceSuggestion[] };
      setEvidence(payload.evidence ?? []);
      trackClientEvidenceViewed(payload.evidence?.length ?? 0);
    } catch (_error) {
      setError('Unable to load evidence suggestions right now.');
    } finally {
      setEvidenceLoading(false);
    }
  }, [attemptId, isTask2, prompt.id, prompt.topic]);

  useEffect(() => {
    if (!attemptId || !isTask2) return;
    void loadEvidence();
  }, [attemptId, isTask2, loadEvidence]);

  useEffect(() => {
    let active = true;
    const fetchHedging = async () => {
      try {
        const response = await fetch('/api/writing/cross/hedging');
        if (!response.ok) return;
        const payload = (await response.json()) as { suggestions: HedgingSuggestion[] };
        if (active) {
          setHedging(payload.suggestions ?? []);
          trackClientHedgingViewed(payload.suggestions?.length ?? 0);
        }
      } catch (_error) {
        if (active) {
          setHedging([]);
        }
      }
    };
    void fetchHedging();
    return () => {
      active = false;
    };
  }, []);

  const hasUnsavedChanges = draftText !== lastSavedDraft.current;

  useEffect(() => {
    if (attemptId || attempt) return;
    let cancelled = false;
    const startAttempt = async () => {
      try {
        const response = await fetch('/api/writing/attempts/start', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ promptId: prompt.id, taskType: prompt.taskType }),
        });
        if (!response.ok) {
          const payload = await response.json().catch(() => ({}));
          throw new Error((payload as { error?: string })?.error ?? 'Unable to start attempt');
        }
        const payload = (await response.json()) as { attemptId: string };
        if (!cancelled) {
          setAttemptId(payload.attemptId);
          trackClientAttemptStarted({ attemptId: payload.attemptId, promptId: prompt.id, taskType: prompt.taskType });
          void router.replace(
            {
              pathname: `/writing/${prompt.slug}`,
              query: { attemptId: payload.attemptId },
            },
            undefined,
            { shallow: true },
          );
        }
      } catch (err) {
        if (!cancelled) {
          setError(err instanceof Error ? err.message : 'Failed to start attempt');
        }
      }
    };
    void startAttempt();
    return () => {
      cancelled = true;
    };
  }, [attempt, attemptId, prompt.id, prompt.slug, prompt.taskType, router]);

  useEffect(() => {
    if (submitState === 'submitting') return;
    const interval = window.setInterval(() => {
      setTimeSpentMs((prev) => prev + 1000);
    }, 1000);
    return () => window.clearInterval(interval);
  }, [submitState]);

  useEffect(() => {
    if (!attemptId || !hasUnsavedChanges) return;
    setSaveState('saving');
    const payload: SaveDraftBody = { attemptId, draftText, wordCount, timeSpentMs };
    const timeout = window.setTimeout(async () => {
      try {
        await sendDraft(payload);
        lastSavedDraft.current = payload.draftText;
        if (isMounted.current) {
          setSaveState('saved');
          setError(null);
          setOfflineQueued(false);
        }
      } catch (err) {
        if (typeof navigator !== 'undefined' && navigator.onLine === false) {
          enqueueOfflineDraft(payload);
          setOfflineQueued(true);
          if (isMounted.current) {
            setSaveState('saved');
            setError('Offline — your draft will sync when you reconnect.');
          }
        } else if (isMounted.current) {
          setSaveState('error');
          setError(err instanceof Error ? err.message : 'Unable to save draft');
        }
      }
    }, 6000);

    return () => window.clearTimeout(timeout);
  }, [attemptId, draftText, hasUnsavedChanges, sendDraft, timeSpentMs, wordCount]);

  useEffect(() => {
    if (!attemptId) return;
    void syncOfflineDrafts();
  }, [attemptId, syncOfflineDrafts]);

  useEffect(() => {
    const handler = () => {
      void syncOfflineDrafts();
    };
    window.addEventListener('online', handler);
    return () => window.removeEventListener('online', handler);
  }, [syncOfflineDrafts]);

  useEffect(() => {
    if (!hasUnsavedChanges) return;
    const handler = (event: BeforeUnloadEvent) => {
      event.preventDefault();
      event.returnValue = '';
      return '';
    };
    window.addEventListener('beforeunload', handler);
    return () => window.removeEventListener('beforeunload', handler);
  }, [hasUnsavedChanges]);

  const handleDraftChange = useCallback(
    (value: string) => {
      setDraftText(value);
      setWordCount(countWords(value));
      setSaveState('saving');
    },
    [],
  );

  const handleApplySuggestion = useCallback(
    (suggestion: LiveSuggestion) => {
      setDraftText((current) => {
        const paragraphs = splitParagraphs(current);
        if (suggestion.paragraphIndex >= paragraphs.length) return current;
        const index = suggestion.paragraphIndex;
        let paragraph = paragraphs[index];
        if (suggestion.replacement && suggestion.original) {
          const escaped = suggestion.original.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
          const regex = new RegExp(escaped);
          paragraph = paragraph.replace(regex, suggestion.replacement ?? suggestion.original);
        } else if (suggestion.example) {
          paragraph = `${suggestion.example} ${paragraph}`.trim();
        } else {
          paragraph = `${suggestion.suggestion} ${paragraph}`.trim();
        }
        const updated = [...paragraphs];
        updated[index] = paragraph;
        const nextText = updated.join('\n\n');
        setWordCount(countWords(nextText));
        setSaveState('saving');
        return nextText;
      });
    },
    [],
  );

  const handleInsertParaphrase = useCallback(
    (sentence: string) => {
      const next = `${draftText.trim()} ${sentence}`.trim();
      handleDraftChange(next);
    },
    [draftText, handleDraftChange],
  );

  const handleEvidenceInsert = useCallback(
    (evidenceText: string) => {
      const trimmed = evidenceText.trim();
      if (!trimmed) return;
      setDraftText((current) => {
        const next = current.trim().length > 0 ? `${current.trim()}\n\n${trimmed}` : trimmed;
        setWordCount(countWords(next));
        setSaveState('saving');
        return next;
      });
    },
    [],
  );

  const handleHandwritingInsert = useCallback(
    ({ text: handwritingText, legibility }: { text: string; legibility: number }) => {
      const trimmed = handwritingText.trim();
      if (!trimmed) return;
      setDraftText((current) => {
        const next = current.trim().length > 0 ? `${current.trim()}\n\n${trimmed}` : trimmed;
        setWordCount(countWords(next));
        setSaveState('saving');
        return next;
      });
      trackClientHandwritingUploaded(legibility);
    },
    [],
  );

  const handleBulkPaste = useCallback(() => {
    setCopyAlert('Large paste detected. Summarise or paraphrase to keep originality high.');
    setBulkPasteDetected(true);
  }, []);

  const handleSubmit = async () => {
    if (!attemptId) return;
    if (typeof navigator !== 'undefined' && navigator.onLine === false) {
      setError('Reconnect to submit for scoring. Your latest draft is stored offline.');
      return;
    }

    setSubmitState('submitting');
    setError(null);
    try {
      await syncOfflineDrafts();

      if (hasUnsavedChanges) {
        const payload: SaveDraftBody = { attemptId, draftText, wordCount, timeSpentMs };
        await sendDraft(payload);
        lastSavedDraft.current = payload.draftText;
        setOfflineQueued(false);
      }

      const response = await fetch('/api/writing/attempts/submit', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ attemptId }),
      });
      if (!response.ok) {
        const payload = await response.json().catch(() => ({}));
        throw new Error((payload as { error?: string })?.error ?? 'Unable to submit');
      }
      trackClientAttemptSubmitted({ attemptId });
      setStatus('submitted');
      window.setTimeout(() => {
        void router.push(`/writing/review/${attemptId}`);
      }, 800);
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Failed to submit attempt');
    } finally {
      if (isMounted.current) {
        setSubmitState('idle');
      }
    }
  };

  const outline = prompt.outline;
  const helperText = offlineQueued
    ? 'Offline — pending saves will sync when you reconnect.'
    : 'Autosave every ~6s while typing.';

  return (
    <>
      <Head>
        <title>{prompt.topic} • Writing studio</title>
      </Head>
      <Container className="py-10">
        <div className="mx-auto flex max-w-5xl flex-col gap-8">
          <div className="flex flex-col gap-3">
            <div className="flex flex-wrap items-center gap-3">
              <Badge variant="soft" tone="info" size="sm" className="capitalize">
                {prompt.taskType === 'task1' ? 'Task 1' : 'Task 2'}
              </Badge>
              <Badge variant="soft" tone="default" size="sm">
                Difficulty {prompt.difficulty}
              </Badge>
            </div>
            <h1 className="text-3xl font-semibold text-foreground md:text-4xl">{prompt.topic}</h1>
            <p className="text-sm text-muted-foreground">
              Autosave keeps your draft safe. Submit when you are ready for scoring and feedback.
            </p>
            {error && <p className="text-sm text-danger">{error}</p>}
            {copyAlert && (
              <Alert variant="warning" className="mt-2">
                <div className="flex flex-wrap items-center justify-between gap-3">
                  <span>{copyAlert}</span>
                  <Button size="xs" variant="ghost" onClick={() => setCopyAlert(null)}>
                    Dismiss
                  </Button>
                </div>
              </Alert>
            )}
          </div>

          <WritingEditor
            value={draftText}
            onChange={handleDraftChange}
            wordCount={wordCount}
            elapsedMs={timeSpentMs}
            taskType={prompt.taskType}
            saveState={saveState}
            status={status}
            submitting={submitState === 'submitting'}
            disableSubmit={!attemptId || draftText.trim().length === 0 || status === 'submitted'}
            onSubmit={handleSubmit}
            helper={helperText}
            onBulkPaste={handleBulkPaste}
          />

          <LanguageToolsDock
            text={draftText}
            timeSpentMs={timeSpentMs}
            onApplySuggestion={handleApplySuggestion}
            onInsertParaphrase={handleInsertParaphrase}
            evidence={isTask2 ? evidence : undefined}
            onInsertEvidence={isTask2 ? handleEvidenceInsert : undefined}
            onRefreshEvidence={isTask2 ? loadEvidence : undefined}
            evidenceLoading={evidenceLoading}
            hedging={hedging}
            attemptId={attemptId}
            onInsertHandwriting={handleHandwritingInsert}
            disabled={status !== 'draft'}
          />

          <div className="grid gap-6 lg:grid-cols-[2fr_1fr]">
            <Card className="card-surface space-y-4 p-6">
              <h2 className="text-xl font-semibold text-foreground">Prompt outline</h2>
              {outline.length > 0 ? (
                <ol className="list-decimal space-y-3 pl-6 text-sm text-muted-foreground">
                  {outline.map((item) => (
                    <li key={item}>{item}</li>
                  ))}
                </ol>
              ) : (
                <p className="text-sm text-muted-foreground">No outline hints for this prompt yet.</p>
              )}
            </Card>
            {prompt.band9Sample && (
              <Card className="card-surface space-y-3 p-6">
                <h2 className="text-xl font-semibold text-foreground">Band 9 sample excerpt</h2>
                <p className="text-sm text-muted-foreground whitespace-pre-line">{prompt.band9Sample}</p>
              </Card>
            )}
          </div>
        </div>
      </Container>
    </>
  );
};

export const getServerSideProps: GetServerSideProps<PromptPageProps> = withPlanPage('free')(async (ctx) => {
  const { slug } = ctx.params as { slug: string };
  const attemptId = typeof ctx.query.attemptId === 'string' ? ctx.query.attemptId : null;

  const supabase = getServerClient(ctx.req as any, ctx.res as any);
  const {
    data: { user },
  } = await supabase.auth.getUser();

  if (!user) {
    return {
      redirect: {
        destination: '/welcome?from=/writing',
        permanent: false,
      },
    };
  }

  const { data: promptRow, error: promptError } = await supabase
    .from('writing_prompts')
    .select('id, slug, topic, task_type, difficulty, band9_sample, outline_json, created_at')
    .eq('slug', slug)
    .maybeSingle();

  if (promptError || !promptRow) {
    return {
      notFound: true,
    };
  }

  let attempt: PromptPageProps['attempt'] = null;
  if (attemptId) {
    const { data: attemptRow } = await supabase
      .from('writing_attempts')
      .select('id, draft_text, word_count, time_spent_ms, status, updated_at')
      .eq('id', attemptId)
      .eq('user_id', user.id)
      .maybeSingle();
    if (attemptRow) {
      attempt = {
        id: attemptRow.id,
        draftText: attemptRow.draft_text ?? '',
        wordCount: attemptRow.word_count ?? 0,
        timeSpentMs: attemptRow.time_spent_ms ?? 0,
        status: attemptRow.status,
        updatedAt: attemptRow.updated_at,
      };
    }
  }

  const rawOutline = promptRow.outline_json;
  let outlineValue: string[] = [];
  if (Array.isArray(rawOutline)) {
    outlineValue = rawOutline.map((item) => String(item)).filter((item) => item.length > 0);
  } else if (rawOutline && typeof rawOutline === 'object') {
    const maybeItems = (rawOutline as { items?: unknown; steps?: unknown }).items;
    const maybeSteps = (rawOutline as { steps?: unknown }).steps;
    if (Array.isArray(maybeItems)) {
      outlineValue = maybeItems.map((item) => String(item)).filter((item) => item.length > 0);
    } else if (Array.isArray(maybeSteps)) {
      outlineValue = maybeSteps.map((item) => String(item)).filter((item) => item.length > 0);
    } else {
      outlineValue = Object.values(rawOutline as Record<string, unknown>)
        .map((item) => String(item))
        .filter((item) => item.length > 0);
    }
  }

  return {
    props: {
      prompt: {
        id: promptRow.id,
        slug: promptRow.slug,
        topic: promptRow.topic,
        taskType: promptRow.task_type as WritingTaskType,
        difficulty: promptRow.difficulty ?? 2,
        band9Sample: promptRow.band9_sample ?? null,
        outline: outlineValue.filter(Boolean),
        createdAt: promptRow.created_at,
      },
      attempt,
    },
  };
});

export default WritingPromptPage;



────────────────────────────────────────────────
[13] FILE: pages/writing/drills/index.tsx
────────────────────────────────────────────────
import { useMemo, useState } from 'react';
import type { GetServerSideProps } from 'next';

import { Badge } from '@/components/design-system/Badge';
import { Button } from '@/components/design-system/Button';
import { Card } from '@/components/design-system/Card';
import { Container } from '@/components/design-system/Container';
import { EmptyState } from '@/components/design-system/EmptyState';
import { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/design-system/Tabs';
import { allDrills, type Drill } from '@/lib/writing/drills';
import { getServerClient } from '@/lib/supabaseServer';
import { withPlanPage } from '@/lib/withPlanPage';

interface PageProps {
  drills: Drill[];
  completed: string[];
}

const criteriaLabels: Record<Drill['criterion'], string> = {
  TR: 'Task Response',
  CC: 'Coherence & Cohesion',
  LR: 'Lexical Resource',
  GRA: 'Grammar',
};

const DrillIndexPage = ({ drills, completed }: PageProps) => {
  const [activeCriterion, setActiveCriterion] = useState<Drill['criterion'] | 'all'>('all');
  const completedSet = useMemo(() => new Set(completed.map((value) => value.toLowerCase())), [completed]);

  const filteredDrills = useMemo(() => {
    if (activeCriterion === 'all') return drills;
    return drills.filter((drill) => drill.criterion === activeCriterion);
  }, [activeCriterion, drills]);

  const groupedByCriterion = useMemo(() => {
    return drills.reduce<Record<string, { total: number; done: number }>>((acc, drill) => {
      const key = drill.criterion;
      acc[key] = acc[key] ?? { total: 0, done: 0 };
      acc[key].total += 1;
      if (completedSet.has(drill.slug)) {
        acc[key].done += 1;
      }
      return acc;
    }, {});
  }, [drills, completedSet]);

  return (
    <Container className="py-12">
      <div className="mx-auto flex max-w-5xl flex-col gap-8">
        <header className="space-y-2">
          <h1 className="text-3xl font-semibold text-foreground md:text-4xl">Writing micro-drills</h1>
          <p className="text-sm text-muted-foreground">
            Target specific weaknesses with five-minute reps. Finish the required drills in your readiness gate to unlock the next redraft.
          </p>
        </header>

        <div className="grid gap-4 md:grid-cols-4">
          {(['TR', 'CC', 'LR', 'GRA'] as Drill['criterion'][]).map((criterion) => {
            const stat = groupedByCriterion[criterion] ?? { total: 0, done: 0 };
            return (
              <Card key={criterion} className="space-y-2 p-4">
                <h2 className="text-sm font-semibold text-foreground">{criteriaLabels[criterion]}</h2>
                <p className="text-2xl font-semibold text-foreground">{stat.done}/{stat.total}</p>
                <p className="text-xs text-muted-foreground">Completed in the last 14 days</p>
              </Card>
            );
          })}
        </div>

        <Tabs value={activeCriterion} onValueChange={(value) => setActiveCriterion(value as Drill['criterion'] | 'all')}>
          <TabsList>
            <TabsTrigger value="all">All drills</TabsTrigger>
            {(['TR', 'CC', 'LR', 'GRA'] as Drill['criterion'][]).map((criterion) => (
              <TabsTrigger key={criterion} value={criterion}>
                {criteriaLabels[criterion]}
              </TabsTrigger>
            ))}
          </TabsList>
          <TabsContent value={activeCriterion} className="mt-4">
            {filteredDrills.length === 0 ? (
              <EmptyState title="No drills found" description="All caught up! Pick a different criterion to keep sharpening your skills." />
            ) : (
              <div className="grid gap-4">
                {filteredDrills.map((drill) => {
                  const isComplete = completedSet.has(drill.slug);
                  return (
                    <Card key={drill.id} className="flex flex-col gap-3 rounded-2xl border border-border/60 bg-card p-5">
                      <div className="flex flex-wrap items-center justify-between gap-2">
                        <div className="space-y-1">
                          <h3 className="text-lg font-semibold text-foreground">{drill.title}</h3>
                          <p className="text-sm text-muted-foreground">{drill.prompt}</p>
                        </div>
                        <div className="flex flex-col items-end gap-2 text-xs text-muted-foreground">
                          <Badge variant="soft" tone="info" size="sm">
                            {criteriaLabels[drill.criterion]}
                          </Badge>
                          <span>{drill.durationMinutes} min</span>
                          {isComplete && <Badge variant="soft" tone="success" size="sm">Completed</Badge>}
                        </div>
                      </div>
                      <div className="flex flex-wrap gap-2 text-xs text-muted-foreground">
                        {drill.tags.map((tag) => (
                          <Badge key={tag} variant="soft" tone="default" size="sm">
                            #{tag}
                          </Badge>
                        ))}
                      </div>
                      <div className="flex flex-wrap gap-2">
                        <Button size="sm" href={`/writing/drills/${drill.slug}`}>
                          Start drill
                        </Button>
                      </div>
                    </Card>
                  );
                })}
              </div>
            )}
          </TabsContent>
        </Tabs>
      </div>
    </Container>
  );
};

export const getServerSideProps: GetServerSideProps<PageProps> = withPlanPage('free')(async (ctx) => {
  const supabase = getServerClient(ctx.req as any, ctx.res as any);
  const {
    data: { user },
  } = await supabase.auth.getUser();

  if (!user) {
    return {
      redirect: {
        destination: '/welcome?from=/writing',
        permanent: false,
      },
    };
  }

  const since = new Date(Date.now() - 14 * 24 * 60 * 60 * 1000).toISOString();
  const { data: events } = await supabase
    .from('writing_drill_events')
    .select('tags')
    .eq('user_id', user.id)
    .gte('completed_at', since);

  const completedSlugs = new Set<string>();
  (events ?? []).forEach((event) => {
    (event.tags ?? []).forEach((tag) => {
      if (tag.toLowerCase().startsWith('drill-') || tag.toLowerCase().includes('task') || tag.toLowerCase().includes('coherence')) {
        completedSlugs.add(tag.toLowerCase());
      }
    });
  });

  const drills = allDrills();

  return {
    props: {
      drills,
      completed: Array.from(completedSlugs),
    },
  };
});

export default DrillIndexPage;



────────────────────────────────────────────────
[14] FILE: pages/writing/drills/[slug].tsx
────────────────────────────────────────────────
import { useState } from 'react';
import type { GetServerSideProps } from 'next';
import Head from 'next/head';

import { Badge } from '@/components/design-system/Badge';
import { Button } from '@/components/design-system/Button';
import { Card } from '@/components/design-system/Card';
import { Container } from '@/components/design-system/Container';
import { Checkbox } from '@/components/design-system/Checkbox';
import { Input } from '@/components/design-system/Input';
import { TextareaAutosize } from '@/components/design-system/TextareaAutosize';
import type { Drill, DrillCheck } from '@/lib/writing/drills';
import { findDrillBySlug } from '@/lib/writing/drills';
import { getServerClient } from '@/lib/supabaseServer';
import { withPlanPage } from '@/lib/withPlanPage';

interface DrillPageProps {
  drill: Drill;
  completed: boolean;
}

const criteriaLabels: Record<Drill['criterion'], string> = {
  TR: 'Task Response',
  CC: 'Coherence & Cohesion',
  LR: 'Lexical Resource',
  GRA: 'Grammar',
};

const renderCheck = (check: DrillCheck, showAnswers: boolean) => {
  switch (check.type) {
    case 'rewrite':
      return (
        <div className="space-y-2">
          <p className="text-sm text-muted-foreground">Rewrite: <span className="text-foreground">{check.input}</span></p>
          {showAnswers && (
            <p className="text-sm text-success">Model answer: {check.target}</p>
          )}
        </div>
      );
    case 'compare':
      return (
        <div className="space-y-2">
          <p className="text-sm text-muted-foreground">Prompt: {check.question}</p>
          {showAnswers && (
            <div className="grid gap-1 text-sm text-muted-foreground">
              <p>✅ Strong: <span className="text-success">{check.strong}</span></p>
              <p>⚠️ Weak: <span className="text-danger">{check.weak}</span></p>
            </div>
          )}
        </div>
      );
    case 'fill':
      return (
        <div className="space-y-2">
          <p className="text-sm text-muted-foreground">{check.question}</p>
          {showAnswers ? (
            <p className="text-sm text-success">Answer: {check.answer}</p>
          ) : (
            <Input placeholder="Type your answer" />
          )}
        </div>
      );
    case 'timer':
      return (
        <div className="space-y-2">
          <p className="text-sm text-muted-foreground">Set a timer for {Math.round(check.durationSeconds / 60)} minutes and complete the goal:</p>
          <p className="text-sm text-foreground font-medium">{check.goal}</p>
        </div>
      );
    case 'ordering':
      return (
        <div className="space-y-2">
          <p className="text-sm text-muted-foreground">Arrange these steps:</p>
          <ul className="list-disc space-y-1 pl-4 text-sm text-muted-foreground">
            {check.items.map((item) => (
              <li key={item}>{item}</li>
            ))}
          </ul>
        </div>
      );
    case 'match':
      return (
        <div className="space-y-2">
          <p className="text-sm text-muted-foreground">Match each item:</p>
          <ul className="space-y-1 text-sm text-muted-foreground">
            {check.pairs.map(([left, right]) => (
              <li key={left}>
                <span className="font-medium text-foreground">{left}</span> → {showAnswers ? right : '________'}
              </li>
            ))}
          </ul>
        </div>
      );
    case 'wordcount':
      return (
        <div className="space-y-2">
          <p className="text-sm text-muted-foreground">Stay under {check.maxWords} words for this exercise.</p>
          {!showAnswers && <TextareaAutosize minRows={4} className="w-full rounded-2xl border border-border/60 bg-card px-4 py-2 text-sm text-foreground" placeholder="Draft your response here" />}
        </div>
      );
    case 'reflection':
      return (
        <div className="space-y-2">
          <p className="text-sm text-muted-foreground">Reflect: {check.question}</p>
          {!showAnswers && <TextareaAutosize minRows={3} className="w-full rounded-2xl border border-border/60 bg-card px-4 py-2 text-sm text-foreground" placeholder="Jot down your notes" />}
        </div>
      );
    case 'checklist':
      return (
        <div className="space-y-2">
          <p className="text-sm text-muted-foreground">Tick off each item:</p>
          <ul className="space-y-2 text-sm text-muted-foreground">
            {check.items.map((item) => (
              <li key={item} className="flex items-center gap-3">
                <Checkbox checked={showAnswers} readOnly />
                <span>{item}</span>
              </li>
            ))}
          </ul>
        </div>
      );
    default:
      return null;
  }
};

const DrillRunner = ({ drill, completed }: DrillPageProps) => {
  const [submitting, setSubmitting] = useState(false);
  const [done, setDone] = useState(completed);
  const [error, setError] = useState<string | null>(null);
  const [showAnswers, setShowAnswers] = useState(false);

  const handleComplete = async () => {
    setSubmitting(true);
    setError(null);
    try {
      const response = await fetch('/api/writing/drills/complete', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          tags: [drill.criterion, drill.slug],
        }),
      });
      if (!response.ok) {
        const payload = (await response.json().catch(() => ({}))) as { error?: string };
        throw new Error(payload.error ?? 'Unable to record completion');
      }
      setDone(true);
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Unable to record completion');
    } finally {
      setSubmitting(false);
    }
  };

  return (
    <>
      <Head>
        <title>{drill.title} • Writing drill</title>
      </Head>
      <Container className="py-10">
        <div className="mx-auto flex max-w-4xl flex-col gap-6">
          <Card className="space-y-4" padding="lg">
            <div className="flex flex-wrap items-center justify-between gap-3">
              <div className="space-y-1">
                <Badge variant="soft" tone="info" size="sm">
                  {drill.criterion} • {criteriaLabels[drill.criterion]}
                </Badge>
                <h1 className="text-2xl font-semibold text-foreground">{drill.title}</h1>
                <p className="text-sm text-muted-foreground">{drill.prompt}</p>
              </div>
              <div className="flex flex-col items-end gap-2 text-xs text-muted-foreground">
                <span>{drill.durationMinutes} min</span>
                {done && <Badge variant="soft" tone="success" size="sm">Completed</Badge>}
              </div>
            </div>
            <div className="flex flex-wrap gap-2 text-xs text-muted-foreground">
              {drill.tags.map((tag) => (
                <Badge key={tag} variant="soft" tone="default" size="sm">
                  #{tag}
                </Badge>
              ))}
            </div>
            <ol className="list-decimal space-y-3 pl-6 text-sm text-muted-foreground">
              {drill.steps.map((step) => (
                <li key={step}>{step}</li>
              ))}
            </ol>
            <div className="flex items-center justify-between">
              <Button size="sm" variant="ghost" onClick={() => setShowAnswers((prev) => !prev)}>
                {showAnswers ? 'Hide examples' : 'Show examples'}
              </Button>
              <Button size="sm" onClick={handleComplete} disabled={submitting} loading={submitting}>
                Mark drill complete
              </Button>
            </div>
            {error && <p className="text-sm text-danger">{error}</p>}
          </Card>

          <div className="grid gap-4">
            {drill.checks.map((check, index) => (
              <Card key={index} className="space-y-3" padding="lg">
                {renderCheck(check, showAnswers)}
              </Card>
            ))}
          </div>
        </div>
      </Container>
    </>
  );
};

export const getServerSideProps: GetServerSideProps<DrillPageProps> = withPlanPage('free')(async (ctx) => {
  const { slug } = ctx.params as { slug: string };
  const drill = findDrillBySlug(slug);
  if (!drill) {
    return { notFound: true };
  }

  const supabase = getServerClient(ctx.req as any, ctx.res as any);
  const {
    data: { user },
  } = await supabase.auth.getUser();

  if (!user) {
    return {
      redirect: {
        destination: '/welcome?from=/writing',
        permanent: false,
      },
    };
  }

  const { data: events } = await supabase
    .from('writing_drill_events')
    .select('tags')
    .eq('user_id', user.id)
    .contains('tags', [drill.slug])
    .limit(1);

  const completed = (events ?? []).length > 0;

  return {
    props: {
      drill,
      completed,
    },
  };
});

export default DrillRunner;



────────────────────────────────────────────────
[15] FILE: pages/writing/reviews/calibrate.tsx
────────────────────────────────────────────────
import { useState } from 'react';
import type { GetServerSideProps } from 'next';
import Head from 'next/head';

import { Badge } from '@/components/design-system/Badge';
import { Button } from '@/components/design-system/Button';
import { Card } from '@/components/design-system/Card';
import { Container } from '@/components/design-system/Container';
import calibration from '@/data/writing/review-calibration';
import { getServerClient } from '@/lib/supabaseServer';
import { withPlanPage } from '@/lib/withPlanPage';

interface CalibrationAnchor {
  id: string;
  taskType: string;
  prompt: string;
  band: number;
  essay: string;
  rubric: Record<string, string>;
}

interface CalibrationPageProps {
  anchors: CalibrationAnchor[];
}

const CalibrationPage = ({ anchors }: CalibrationPageProps) => {
  const [submitting, setSubmitting] = useState(false);
  const [complete, setComplete] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const handleSubmit = async () => {
    setSubmitting(true);
    setError(null);
    try {
      const [firstAnchor] = anchors;
      const response = await fetch('/api/writing/reviews/calibrate', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          anchorId: firstAnchor.id,
          ratings: { TR: 7, CC: 7, LR: 7, GRA: 7 },
        }),
      });
      if (!response.ok) {
        const payload = (await response.json().catch(() => ({}))) as { error?: string };
        throw new Error(payload.error ?? 'Unable to record calibration');
      }
      setComplete(true);
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Unable to record calibration');
    } finally {
      setSubmitting(false);
    }
  };

  return (
    <>
      <Head>
        <title>Peer review calibration • Writing studio</title>
      </Head>
      <Container className="py-10">
        <div className="mx-auto flex max-w-4xl flex-col gap-6">
          <header className="space-y-2">
            <h1 className="text-3xl font-semibold text-foreground md:text-4xl">Peer review calibration</h1>
            <p className="text-sm text-muted-foreground">
              Score two anchored essays to align with Gramor feedback standards. Once complete, you can submit peer reviews on any attempt.
            </p>
          </header>

          {anchors.map((anchor) => (
            <Card key={anchor.id} className="space-y-4" padding="lg">
              <div className="flex flex-wrap items-center justify-between gap-3">
                <Badge variant="soft" tone="info" size="sm" className="capitalize">
                  {anchor.taskType}
                </Badge>
                <Badge variant="soft" tone="success" size="sm">
                  Band {anchor.band.toFixed(1)}
                </Badge>
              </div>
              <h2 className="text-xl font-semibold text-foreground">{anchor.prompt}</h2>
              <div className="space-y-2 rounded-2xl border border-border/60 bg-muted/20 p-3">
                <p className="whitespace-pre-line text-sm text-muted-foreground">{anchor.essay}</p>
              </div>
              <div className="space-y-2">
                <h3 className="text-sm font-semibold text-foreground">Rubric highlights</h3>
                <ul className="space-y-2 text-sm text-muted-foreground">
                  {Object.entries(anchor.rubric).map(([criterion, note]) => (
                    <li key={criterion} className="flex items-start gap-2">
                      <Badge variant="soft" tone="default" size="xs">
                        {criterion}
                      </Badge>
                      <span>{note}</span>
                    </li>
                  ))}
                </ul>
              </div>
            </Card>
          ))}

          <Card className="space-y-3" padding="lg">
            <h2 className="text-lg font-semibold text-foreground">Confirm alignment</h2>
            <p className="text-sm text-muted-foreground">
              When you understand the scoring rationale above, record your calibration to unlock peer feedback tools.
            </p>
            {error && <p className="text-sm text-danger">{error}</p>}
            <div className="flex flex-wrap gap-2">
              <Button onClick={handleSubmit} loading={submitting} disabled={complete}>
                {complete ? 'Calibration recorded' : 'Mark calibration complete'}
              </Button>
              <Button size="sm" variant="outline" href="/writing/review">
                Back to reviews
              </Button>
            </div>
          </Card>
        </div>
      </Container>
    </>
  );
};

export const getServerSideProps: GetServerSideProps<CalibrationPageProps> = withPlanPage('starter')(async (ctx) => {
  const supabase = getServerClient(ctx.req as any, ctx.res as any);
  const {
    data: { user },
  } = await supabase.auth.getUser();

  if (!user) {
    return {
      redirect: {
        destination: '/welcome?from=/writing',
        permanent: false,
      },
    };
  }

  return {
    props: {
      anchors: calibration as CalibrationAnchor[],
    },
  };
});

export default CalibrationPage;



