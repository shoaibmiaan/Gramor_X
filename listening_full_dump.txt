===== components/listening/AnswerReview.tsx =====
import React, { useMemo } from 'react';
import { Card } from '@/components/design-system/Card';
import { Badge } from '@/components/design-system/Badge';

type QType = 'mcq' | 'gap' | 'match';

type MatchPair = [number, number];
type AnswerValue = string | MatchPair[];

type McqQuestion = {
  qno: number;
  type: 'mcq';
  prompt?: string;
  options?: string[];
  answer_key: { value: string };
};

type GapQuestion = {
  qno: number;
  type: 'gap';
  prompt?: string;
  answer_key: { text: string };
};

type MatchQuestion = {
  qno: number;
  type: 'match';
  prompt?: string;
  match_left?: string[];
  match_right?: string[];
  answer_key: { pairs: MatchPair[] };
};

type Question = McqQuestion | GapQuestion | MatchQuestion;

type Answer =
  | { qno: number; answer: AnswerValue | null }
  | { qno: number; value?: string; text?: string; pairs?: MatchPair[] }; // tolerates older shapes

type AnswerMap = Record<number, AnswerValue | null>;

type Props = {
  questions: Question[];
  answers: Answer[] | AnswerMap;
  className?: string;
};

function toMap(answers: Props['answers']): AnswerMap {
  if (Array.isArray(answers)) {
    const m: AnswerMap = {};
    for (const a of answers) {
      if ('answer' in a) {
        m[a.qno] = a.answer ?? null;
      } else {
        m[a.qno] = a.value ?? a.text ?? a.pairs ?? null;
      }
    }
    return m;
  }
  return answers || {};
}

// ------- Normalizers & comparers -------
const normText = (s: unknown) =>
  String(s ?? '')
    .toLowerCase()
    .trim()
    .replace(/\s+/g, ' ')
    .replace(/[.,/#!$%^&*;:{}=\-_`~()"]/g, '');

function isCorrect(q: Question, user: AnswerValue | null) {
  if (user == null) return false;

  if (q.type === 'mcq') {
    const want = String(q.answer_key.value ?? '').trim().toUpperCase();
    const got = String(user).trim().toUpperCase();
    return want !== '' && got === want;
  }

  if (q.type === 'gap') {
    const want = normText(q.answer_key.text);
    const got = normText(user);
    return want !== '' && got === want;
  }

  // match: compare normalized pairs (sorted)
  if (q.type === 'match') {
    const wantPairs: MatchPair[] = (q.answer_key.pairs ?? []).map(
      ([l, r]): MatchPair => [Number(l), Number(r)]
    );
    const gotPairs: MatchPair[] = Array.isArray(user)
      ? (user as MatchPair[]).map(([l, r]) => [Number(l), Number(r)] as MatchPair)
      : [];
    const sort = (arr: MatchPair[]) =>
      [...arr]
        .map(([l, r]) => [l, r] as MatchPair)
        .sort((a, b) => a[0] - b[0] || a[1] - b[1]);
    const a = JSON.stringify(sort(wantPairs));
    const b = JSON.stringify(sort(gotPairs));
    return a === b && wantPairs.length > 0;
  }

  return false;
}

function formatAnswer(q: Question, val: AnswerValue | null): string {
  if (val == null) return '—';
  if (q.type === 'mcq') return String(val).toUpperCase();
  if (q.type === 'gap') return String(val);
  if (q.type === 'match') {
    const pairs: MatchPair[] = Array.isArray(val)
      ? (val as MatchPair[]).map(([l, r]) => [Number(l), Number(r)] as MatchPair)
      : [];
    return pairs.map(([l, r]) => `${l}→${r}`).join(', ');
  }
  return String(val);
}

function correctValue(q: Question): AnswerValue {
  if (q.type === 'mcq') return q.answer_key.value ?? '';
  if (q.type === 'gap') return q.answer_key.text ?? '';
  if (q.type === 'match') return q.answer_key.pairs ?? [];
  return '';
}

type RowResult = {
  q: Question;
  user: AnswerValue | null;
  correct: AnswerValue;
  ok: boolean;
  unanswered: boolean;
};

export default function AnswerReview({ questions, answers, className = '' }: Props) {
  const aMap = useMemo<AnswerMap>(() => toMap(answers), [answers]);

  const rows = useMemo<RowResult[]>(() => {
    return [...questions].sort((a, b) => a.qno - b.qno).map(q => {
      const user = aMap[q.qno] ?? null;
      const correct = correctValue(q);
      const ok = isCorrect(q, user);
      const unanswered = user == null || (q.type !== 'match' && String(user).trim() === '');

      return {
        q,
        user,
        correct,
        ok,
        unanswered,
      };
    });
  }, [questions, aMap]);

  const totals = useMemo<{ correct: number; total: number }>(() => {
    const correct = rows.filter(r => r.ok).length;
    const total = rows.length;
    return { correct, total };
  }, [rows]);

  return (
    <section className={className}>
      <Card className="card-surface p-6 rounded-ds-2xl mb-4">
        <div className="flex flex-wrap items-center gap-3">
          <h3 className="text-h3 font-semibold">Answer Review</h3>
          <Badge variant="primary" size="sm">
            Correct: {totals.correct} / {totals.total}
          </Badge>
        </div>
      </Card>

      <div className="grid gap-3">
        {rows.map(({ q, user, correct, ok, unanswered }) => (
          <Card key={q.qno} className="card-surface p-4 rounded-ds-2xl">
            <div className="flex flex-wrap items-start gap-3">
              <div className="min-w-[64px]">
                <Badge variant={ok ? 'primary' : unanswered ? 'warning' : 'danger'} size="sm">
                  Q{q.qno} {ok ? 'Correct' : unanswered ? 'Unanswered' : 'Incorrect'}
                </Badge>
              </div>

              <div className="flex-1">
                {q.prompt && (
                  <div className="text-body mb-2">
                    <span className="opacity-70">Prompt:</span> {q.prompt}
                  </div>
                )}

                {/* Type-specific context */}
                {q.type === 'mcq' && q.options?.length ? (
                  <div className="text-small text-muted-foreground mb-2">
                    Options: {q.options.map((opt, idx) => (
                      <span key={idx} className="inline-block mr-2">
                        <span className="font-semibold">{String.fromCharCode(65 + idx)}.</span> {opt}
                      </span>
                    ))}
                  </div>
                ) : null}

                {q.type === 'match' && (q.match_left?.length || q.match_right?.length) ? (
                  <div className="text-small text-muted-foreground mb-2">
                    <div>Left: {q.match_left?.join(', ') || '—'}</div>
                    <div>Right: {q.match_right?.join(', ') || '—'}</div>
                  </div>
                ) : null}

                {/* Answers row */}
                <div className="flex flex-wrap items-center gap-2">
                  <span className="text-small opacity-70 mr-1">Your answer:</span>
                  <Badge variant={ok ? 'primary' : unanswered ? 'warning' : 'danger'} size="sm">
                    {formatAnswer(q, user)}
                  </Badge>

                  {!ok && (
                    <>
                      <span className="text-small opacity-70 mx-2">Correct:</span>
                      <Badge variant="primary" size="sm">
                        {formatAnswer(q, correct)}
                      </Badge>
                    </>
                  )}
                </div>
              </div>
            </div>
          </Card>
        ))}
      </div>
    </section>
  );
}

export type { Question, Answer, MatchPair };



===== components/listening/AudioSectionsPlayer.tsx =====
import { Icon } from '@/components/design-system/Icon';
// components/listening/AudioSectionsPlayer.tsx
import React, { useCallback, useEffect, useMemo, useRef, useState } from 'react';
import { ProgressBar } from '@/components/design-system/ProgressBar';
import AudioPlayer from '@/components/audio/Player';

type MCQ = {
  id: string;
  qNo: number;
  type: 'mcq';
  prompt: string;
  options: string[];
  answer: string;
};

type GAP = {
  id: string;
  qNo: number;
  type: 'gap';
  prompt: string;
  answer: string;
};

type MATCH = {
  id: string;
  qNo: number;
  type: 'match';
  left: string[];
  right: string[];
  pairs: Record<number, number>; // key: left index, value: right index
};

export type Question = MCQ | GAP | MATCH;

export type ListeningSection = {
  orderNo: number;
  startMs: number;
  endMs: number;
  transcript?: string;
  questions: Question[];
};

export type AudioSectionsPlayerProps = {
  masterAudioUrl: string;
  sections: ListeningSection[];
  initialSectionIndex?: number;
  autoAdvance?: boolean;       // default: true
  allowSeek?: boolean;         // default: false (exam-like)
  onReady?: () => void;
  onPlay?: (sectionIndex: number) => void;
  onPause?: (sectionIndex: number) => void;
  onSectionChange?: (sectionIndex: number) => void;
  onTimeUpdate?: (payload: { sectionIndex: number; sectionMs: number; absoluteMs: number }) => void;
  seekToMs?: number | null;
  onExternalSeekResolved?: () => void;
  className?: string;
};

function clamp(n: number, min: number, max: number) {
  return Math.max(min, Math.min(max, n));
}

export const AudioSectionsPlayer: React.FC<AudioSectionsPlayerProps> = ({
  masterAudioUrl,
  sections,
  initialSectionIndex = 0,
  autoAdvance = true,
  allowSeek = false,
  onReady,
  onPlay,
  onPause,
  onSectionChange,
  onTimeUpdate,
  seekToMs = null,
  onExternalSeekResolved,
  className = '',
}) => {
  // ---- SSR-safe mount gate (no conditional hooks) ----
  const [mounted, setMounted] = useState(false);
  useEffect(() => { setMounted(true); }, []);

  // ---- refs & state ----
  const audioRef = useRef<HTMLAudioElement | null>(null);
  const rafRef = useRef<number | null>(null);
  const lastSeekRef = useRef<number | null>(null);
  const [ready, setReady] = useState(false);
  const [playing, setPlaying] = useState(false);
  const [sectionIndex, setSectionIndex] = useState<number>(clamp(initialSectionIndex, 0, Math.max(0, sections.length - 1)));
  const [localTimeMs, setLocalTimeMs] = useState<number>(0); // progress within section

  const hasAudio = Boolean(masterAudioUrl);
  const current = sections[sectionIndex];

  // Precomputed section bounds in seconds (HTMLAudio is seconds-based)
  const bounds = useMemo(() => {
    if (!current) return { startS: 0, endS: 0, lengthMs: 0 };
    const startS = current.startMs / 1000;
    const endS = current.endMs / 1000;
    const lengthMs = current.endMs - current.startMs;
    return { startS, endS, lengthMs };
  }, [current]);

  // ---- helpers (unconditional hooks) ----
  const loadToSection = useCallback((sIndex: number) => {
    const audio = audioRef.current;
    const target = sections[sIndex];
    if (!audio || !target) return;

    // Jump to section start
    audio.currentTime = target.startMs / 1000;
    setLocalTimeMs(0);
  }, [sections]);

  const tick = useCallback(() => {
    const audio = audioRef.current;
    if (!audio || !current) return;

    const nowS = audio.currentTime;
    const nowMs = nowS * 1000;
    const startMs = current.startMs;
    const endMs = current.endMs;

    // update progress within section
    const within = clamp(nowMs - startMs, 0, Math.max(0, endMs - startMs));
    setLocalTimeMs(within);
    onTimeUpdate?.({ sectionIndex, sectionMs: within, absoluteMs: nowMs });

    // stop/advance at section end
    if (nowMs >= endMs - 10) {
      // small guard
      if (autoAdvance && sectionIndex < sections.length - 1) {
        // advance to next section
        const next = sectionIndex + 1;
        setSectionIndex(next);
        onSectionChange?.(next);
        // queue jump on next frame to avoid stutter
        requestAnimationFrame(() => {
          loadToSection(next);
          audio.play().catch(() => setPlaying(false));
          onPlay?.(next);
        });
      } else {
        // pause at the end
        audio.pause();
        setPlaying(false);
        onPause?.(sectionIndex);
      }
    }

    rafRef.current = requestAnimationFrame(tick);
  }, [
    autoAdvance,
    current,
    loadToSection,
    onPause,
    onPlay,
    onSectionChange,
    onTimeUpdate,
    sectionIndex,
    sections.length,
  ]);

  const startRaf = useCallback(() => {
    if (rafRef.current != null) cancelAnimationFrame(rafRef.current);
    rafRef.current = requestAnimationFrame(tick);
  }, [tick]);

  const stopRaf = useCallback(() => {
    if (rafRef.current != null) {
      cancelAnimationFrame(rafRef.current);
      rafRef.current = null;
    }
  }, []);

  const handleCanPlay = useCallback(() => {
    setReady(true);
    onReady?.();
    loadToSection(sectionIndex);
  }, [loadToSection, onReady, sectionIndex]);

  const handlePlay = useCallback(() => {
    setPlaying(true);
    onPlay?.(sectionIndex);
    startRaf();
  }, [onPlay, sectionIndex, startRaf]);

  const handlePause = useCallback(() => {
    setPlaying(false);
    onPause?.(sectionIndex);
    stopRaf();
  }, [onPause, sectionIndex, stopRaf]);

  const handleEnded = useCallback(() => {
    setPlaying(false);
    stopRaf();
  }, [stopRaf]);

  // jump audio when section changes (user nav)
  useEffect(() => {
    if (!ready) return;
    loadToSection(sectionIndex);
  }, [ready, sectionIndex, loadToSection]);

  useEffect(() => () => stopRaf(), [stopRaf]);

  useEffect(() => {
    if (!mounted) return;
    if (seekToMs == null) return;
    if (seekToMs === lastSeekRef.current) return;
    lastSeekRef.current = seekToMs;

    const audio = audioRef.current;
    if (!audio) return;

    const targetIndex = sections.findIndex((s) => seekToMs >= s.startMs && seekToMs <= s.endMs);
    if (targetIndex !== -1) {
      if (targetIndex !== sectionIndex) {
        setSectionIndex(targetIndex);
        onSectionChange?.(targetIndex);
      }
      const target = sections[targetIndex];
      const within = clamp(seekToMs - target.startMs, 0, Math.max(0, target.endMs - target.startMs));
      setLocalTimeMs(within);
    }

    audio.currentTime = seekToMs / 1000;
    onExternalSeekResolved?.();
  }, [mounted, onExternalSeekResolved, onSectionChange, sectionIndex, sections, seekToMs]);

  // ---- controls ----
  const play = useCallback(() => {
    const audio = audioRef.current;
    if (!audio) return;
    // clamp to section window if user scrubbed
    const nowS = audio.currentTime;
    if (nowS < bounds.startS || nowS > bounds.endS) {
      audio.currentTime = bounds.startS;
    }
    audio.play().catch(() => setPlaying(false));
  }, [bounds.startS, bounds.endS]);

  const pause = useCallback(() => {
    audioRef.current?.pause();
  }, []);

  const prevSection = useCallback(() => {
    const prev = clamp(sectionIndex - 1, 0, sections.length - 1);
    if (prev === sectionIndex) return;
    setSectionIndex(prev);
    onSectionChange?.(prev);
  }, [onSectionChange, sectionIndex, sections.length]);

  const nextSection = useCallback(() => {
    const next = clamp(sectionIndex + 1, 0, sections.length - 1);
    if (next === sectionIndex) return;
    setSectionIndex(next);
    onSectionChange?.(next);
  }, [onSectionChange, sectionIndex, sections.length]);

  const onSeek = useCallback((pct: number) => {
    if (!allowSeek) return; // locked in exam mode
    const audio = audioRef.current;
    if (!audio || !current) return;
    const lengthMs = current.endMs - current.startMs;
    const newWithinMs = clamp(Math.round(lengthMs * pct), 0, lengthMs);
    audio.currentTime = (current.startMs + newWithinMs) / 1000;
    setLocalTimeMs(newWithinMs);
  }, [allowSeek, current]);

  // ---- derived for UI ----
  const pct = useMemo(() => {
    const len = Math.max(1, bounds.endS * 1000 - bounds.startS * 1000);
    return clamp(localTimeMs / len, 0, 1);
  }, [bounds.endS, bounds.startS, localTimeMs]);

  const mmss = useMemo(() => {
    const secs = Math.floor(localTimeMs / 1000);
    const m = Math.floor(secs / 60).toString().padStart(2, '0');
    const s = (secs % 60).toString().padStart(2, '0');
    return `${m}:${s}`;
  }, [localTimeMs]);

  const handleSliderKeyDown = useCallback(
    (event: React.KeyboardEvent<HTMLDivElement>) => {
      if (!allowSeek) return;

      let nextPct: number | null = null;
      const step = 0.05; // 5%
      const bigStep = 0.1; // 10%

      switch (event.key) {
        case 'ArrowLeft':
        case 'ArrowDown':
          nextPct = clamp(pct - step, 0, 1);
          break;
        case 'ArrowRight':
        case 'ArrowUp':
          nextPct = clamp(pct + step, 0, 1);
          break;
        case 'PageDown':
          nextPct = clamp(pct - bigStep, 0, 1);
          break;
        case 'PageUp':
          nextPct = clamp(pct + bigStep, 0, 1);
          break;
        case 'Home':
          nextPct = 0;
          break;
        case 'End':
          nextPct = 1;
          break;
        default:
          break;
      }

      if (nextPct == null) return;

      event.preventDefault();
      onSeek(nextPct);
    },
    [allowSeek, onSeek, pct]
  );

  const focusRing =
    'focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-primary/70 focus-visible:ring-offset-2 focus-visible:ring-offset-background';

  const togglePlayPause = useCallback(() => {
    if (playing) {
      pause();
    } else {
      play();
    }
  }, [pause, play, playing]);

  const playPauseLabel = playing ? 'Pause' : 'Play';
  const playPauseIcon = playing ? 'pause' : 'play';

  // ---- render ----
  if (!mounted) {
    return (
      <div className={`card-surface p-4 rounded-ds ${className}`}>
        <div className="text-small opacity-80">Loading audio…</div>
      </div>
    );
  }

  if (!hasAudio || !current) {
    return (
      <div className={`card-surface p-4 rounded-ds ${className}`}>
        <div className="text-small opacity-80">No audio or sections available.</div>
      </div>
    );
  }

  return (
    <div className={`card-surface p-4 rounded-ds ${className}`}>
      {/* Header / Section info */}
      <div className="flex items-center justify-between gap-3">
        <div>
          <div className="text-small opacity-70">Section</div>
          <div className="font-semibold">#{current.orderNo}</div>
        </div>
        <div className="flex items-center gap-2">
          <button
            type="button"
            onClick={prevSection}
            className={`px-3 py-2 rounded-ds border border-lightBorder dark:border-white/10 hover:bg-white/5 ${focusRing}`}
            aria-label="Previous section"
          >
            <Icon name="step-backward" />
          </button>
          <button
            type="button"
            onClick={togglePlayPause}
            disabled={!ready && !playing}
            className={`px-4 py-2 rounded-ds-xl bg-primary text-white disabled:opacity-50 hover:opacity-90 ${focusRing}`}
            aria-label={playPauseLabel}
            aria-pressed={playing}
          >
            <Icon name={playPauseIcon} /> <span className="ml-2">{playPauseLabel}</span>
          </button>
          <button
            type="button"
            onClick={nextSection}
            className={`px-3 py-2 rounded-ds border border-lightBorder dark:border-white/10 hover:bg-white/5 ${focusRing}`}
            aria-label="Next section"
          >
            <Icon name="step-forward" />
          </button>
        </div>
      </div>

      {/* Progress */}
      <div className="mt-4">
        <div className="flex items-center justify-between text-small opacity-70 mb-1">
          <span>{mmss}</span>
          <span>{Math.round(pct * 100)}%</span>
        </div>
        <div
          onClick={(e) => {
            if (!allowSeek) return;
            const rect = (e.currentTarget as HTMLDivElement).getBoundingClientRect();
            const p = clamp((e.clientX - rect.left) / rect.width, 0, 1);
            onSeek(p);
          }}
          onKeyDown={handleSliderKeyDown}
          role={allowSeek ? 'slider' : undefined}
          aria-label={allowSeek ? 'Section progress' : undefined}
          aria-valuemin={allowSeek ? 0 : undefined}
          aria-valuemax={allowSeek ? 100 : undefined}
          aria-valuenow={allowSeek ? Math.round(pct * 100) : undefined}
          aria-valuetext={allowSeek ? `${mmss} elapsed` : undefined}
          tabIndex={allowSeek ? 0 : undefined}
          aria-disabled={allowSeek ? undefined : true}
          className={allowSeek ? `rounded-ds ${focusRing}` : undefined}
        >
          <ProgressBar
            value={pct * 100}
            className={allowSeek ? 'cursor-pointer' : 'cursor-not-allowed'}
          />
        </div>
      </div>

      {/* Hidden audio element holder (managed via ref) */}
      <AudioPlayer
        ref={audioRef}
        src={masterAudioUrl}
        hidden
        preload="metadata"
        preferMetadataOnly
        onCanPlay={handleCanPlay}
        onPlay={handlePlay}
        onPause={handlePause}
        onEnded={handleEnded}
      />
    </div>
  );
};

export default AudioSectionsPlayer;


===== components/listening/ListeningExamShell.tsx =====
// components/listening/ListeningExamShell.tsx
import * as React from 'react';

import { Card } from '@/components/design-system/Card';
import { Button } from '@/components/design-system/Button';
import { Badge } from '@/components/design-system/Badge';
import Icon from '@/components/design-system/Icon';
import { ExamFooter } from '@/components/exam/ExamFooter';
import { cn } from '@/lib/utils';

type BaseListeningTest = {
  id: string;
  title: string | null;
  slug?: string | null;
  duration_minutes?: number | null;
};

type ListeningExamShellProps<TTest extends BaseListeningTest = BaseListeningTest> = {
  test: TTest;
};

const DEFAULT_DURATION_MIN = 30;
const DEFAULT_TOTAL_QUESTIONS = 40;

export const ListeningExamShell = <TTest extends BaseListeningTest>({
  test,
}: ListeningExamShellProps<TTest>) => {
  const [currentQuestion, setCurrentQuestion] = React.useState(1);

  const totalQuestions = DEFAULT_TOTAL_QUESTIONS;
  const durationMinutes = test.duration_minutes ?? DEFAULT_DURATION_MIN;

  const [remainingSeconds, setRemainingSeconds] = React.useState(
    durationMinutes * 60,
  );

  // VERY simple in-component timer for now (CBE-strict later via shared hook)
  React.useEffect(() => {
    if (remainingSeconds <= 0) return;

    const id = window.setInterval(() => {
      setRemainingSeconds((prev) => (prev > 0 ? prev - 1 : 0));
    }, 1000);

    return () => window.clearInterval(id);
  }, [remainingSeconds]);

  const minutes = Math.floor(remainingSeconds / 60);
  const seconds = remainingSeconds % 60;

  const handlePrev = () => {
    setCurrentQuestion((q) => (q > 1 ? q - 1 : q));
  };

  const handleNext = () => {
    setCurrentQuestion((q) =>
      q < totalQuestions ? q + 1 : q,
    );
  };

  const handleSubmit = () => {
    // TODO: wire to real submit flow (API → Supabase)
    // For now just a placeholder action.
    // eslint-disable-next-line no-alert
    alert('Submit listening attempt – wire this to your API.');
  };

  return (
    <div className="space-y-4">
      {/* Top meta strip */}
      <Card className="flex flex-col gap-3 rounded-ds-2xl border border-border/70 bg-card/95 px-4 py-3 md:flex-row md:items-center md:justify-between">
        <div className="flex items-start gap-3">
          <span className="mt-1 inline-flex h-8 w-8 items-center justify-center rounded-full bg-primary/10 text-primary">
            <Icon name="Headphones" size={18} />
          </span>
          <div className="space-y-1">
            <div className="inline-flex items-center gap-2 text-[11px] font-medium">
              <Badge size="xs" variant="neutral">
                IELTS Listening · Mock
              </Badge>
              {test.slug && (
                <span className="rounded-ds-full bg-muted px-2 py-[2px] text-[10px] font-mono uppercase tracking-wide text-muted-foreground">
                  {test.slug}
                </span>
              )}
            </div>
            <h2 className="font-slab text-sm font-semibold text-foreground md:text-base">
              {test.title ?? 'Listening Mock Test'}
            </h2>
            <p className="text-[11px] text-muted-foreground">
              4 sections · {totalQuestions} questions ·{' '}
              {durationMinutes} minutes
            </p>
          </div>
        </div>

        <div className="flex items-center gap-4">
          <div className="text-right">
            <p className="text-[10px] font-medium uppercase tracking-[0.18em] text-muted-foreground">
              Time remaining
            </p>
            <p className="font-mono text-lg font-semibold text-foreground">
              {String(minutes).padStart(2, '0')}:
              {String(seconds).padStart(2, '0')}
            </p>
          </div>
          <div className="hidden h-10 w-px bg-border/70 md:block" />
          <div className="hidden flex-col items-end text-[11px] text-muted-foreground md:flex">
            <span>
              Q{currentQuestion} of {totalQuestions}
            </span>
            <span className="inline-flex items-center gap-1">
              <span className="h-2 w-8 rounded-full bg-muted">
                <span
                  className="block h-2 rounded-full bg-primary"
                  style={{
                    width: `${(currentQuestion / totalQuestions) * 100}%`,
                  }}
                />
              </span>
            </span>
          </div>
        </div>
      </Card>

      {/* Main exam layout */}
      <div className="grid gap-4 lg:grid-cols-[minmax(0,1.4fr)_minmax(0,1fr)]">
        {/* Left: audio + questions */}
        <div className="space-y-4">
          {/* Audio / instructions card */}
          <Card className="rounded-ds-2xl border border-border/70 bg-card/95 p-4">
            <div className="flex items-center justify-between gap-3">
              <div>
                <p className="text-xs font-semibold uppercase tracking-[0.18em] text-muted-foreground">
                  Audio playback
                </p>
                <p className="text-[11px] text-muted-foreground">
                  Once the recording starts, it will play only once. Follow the
                  instructions on screen.
                </p>
              </div>
              <Button
                type="button"
                size="sm"
                variant="secondary"
                className="rounded-ds-xl"
                // TODO: hook this to actual audio logic
                onClick={() => alert('Start audio – wire to real player.')}
              >
                <Icon name="Play" size={14} className="mr-1" />
                Start audio
              </Button>
            </div>

            {/* Fake waveform / placeholder */}
            <div className="mt-3 h-12 rounded-ds-xl bg-muted/80" />
          </Card>

          {/* Question area */}
          <Card className="min-h-[280px] rounded-ds-2xl border border-border/70 bg-card/95 p-4">
            <div className="mb-3 flex items-center justify-between gap-3">
              <div className="flex items-center gap-2">
                <Badge size="xs" variant="neutral">
                  Question {currentQuestion}
                </Badge>
                <span className="text-[11px] text-muted-foreground">
                  Section {/* TODO: derive from real data */}1
                </span>
              </div>
              <span className="text-[11px] text-muted-foreground">
                Answer EXACTLY as you hear it. Check spelling.
              </span>
            </div>

            {/* TODO: Replace this block with your real listening question renderer */}
            <div className="rounded-ds-xl border border-dashed border-border/60 bg-muted/40 px-4 py-6 text-sm text-muted-foreground">
              <p className="font-medium text-foreground">
                Listening question UI goes here.
              </p>
              <p className="mt-1 text-xs text-muted-foreground">
                Wire this to your actual question data (gap-fills, MCQs, maps, etc.).
                This shell only handles layout, timer, and navigation.
              </p>
            </div>
          </Card>
        </div>

        {/* Right: sidebar – question nav + status */}
        <div className="space-y-4">
          <Card className="rounded-ds-2xl border border-border/70 bg-card/95 p-4">
            <div className="mb-2 flex items-center justify-between gap-2">
              <p className="text-xs font-semibold uppercase tracking-[0.18em] text-muted-foreground">
                Question map
              </p>
              <span className="text-[11px] text-muted-foreground">
                Tap to jump
              </span>
            </div>

            <div className="grid grid-cols-8 gap-1">
              {Array.from({ length: totalQuestions }).map((_, idx) => {
                const qNo = idx + 1;
                const isCurrent = qNo === currentQuestion;
                const isVisited = qNo < currentQuestion;

                return (
                  <button
                    key={qNo}
                    type="button"
                    onClick={() => setCurrentQuestion(qNo)}
                    className={cn(
                      'flex h-7 w-7 items-center justify-center rounded-full border text-[11px] transition',
                      isCurrent &&
                        'border-primary bg-primary text-white shadow-sm',
                      !isCurrent &&
                        (isVisited
                          ? 'border-primary/40 bg-primary/5 text-primary'
                          : 'border-border bg-muted/70 text-muted-foreground hover:border-primary/40 hover:bg-primary/5 hover:text-primary'),
                    )}
                  >
                    {qNo}
                  </button>
                );
              })}
            </div>
          </Card>

          <Card className="rounded-ds-2xl border border-border/70 bg-card/95 p-4">
            <p className="text-xs font-semibold uppercase tracking-[0.18em] text-muted-foreground">
              Status
            </p>
            <div className="mt-3 space-y-2 text-xs text-muted-foreground">
              <div className="flex items-center justify-between">
                <span>Current question</span>
                <span className="font-medium text-foreground">
                  {currentQuestion} / {totalQuestions}
                </span>
              </div>
              <div className="flex items-center justify-between">
                <span>Time spent</span>
                <span className="font-medium text-foreground">
                  {Math.max(
                    0,
                    durationMinutes - Math.floor(remainingSeconds / 60),
                  )}
                  min
                </span>
              </div>
              <div className="flex items-center justify-between">
                <span>Estimated band</span>
                <span className="font-medium text-muted-foreground">
                  —{/* wired after scoring */}
                </span>
              </div>
            </div>
          </Card>
        </div>
      </div>

      {/* Bottom exam footer */}
      <ExamFooter
        currentQuestion={currentQuestion}
        totalQuestions={totalQuestions}
        primaryLabel="Submit listening test"
        onPrimaryClick={handleSubmit}
        primaryDisabled={false}
        secondaryLabel="Previous question"
        onSecondaryClick={handlePrev}
        className="mt-2"
      />

      {/* Simple next button floating on right side above footer */}
      <div className="flex justify-end">
        <Button
          type="button"
          variant="secondary"
          size="sm"
          className="mt-2 rounded-ds-xl"
          onClick={handleNext}
        >
          Next question
          <Icon name="ArrowRight" size={14} className="ml-1" />
        </Button>
      </div>
    </div>
  );
};


===== components/listening/ListeningFilterBar.tsx =====
// components/listening/ListeningFilterBar.tsx
import * as React from 'react';
import { Button } from '@/components/design-system/Button';
import { Badge } from '@/components/design-system/Badge';
import { Card } from '@/components/design-system/Card';

export type Level = 'beginner' | 'intermediate' | 'advanced';
export type Accent = 'uk' | 'us' | 'aus' | 'mix';

export type ListeningFilter = {
  level?: Level;
  topics: string[];
  accent?: Accent;
};

type Props = {
  value: ListeningFilter;
  onChange: (next: ListeningFilter) => void;
  allTopics: string[];
};

const LEVELS: (Level | undefined)[] = [undefined, 'beginner', 'intermediate', 'advanced'];
const ACCENTS: (Accent | undefined)[] = [undefined, 'mix', 'uk', 'us', 'aus'];

export function ListeningFilterBar({ value, onChange, allTopics }: Props) {
  const setLevel = (lvl?: Level) => onChange({ ...value, level: lvl });
  const setAccent = (acc?: Accent) => onChange({ ...value, accent: acc });
  const toggleTopic = (t: string) => {
    const has = value.topics.includes(t);
    const topics = has ? value.topics.filter((x) => x !== t) : [...value.topics, t];
    onChange({ ...value, topics });
  };
  const resetAll = () => onChange({ level: undefined, topics: [], accent: undefined });

  return (
    <Card className="p-4">
      <div className="flex flex-col gap-4">
        {/* Level */}
        <div className="flex flex-wrap items-center gap-2">
          <span className="opacity-70 text-sm">Level</span>
          <div className="flex flex-wrap gap-2">
            {LEVELS.map((lvl) => (
              <Button
                key={lvl ?? 'any'}
                size="sm"
                variant={value.level === lvl || (!value.level && !lvl) ? 'default' : 'ghost'}
                onClick={() => setLevel(lvl)}
                aria-pressed={value.level === lvl || (!value.level && !lvl)}
              >
                {lvl ? label(lvl) : 'Any'}
              </Button>
            ))}
          </div>
        </div>

        {/* Accent */}
        <div className="flex flex-wrap items-center gap-2">
          <span className="opacity-70 text-sm">Accent</span>
          <div className="flex flex-wrap gap-2">
            {ACCENTS.map((acc) => (
              <Button
                key={acc ?? 'any'}
                size="sm"
                variant={value.accent === acc || (!value.accent && !acc) ? 'default' : 'ghost'}
                onClick={() => setAccent(acc)}
                aria-pressed={value.accent === acc || (!value.accent && !acc)}
              >
                {acc ? acc.toUpperCase() : 'Any'}
              </Button>
            ))}
          </div>
        </div>

        {/* Topics */}
        <div className="flex flex-wrap items-center gap-2">
          <span className="opacity-70 text-sm">Topics</span>
          <div className="flex flex-wrap gap-2">
            {allTopics.map((t) => {
              const active = value.topics.includes(t);
              return (
                <button
                  key={t}
                  type="button"
                  onClick={() => toggleTopic(t)}
                  className="outline-none"
                  aria-pressed={active}
                >
                  <Badge variant={active ? 'default' : 'secondary'}>
                    {label(t)}
                  </Badge>
                </button>
              );
            })}
            {value.topics.length > 0 && (
              <Button size="sm" variant="ghost" onClick={() => onChange({ ...value, topics: [] })}>
                Clear topics
              </Button>
            )}
          </div>
        </div>

        {/* Reset */}
        {(value.level || value.accent || value.topics.length > 0) && (
          <div className="flex">
            <Button size="sm" variant="secondary" onClick={resetAll}>Reset filters</Button>
          </div>
        )}
      </div>
    </Card>
  );
}

function label(s: string) {
  return s.charAt(0).toUpperCase() + s.slice(1);
}


===== components/listening/ListeningHero.tsx =====
// components/listening/ListeningHero.tsx
import * as React from 'react';
import Link from 'next/link';
import { Button } from '@/components/design-system/Button';
import { Badge } from '@/components/design-system/Badge';

export function ListeningHero() {
  return (
    <div className="flex flex-col gap-4">
      <Badge>IELTS • Listening</Badge>
      <h1 className="text-2xl md:text-3xl font-semibold">
        Listening Tips & Resources
      </h1>
      <p className="opacity-80 max-w-2xl">
        Level-based strategies, practice drills, and AI tools to master IELTS Listening
        — Academic & General. Start where you are, and level up fast.
      </p>
      <div className="mt-2 flex flex-wrap items-center gap-3">
        <Link href="/tools/listening/dictation" className="inline-flex">
          <Button>Try AI Dictation</Button>
        </Link>
        <Link href="/mock/listening/start" className="inline-flex">
          <Button variant="secondary">Begin a Mock</Button>
        </Link>
      </div>
    </div>
  );
}


===== components/listening/NoiseLadderPlayer.tsx =====
// components/listening/NoiseLadderPlayer.tsx
import React, { useEffect, useRef } from 'react';

export type NoiseLayer = {
  label: string;
  src: string | null;
  volume?: number;
};

export type NoiseLadderPlayerProps = {
  audioRef: React.RefObject<HTMLAudioElement>;
  layers: NoiseLayer[];
  level: number;
  onLevelChange?: (level: number) => void;
  className?: string;
};

// Simple player that overlays a looping noise track on top of a base audio element.
export const NoiseLadderPlayer: React.FC<NoiseLadderPlayerProps> = ({
  audioRef,
  layers,
  level,
  onLevelChange,
  className = '',
}) => {
  const noiseRef = useRef<HTMLAudioElement | null>(null);

  // load the selected noise layer
  useEffect(() => {
    const noise = noiseRef.current;
    if (!noise) return;
    const layer = layers[level];
    if (layer && layer.src) {
      noise.src = layer.src;
      noise.loop = true;
      noise.volume = layer.volume ?? 0.3;
    } else {
      noise.src = '';
    }
  }, [level, layers]);

  // sync noise with the main audio
  useEffect(() => {
    const base = audioRef.current;
    const noise = noiseRef.current;
    if (!base || !noise) return;

    const handlePlay = () => {
      if (level > 0 && noise.src) {
        noise.currentTime = base.currentTime;
        noise.play().catch(() => {});
      }
    };
    const handlePause = () => noise.pause();

    base.addEventListener('play', handlePlay);
    base.addEventListener('pause', handlePause);

    return () => {
      base.removeEventListener('play', handlePlay);
      base.removeEventListener('pause', handlePause);
    };
  }, [audioRef, level]);

  const step = (delta: number) => {
    const max = layers.length - 1;
    const next = Math.max(0, Math.min(max, level + delta));
    if (next !== level) {
      onLevelChange?.(next);
    }
  };

  return (
    <div className={`flex items-center gap-2 ${className}`}>
      <button
        type="button"
        onClick={() => step(-1)}
        disabled={level <= 0}
        className="px-2 py-1 rounded-ds border border-lightBorder dark:border-white/10"
        aria-label="Decrease noise"
      >
        -
      </button>
      <span className="text-small">
        {layers[level]?.label ?? 'Off'}
      </span>
      <button
        type="button"
        onClick={() => step(1)}
        disabled={level >= layers.length - 1}
        className="px-2 py-1 rounded-ds border border-lightBorder dark:border-white/10"
        aria-label="Increase noise"
      >
        +
      </button>
      <audio ref={noiseRef} className="hidden" />
    </div>
  );
};

export default NoiseLadderPlayer;


===== components/listening/ReviewScreen.tsx =====
import React, { useEffect, useMemo, useState } from 'react';

import { supabase } from '@/lib/supabaseClient';
import { Card } from '@/components/design-system/Card';
import { Alert } from '@/components/design-system/Alert';
import { EmptyState } from '@/components/design-system/EmptyState';
import { Skeleton } from '@/components/design-system/Skeleton';
import { ScoreCard } from '@/components/design-system/ScoreCard';
import AnswerReview, {
  Answer as ReviewAnswer,
  MatchPair,
  Question as ReviewQuestion,
} from '@/components/listening/AnswerReview';
import TranscriptReview from '@/components/listening/TranscriptReview';
import { isCorrect } from '@/lib/answers';

type ApiAttempt = {
  id: string;
  test_slug: string;
  score: number;
  band: number | null;
  section_scores?: Record<string, unknown> | null;
  submitted_at: string | null;
  meta?: Record<string, unknown> | null;
};

type ApiQuestion = {
  qno: number;
  type: 'mcq' | 'gap' | 'match';
  prompt?: string | null;
  options?: any;
  match_left?: string[] | null;
  match_right?: string[] | null;
  answer_key?: any;
  section_order?: number | null;
};

type ApiAnswer = {
  qno: number;
  answer: any;
  is_correct?: boolean | null;
};

type ApiSection = {
  order_no: number;
  title?: string | null;
  transcript?: string | null;
};

type ApiTest = {
  slug: string;
  title?: string | null;
} | null;

type QuestionResult = {
  qno: number;
  ok: boolean;
  unanswered: boolean;
};

type Summary = {
  total: number;
  correct: number;
  accuracy: number;
  band: number;
  rawScore: number;
};

function normalizeMcqOptions(options: any): string[] {
  if (!Array.isArray(options)) return [];
  return options.map((opt) => {
    if (typeof opt === 'string') return opt;
    if (opt && typeof opt === 'object') {
      return String(opt.label ?? opt.text ?? opt.value ?? '').trim();
    }
    return String(opt ?? '');
  });
}

function normalizePairs(pairs: any): MatchPair[] {
  if (!Array.isArray(pairs)) return [];
  return pairs
    .map((pair): MatchPair | null => {
      if (Array.isArray(pair) && pair.length >= 2) {
        return [Number(pair[0]), Number(pair[1])] as MatchPair;
      }
      if (pair && typeof pair === 'object') {
        return [Number((pair as any).left), Number((pair as any).right)] as MatchPair;
      }
      return null;
    })
    .filter((pair): pair is MatchPair => Array.isArray(pair) && pair.every((v) => !Number.isNaN(v)));
}

function normalizeAnswerValue(question: ApiQuestion | undefined, value: any): string | MatchPair[] | null {
  if (value == null) return null;

  if (question?.type === 'match') {
    if (Array.isArray(value)) return normalizePairs(value);
    if (value && typeof value === 'object') {
      if ('pairs' in value) return normalizePairs((value as any).pairs);
      if ('left' in value && 'right' in value) return normalizePairs([value]);
    }
    return normalizePairs([]);
  }

  if (typeof value === 'string') return value;
  if (typeof value === 'number') return String(value);
  if (Array.isArray(value)) return String(value[0] ?? '');
  if (value && typeof value === 'object') {
    if ('value' in value) return String((value as any).value ?? '');
    if ('label' in value) return String((value as any).label ?? '');
    if ('text' in value) return String((value as any).text ?? '');
  }
  return String(value ?? '');
}

export default function ReviewScreen({ slug, attemptId }: { slug: string; attemptId?: string | null }) {
  const [attempt, setAttempt] = useState<ApiAttempt | null>(null);
  const [test, setTest] = useState<ApiTest>(null);
  const [questions, setQuestions] = useState<ApiQuestion[]>([]);
  const [answers, setAnswers] = useState<ApiAnswer[]>([]);
  const [sections, setSections] = useState<ApiSection[]>([]);
  const [sectionAssignments, setSectionAssignments] = useState<Map<number, number | null>>(new Map());
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    let active = true;

    (async () => {
      try {
        setLoading(true);
        setError(null);

        let id = attemptId ?? undefined;

        if (!id) {
          const { data: latest, error: latestErr } = await supabase
            .from('listening_attempts')
            .select('id')
            .eq('test_slug', slug)
            .order('submitted_at', { ascending: false })
            .limit(1)
            .maybeSingle();
          if (latestErr) throw latestErr;
          id = latest?.id ?? undefined;
        }

        if (!id) {
          if (active) {
            setAttempt(null);
            setTest(null);
            setQuestions([]);
            setAnswers([]);
            setSections([]);
            setSectionAssignments(new Map());
          }
          return;
        }

        const response = await fetch(`/api/listening/review/${id}`, { credentials: 'include' });
        if (!response.ok) {
          let detail = '';
          try {
            const parsed = await response.json();
            detail = parsed?.error;
          } catch {
            // ignore
          }
          throw new Error(detail || `Failed to load review (status ${response.status})`);
        }

        const payload = (await response.json()) as {
          attempt?: ApiAttempt;
          test?: ApiTest;
          questions?: ApiQuestion[];
          answers?: ApiAnswer[];
          sections?: ApiSection[];
        };

        if (!active) return;

        setAttempt(payload.attempt ?? null);
        setTest(payload.test ?? null);
        setQuestions(payload.questions ?? []);
        setAnswers(payload.answers ?? []);
        setSections(payload.sections ?? []);

        const assignment = new Map<number, number | null>();
        (payload.questions ?? []).forEach((q) => {
          assignment.set(q.qno, typeof q.section_order === 'number' ? q.section_order : null);
        });
        setSectionAssignments(assignment);
      } catch (err: any) {
        if (!active) return;
        setError(err?.message ?? 'Failed to load review');
        setAttempt(null);
        setTest(null);
        setQuestions([]);
        setAnswers([]);
        setSections([]);
        setSectionAssignments(new Map());
      } finally {
        if (active) setLoading(false);
      }
    })();

    return () => {
      active = false;
    };
  }, [slug, attemptId]);

  const normalized = useMemo(() => {
    const questionMap = new Map<number, ApiQuestion>();
    questions.forEach((q) => questionMap.set(q.qno, q));

    const normalizedQuestions: ReviewQuestion[] = questions.map((q) => {
      if (q.type === 'mcq') {
        const answerKey = String(q.answer_key?.value ?? '').trim();
        return {
          qno: q.qno,
          type: 'mcq',
          prompt: q.prompt ?? undefined,
          options: normalizeMcqOptions(q.options),
          answer_key: { value: answerKey },
        } as ReviewQuestion;
      }

      if (q.type === 'gap') {
        return {
          qno: q.qno,
          type: 'gap',
          prompt: q.prompt ?? undefined,
          answer_key: { text: String(q.answer_key?.text ?? '') },
        } as ReviewQuestion;
      }

      return {
        qno: q.qno,
        type: 'match',
        prompt: q.prompt ?? undefined,
        match_left: Array.isArray(q.match_left) ? q.match_left.map(String) : [],
        match_right: Array.isArray(q.match_right) ? q.match_right.map(String) : [],
        answer_key: { pairs: normalizePairs(q.answer_key?.pairs) },
      } as ReviewQuestion;
    });

    const normalizedAnswers: Array<{ qno: number; answer: string | MatchPair[] | null }> = answers.map((ans) => {
      const q = questionMap.get(ans.qno);
      return {
        qno: ans.qno,
        answer: normalizeAnswerValue(q, ans.answer),
      };
    });

    return { questions: normalizedQuestions, answers: normalizedAnswers };
  }, [questions, answers]);

  const answerMap = useMemo(() => {
    const map = new Map<number, string | MatchPair[] | null>();
    normalized.answers.forEach((ans) => {
      map.set(ans.qno, ans.answer ?? null);
    });
    return map;
  }, [normalized.answers]);

  const questionResults: QuestionResult[] = useMemo(() => {
    return normalized.questions.map((question) => {
      const userAnswer = answerMap.get(question.qno) ?? null;
      let ok = false;

      if (question.type === 'mcq') {
        ok = isCorrect(String(userAnswer ?? ''), question.answer_key.value);
      } else if (question.type === 'gap') {
        ok = isCorrect(String(userAnswer ?? ''), question.answer_key.text);
      } else {
        const want = question.answer_key.pairs ?? [];
        const got = Array.isArray(userAnswer) ? (userAnswer as MatchPair[]) : [];
        const sort = (pairs: MatchPair[]) =>
          [...pairs].sort((a, b) => (a[0] - b[0]) || (a[1] - b[1]));
        ok = want.length > 0 && JSON.stringify(sort(want)) === JSON.stringify(sort(got));
      }

      const unanswered =
        userAnswer == null || (question.type !== 'match' && String(userAnswer).trim().length === 0);

      return { qno: question.qno, ok, unanswered };
    });
  }, [normalized.questions, answerMap]);

  const summary: Summary = useMemo(() => {
    const total = questionResults.length;
    const correct = questionResults.filter((result) => result.ok).length;
    const accuracy = total ? (correct / total) * 100 : 0;
    const rawScore = attempt?.score ?? correct;
    const band = attempt?.band ?? Number(((accuracy / 100) * 9).toFixed(1));
    return { total, correct, accuracy, band, rawScore };
  }, [questionResults, attempt]);

  const transcriptSections = useMemo(() => {
    return sections
      .map((section) => ({
        order: section.order_no,
        title: section.title ?? null,
        transcript: section.transcript ?? null,
      }))
      .filter((section) => typeof section.order === 'number')
      .sort((a, b) => a.order - b.order);
  }, [sections]);

  const answersForReview = useMemo<ReviewAnswer[]>(
    () =>
      normalized.answers.map(
        (ans) => ({
          qno: ans.qno,
          answer: ans.answer ?? null,
        }) as ReviewAnswer
      ),
    [normalized.answers]
  );

  if (loading) {
    return (
      <Card className="card-surface rounded-ds-2xl p-6">
        <Skeleton className="h-6 w-48" />
        <div className="mt-4 space-y-3">
          <Skeleton className="h-20 w-full" />
          <Skeleton className="h-20 w-full" />
        </div>
      </Card>
    );
  }

  if (error) {
    return (
      <Alert variant="warning" title="Couldn’t load your review">
        {error}
      </Alert>
    );
  }

  if (!normalized.questions.length) {
    return (
      <EmptyState
        title="Nothing to review yet"
        description="Finish a Listening test to see your answers and explanations here."
        actionLabel="Back to Listening"
        onAction={() => history.back()}
      />
    );
  }

  const testTitle = test?.title || slug;
  const submittedAt = attempt?.submitted_at ? new Date(attempt.submitted_at) : null;

  return (
    <div className="grid gap-6 lg:grid-cols-3">
      <div className="space-y-6 lg:col-span-1">
        <Card className="card-surface rounded-ds-2xl p-6">
          <div className="space-y-4">
            <div>
              <p className="text-small uppercase tracking-wide text-muted-foreground">Listening Test</p>
              <h2 className="text-h3 font-semibold">{testTitle}</h2>
            </div>
            <ScoreCard title="Listening Band" overall={summary.band} />
            <dl className="space-y-2 text-small text-muted-foreground">
              <div className="flex items-center justify-between gap-2">
                <dt>Raw score</dt>
                <dd className="text-foreground font-semibold">
                  {summary.rawScore} / {summary.total || '—'}
                </dd>
              </div>
              <div className="flex items-center justify-between gap-2">
                <dt>Accuracy</dt>
                <dd className="text-foreground font-semibold">{Math.round(summary.accuracy)}%</dd>
              </div>
              {submittedAt ? (
                <div className="flex items-center justify-between gap-2">
                  <dt>Submitted</dt>
                  <dd className="text-foreground font-semibold">
                    {submittedAt.toLocaleString(undefined, {
                      year: 'numeric',
                      month: 'short',
                      day: 'numeric',
                      hour: '2-digit',
                      minute: '2-digit',
                    })}
                  </dd>
                </div>
              ) : null}
              {attempt?.id ? (
                <div className="flex items-center justify-between gap-2">
                  <dt>Attempt ID</dt>
                  <dd className="text-xs font-mono text-muted-foreground">{attempt.id}</dd>
                </div>
              ) : null}
            </dl>
          </div>
        </Card>

        <TranscriptReview
          sections={transcriptSections}
          questionStatuses={questionResults}
          sectionAssignments={sectionAssignments}
        />
      </div>

      <div className="lg:col-span-2">
        <AnswerReview questions={normalized.questions} answers={answersForReview} />
      </div>
    </div>
  );
}



===== components/listening/SaveButton.tsx =====
// Auto-generated placeholder component — replace with real implementation.
export default function Placeholder(){ return null; }


===== components/listening/Transcript.tsx =====
import React, { useEffect, useMemo, useRef, useState } from 'react';
import { Icon } from '@/components/design-system/Icon';

type Cue = {
  id: string;
  startMs: number;
  endMs: number;
  text: string;
};

type TranscriptProps = {
  transcript?: string | null;
  locked?: boolean;
  currentTimeMs?: number;
  onSeek?: (relativeMs: number) => void;
  followActiveCue?: boolean;
  className?: string;
  expanded?: boolean;
  defaultExpanded?: boolean;
  onExpandedChange?: (expanded: boolean) => void;
};

function parseTimestamp(raw: string): number | null {
  const cleaned = raw.trim().replace(',', '.');
  if (!cleaned) return null;
  const parts = cleaned.split(':');
  if (parts.length < 2 || parts.length > 3) return null;
  const [h, m, s] =
    parts.length === 3
      ? [Number(parts[0]), Number(parts[1]), Number(parts[2])]
      : [0, Number(parts[0]), Number(parts[1])];
  if ([h, m, s].some((v) => Number.isNaN(v))) return null;
  const secs = s;
  const whole = Math.trunc(secs);
  const frac = secs - whole;
  const total = h * 3600 + m * 60 + whole + frac;
  return Math.max(0, Math.round(total * 1000));
}

const TIMING_RE = /(?<start>\d{1,2}:\d{2}(?::\d{2})?(?:[.,]\d{1,3})?)\s*-->\s*(?<end>\d{1,2}:\d{2}(?::\d{2})?(?:[.,]\d{1,3})?)/;

function stripHtml(text: string) {
  return text.replace(/<[^>]+>/g, '').replace(/\s+/g, ' ').trim();
}

function parseTranscript(raw?: string | null): Cue[] {
  if (!raw) return [];
  const normalized = raw
    .replace(/\r/g, '')
    .replace(/^WEBVTT[^\n]*\n?/i, '')
    .replace(/<br\s*\/>/gi, '\n')
    .trim();
  if (!normalized) return [];

  const blocks = normalized.split(/\n{2,}/);
  const cues: Cue[] = [];

  blocks.forEach((block, idx) => {
    const lines = block.split('\n').map((line) => line.trim()).filter(Boolean);
    if (!lines.length) return;

    let pointer = 0;
    if (/^\d+$/.test(lines[0])) pointer += 1;
    const timingLine = lines[pointer] || '';
    const match = timingLine.match(TIMING_RE);

    let start = 0;
    let end = 0;
    if (match?.groups) {
      start = parseTimestamp(match.groups.start) ?? 0;
      end = parseTimestamp(match.groups.end) ?? start;
      pointer += 1;
    }

    const text = stripHtml(lines.slice(pointer).join(' '));
    if (!text) return;

    if (!match) {
      // Not a timecoded block; approximate order by index.
      start = cues.length ? cues[cues.length - 1].endMs : 0;
      end = start + Math.max(2000, text.split(' ').length * 600);
    } else if (end <= start) {
      end = start + Math.max(500, text.split(' ').length * 400);
    }

    cues.push({
      id: `${idx}-${start}`,
      startMs: start,
      endMs: end,
      text,
    });
  });

  if (cues.length) {
    return cues.sort((a, b) => a.startMs - b.startMs);
  }

  // Fallback: treat each line as a cue even without timing.
  const fallbackLines = normalized.split(/\n+/).map((line) => stripHtml(line)).filter(Boolean);
  return fallbackLines.map((text, idx) => ({
    id: `plain-${idx}`,
    startMs: idx * 4000,
    endMs: (idx + 1) * 4000,
    text,
  }));
}

function formatTimestamp(ms: number): string {
  const totalSeconds = Math.max(0, Math.round(ms / 1000));
  const minutes = Math.floor(totalSeconds / 60)
    .toString()
    .padStart(2, '0');
  const seconds = (totalSeconds % 60).toString().padStart(2, '0');
  return `${minutes}:${seconds}`;
}

export const Transcript: React.FC<TranscriptProps> = ({
  transcript,
  locked = false,
  currentTimeMs = 0,
  onSeek,
  followActiveCue = true,
  className = '',
  expanded,
  defaultExpanded = false,
  onExpandedChange,
}) => {
  const cues = useMemo(() => parseTranscript(transcript), [transcript]);
  const isControlled = typeof expanded === 'boolean';
  const [internalExpanded, setInternalExpanded] = useState(defaultExpanded);
  const expandedState = isControlled ? expanded : internalExpanded;
  const contentId = useMemo(() => `transcript-panel-${Math.random().toString(36).slice(2, 8)}`, []);
  const cueRefs = useRef<Array<HTMLButtonElement | null>>([]);

  useEffect(() => {
    if (!locked) return;
    if (expandedState) {
      if (!isControlled) {
        setInternalExpanded(false);
      }
      onExpandedChange?.(false);
    }
  }, [expandedState, isControlled, locked, onExpandedChange]);

  const activeIndex = useMemo(() => {
    if (!cues.length) return -1;
    const idx = cues.findIndex((cue) => currentTimeMs >= cue.startMs && currentTimeMs < cue.endMs);
    return idx;
  }, [cues, currentTimeMs]);

  useEffect(() => {
    if (!followActiveCue || !expanded) return;
    if (activeIndex < 0) return;
    const el = cueRefs.current[activeIndex];
    if (el) {
      el.scrollIntoView({ block: 'nearest', behavior: 'smooth' });
    }
  }, [activeIndex, expanded, followActiveCue]);

  const setExpandedState = (next: boolean) => {
    if (!isControlled) {
      setInternalExpanded(next);
    }
    onExpandedChange?.(next);
  };

  const handleToggle = () => {
    if (locked || !cues.length) return;
    setExpandedState(!expandedState);
  };

  const handleCueClick = (cue: Cue) => {
    if (!onSeek || locked) return;
    onSeek(cue.startMs);
  };

  const disabled = locked || !cues.length;
  const showContent = expandedState && !locked && cues.length > 0;
  const controlLabel = locked
    ? 'Transcript locked until you check your answers'
    : cues.length
    ? showContent
      ? 'Hide transcript'
      : 'Show transcript'
    : 'Transcript unavailable';

  return (
    <div className={`card-surface rounded-ds p-4 ${className}`}>
      <button
        type="button"
        onClick={handleToggle}
        className={`flex w-full items-center justify-between gap-2 rounded-ds border border-lightBorder px-3 py-2 text-left transition hover:bg-white/5 disabled:cursor-not-allowed disabled:opacity-60 dark:border-white/10`}
        aria-expanded={showContent}
        aria-controls={contentId}
        disabled={disabled}
        aria-label={controlLabel}
      >
        <span className="flex items-center gap-2 font-semibold">
          <Icon name={showContent ? 'chevron-up' : 'chevron-down'} />
          Transcript
        </span>
        <span className="text-small text-grayish">
          {locked ? 'Locked' : cues.length ? (showContent ? 'Hide' : 'Show') : 'Unavailable'}
        </span>
      </button>

      {locked ? (
        <p className="mt-3 text-small text-grayish">
          Transcript will unlock after you submit your answers.
        </p>
      ) : (
        <div
          id={contentId}
          hidden={!showContent}
          className="mt-3 max-h-64 overflow-y-auto rounded-ds border border-lightBorder bg-white/40 p-3 text-small leading-relaxed dark:border-white/10 dark:bg-white/5"
          aria-live="polite"
        >
          {cues.length ? (
            <ul className="space-y-2">
              {cues.map((cue, idx) => {
                const active = idx === activeIndex;
                return (
                  <li key={cue.id}>
                    <button
                      type="button"
                      onClick={() => handleCueClick(cue)}
                      ref={(node) => {
                        cueRefs.current[idx] = node;
                      }}
                      className={`w-full rounded-ds border px-3 py-2 text-left transition focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-primary/60 ${
                        active
                          ? 'border-primary/70 bg-primary/10 text-primary'
                          : 'border-lightBorder dark:border-white/10 hover:bg-black/5 dark:hover:bg-white/10'
                      }`}
                    >
                      <div className="flex items-start justify-between gap-3">
                        <span className="flex-1 whitespace-pre-line break-words text-sm">{cue.text}</span>
                        <span className={`ml-2 shrink-0 text-caption ${active ? 'text-primary' : 'text-muted-foreground'}`}>
                          {formatTimestamp(cue.startMs)}
                        </span>
                      </div>
                    </button>
                  </li>
                );
              })}
            </ul>
          ) : (
            <p className="text-small text-grayish">No transcript available for this section.</p>
          )}
        </div>
      )}
    </div>
  );
};

export default Transcript;


===== components/listening/TranscriptReview.tsx =====
import React, { useMemo } from 'react';

import { Card } from '@/components/design-system/Card';
import { Badge } from '@/components/design-system/Badge';

type Section = {
  order: number;
  title?: string | null;
  transcript?: string | null;
};

type QuestionStatus = {
  qno: number;
  ok: boolean;
  unanswered: boolean;
};

type Props = {
  sections: Section[];
  questionStatuses: QuestionStatus[];
  sectionAssignments: Map<number, number | null>;
  className?: string;
};

function badgeVariant(status: QuestionStatus) {
  if (status.ok) return 'primary';
  if (status.unanswered) return 'warning';
  return 'danger';
}

const TranscriptReview: React.FC<Props> = ({
  sections,
  questionStatuses,
  sectionAssignments,
  className = '',
}) => {
  const enrichedSections = useMemo(() => {
    return sections
      .map((section) => ({
        ...section,
        questions: questionStatuses
          .filter((status) => sectionAssignments.get(status.qno) === section.order)
          .sort((a, b) => a.qno - b.qno),
      }))
      .filter((section) => typeof section.order === 'number')
      .sort((a, b) => a.order - b.order);
  }, [sections, questionStatuses, sectionAssignments]);

  const hasTranscript = enrichedSections.some((section) => (section.transcript ?? '').trim().length > 0);

  if (!enrichedSections.length || !hasTranscript) return null;

  return (
    <Card className={`card-surface rounded-ds-2xl p-6 ${className}`}>
      <div className="flex flex-col gap-2">
        <h3 className="text-h4 font-semibold">Transcripts</h3>
        <p className="text-small text-muted-foreground">
          Review the audio transcripts and see which questions were associated with each section.
        </p>
      </div>

      <div className="mt-6 space-y-5">
        {enrichedSections.map((section) => {
          const transcript = (section.transcript ?? '').trim();
          return (
            <div
              key={section.order}
              className="rounded-ds-xl border border-lightBorder/60 bg-white/60 p-4 dark:border-white/10 dark:bg-white/5"
            >
              <div className="flex flex-wrap items-center justify-between gap-3">
                <div>
                  <p className="text-small uppercase tracking-wide text-muted-foreground">Section {section.order}</p>
                  {section.title ? <h4 className="text-body font-semibold">{section.title}</h4> : null}
                </div>

                {section.questions.length ? (
                  <div className="flex flex-wrap items-center gap-2">
                    {section.questions.map((status) => (
                      <Badge key={status.qno} variant={badgeVariant(status)} size="sm">
                        Q{status.qno}
                      </Badge>
                    ))}
                  </div>
                ) : null}
              </div>

              <div className="mt-3 whitespace-pre-wrap text-small leading-relaxed text-gray-900 dark:text-white/80">
                {transcript || 'Transcript not available for this section.'}
              </div>
            </div>
          );
        })}
      </div>
    </Card>
  );
};

export default TranscriptReview;



===== components/listening/accent/AccentClip.tsx =====
// Auto-generated placeholder component — replace with real implementation.
export default function Placeholder(){ return null; }


===== components/listening/analytics/DrillBreakdown.tsx =====
// Auto-generated placeholder component — replace with real implementation.
export default function Placeholder(){ return null; }


===== components/listening/cards/ResourceCard.tsx =====
// components/listening/cards/ResourceCard.tsx
import * as React from 'react';
import Link from 'next/link';
import { Card } from '@/components/design-system/Card';
import { Badge } from '@/components/design-system/Badge';

type Level = 'beginner' | 'intermediate' | 'advanced';
type Accent = 'uk' | 'us' | 'aus' | 'mix';

type Props = {
  title: string;
  kind: 'article' | 'audio' | 'video' | 'exercise';
  level: Level;
  accent: Accent;
  topics: string[];
  href: string;
  className?: string;
};

export function ResourceCard({
  title,
  kind,
  level,
  accent,
  topics,
  href,
  className,
}: Props) {
  return (
    <Link href={href} className="block">
      <Card className={['p-4 hover:translate-y-[-1px] transition-transform', className].filter(Boolean).join(' ')}>
        <div className="flex items-start justify-between">
          <Badge>{label(kind)}</Badge>
          <div className="flex gap-2">
            <Badge variant="secondary">{label(level)}</Badge>
            <Badge variant="secondary">{accent.toUpperCase()}</Badge>
          </div>
        </div>
        <h3 className="mt-3 text-base font-semibold">{title}</h3>
        {!!topics?.length && (
          <div className="mt-3 flex flex-wrap gap-2">
            {topics.map((t) => (
              <Badge key={t} variant="outline">
                {label(t)}
              </Badge>
            ))}
          </div>
        )}
      </Card>
    </Link>
  );
}

function label(s: string) {
  return s.charAt(0).toUpperCase() + s.slice(1);
}


===== components/listening/dictation/DictationEditor.tsx =====
// Auto-generated placeholder component — replace with real implementation.
export default function Placeholder(){ return null; }


===== components/listening/players/AccentSwitcher.tsx =====
// Auto-generated placeholder component — replace with real implementation.
export default function Placeholder(){ return null; }


===== components/listening/quizzes/TimedMiniTest.tsx =====
// Auto-generated placeholder component — replace with real implementation.
export default function Placeholder(){ return null; }


