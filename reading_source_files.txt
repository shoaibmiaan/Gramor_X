Reading Source Files Dump - Generated on 02/18/2026 02:50:21
================================================================================

================================================================================
FILE: C:\Users\DELL\Documents\Gramor_X\pages\admin\reading.tsx
================================================================================

import React, { useEffect, useMemo, useState } from 'react';
import Head from 'next/head';

import { RoleGuard } from '@/components/auth/RoleGuard';
import { Container } from '@/components/design-system/Container';
import { Input } from '@/components/design-system/Input';
import { Textarea } from '@/components/design-system/Textarea';
import { Button } from '@/components/design-system/Button';
import { Select } from '@/components/design-system/Select';
import { useToast } from '@/components/design-system/Toaster';

const QUESTION_TYPES = [
  { value: 'mcq', label: 'Multiple choice' },
  { value: 'tfng', label: 'True / False / Not Given' },
  { value: 'short', label: 'Short answer' },
] as const;

const TFNG_OPTIONS = ['True', 'False', 'Not Given'] as const;

const MAX_OPTIONS = 6;

const defaultMcqOptions = ['', '', '', ''];

type QuestionType = (typeof QUESTION_TYPES)[number]['value'];

type QuestionDraft = {
  id: string;
  type: QuestionType;
  prompt: string;
  options: string[];
  correctIndex: number;
  tfngAnswer: typeof TFNG_OPTIONS[number];
  shortAnswers: string;
};

type ExistingTest = {
  slug: string;
  title: string;
  difficulty: string;
  words: number | null;
  questionCount: number;
  createdAt: string | null;
};

const createQuestion = (seed: number): QuestionDraft => ({
  id: `q-${Date.now()}-${seed}`,
  type: 'mcq',
  prompt: '',
  options: [...defaultMcqOptions],
  correctIndex: 0,
  tfngAnswer: 'True',
  shortAnswers: '',
});

function slugify(input: string) {
  const base = input
    .toLowerCase()
    .replace(/[^a-z0-9]+/g, '-')
    .replace(/^-+|-+$/g, '')
    .replace(/-{2,}/g, '-')
    .slice(0, 80);
  return base || 'reading-test';
}

const AdminReadingContent: React.FC = () => {
  const [title, setTitle] = useState('');
  const [customSlug, setCustomSlug] = useState('');
  const [difficulty, setDifficulty] = useState('Academic');
  const [passage, setPassage] = useState('');
  const [questions, setQuestions] = useState<QuestionDraft[]>([createQuestion(1)]);
  const [saving, setSaving] = useState(false);
  const [loadingList, setLoadingList] = useState(false);
  const [existing, setExisting] = useState<ExistingTest[]>([]);

  const { success, error: toastError } = useToast();

  useEffect(() => {
    let cancelled = false;
    const load = async () => {
      setLoadingList(true);
      try {
        const res = await fetch('/api/admin/reading/tests');
        if (!res.ok) throw new Error('Failed to load passages');
        const data = (await res.json()) as ExistingTest[];
        if (!cancelled) setExisting(data);
      } catch (err: any) {
        if (!cancelled) {
          toastError(err?.message ?? 'Could not load existing passages');
        }
      } finally {
        if (!cancelled) setLoadingList(false);
      }
    };
    load();
    return () => {
      cancelled = true;
    };
  }, [toastError]);

  const suggestedSlug = useMemo(() => slugify(customSlug || title), [customSlug, title]);

  const wordCount = useMemo(() => {
    return passage
      .trim()
      .split(/\s+/)
      .filter(Boolean).length;
  }, [passage]);

  const validationError = useMemo(() => {
    if (!title.trim()) return 'Title is required';
    if (!passage.trim()) return 'Passage text is required';
    for (const q of questions) {
      if (!q.prompt.trim()) return 'Every question needs a prompt';
      if (q.type === 'mcq') {
        const trimmed = q.options.map((opt) => opt.trim());
        const filled = trimmed.filter(Boolean);
        if (filled.length < 2) return 'Each MCQ must have at least two filled options';
        if (trimmed.some((opt) => !opt)) return 'Fill all MCQ options or remove the extras';
        if (!trimmed[q.correctIndex]) return 'Pick a valid correct option for each MCQ';
      }
      if (q.type === 'short') {
        const answers = q.shortAnswers
          .split(/\r?\n/)
          .map((ans) => ans.trim())
          .filter(Boolean);
        if (answers.length === 0) return 'Short-answer questions need at least one accepted answer';
      }
    }
    return null;
  }, [passage, questions, title]);

  const resetForm = () => {
    setTitle('');
    setCustomSlug('');
    setDifficulty('Academic');
    setPassage('');
    setQuestions([createQuestion(1)]);
  };

  const addQuestion = () => {
    setQuestions((prev) => [...prev, createQuestion(prev.length + 1)]);
  };

  const removeQuestion = (id: string) => {
    setQuestions((prev) => (prev.length === 1 ? prev : prev.filter((q) => q.id !== id)));
  };

  const updateQuestion = (id: string, updates: Partial<QuestionDraft>) => {
    setQuestions((prev) => prev.map((q) => (q.id === id ? { ...q, ...updates } : q)));
  };

  const updateOption = (id: string, index: number, value: string) => {
    setQuestions((prev) =>
      prev.map((q) => {
        if (q.id !== id) return q;
        const next = [...q.options];
        next[index] = value;
        return { ...q, options: next };
      }),
    );
  };

  const addOption = (id: string) => {
    setQuestions((prev) =>
      prev.map((q) => {
        if (q.id !== id) return q;
        if (q.options.length >= MAX_OPTIONS) return q;
        return { ...q, options: [...q.options, ''] };
      }),
    );
  };

  const removeOption = (id: string, index: number) => {
    setQuestions((prev) =>
      prev.map((q) => {
        if (q.id !== id) return q;
        if (q.options.length <= 2) return q;
        const next = q.options.filter((_, idx) => idx !== index);
        const nextCorrect = q.correctIndex >= next.length ? 0 : q.correctIndex;
        return { ...q, options: next, correctIndex: nextCorrect };
      }),
    );
  };

  const handleSubmit = async (event: React.FormEvent) => {
    event.preventDefault();
    const error = validationError;
    if (error) {
      toastError(error);
      return;
    }

    setSaving(true);
    try {
      const payload = {
        title: title.trim(),
        slug: customSlug.trim() || undefined,
        difficulty,
        passage: passage.trim(),
        questions: questions.map((q) => {
          if (q.type === 'mcq') {
            return {
              type: 'mcq' as const,
              prompt: q.prompt.trim(),
              options: q.options.map((opt) => opt.trim()),
              correctIndex: q.correctIndex,
            };
          }
          if (q.type === 'tfng') {
            return {
              type: 'tfng' as const,
              prompt: q.prompt.trim(),
              answer: q.tfngAnswer,
            };
          }
          const answers = q.shortAnswers
            .split(/\r?\n/)
            .map((ans) => ans.trim())
            .filter(Boolean);
          return {
            type: 'short' as const,
            prompt: q.prompt.trim(),
            answers,
          };
        }),
      };

      const res = await fetch('/api/admin/reading/tests', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(payload),
      });

      const json = await res.json().catch(() => ({ error: 'Failed to save test' }));

      if (!res.ok || json?.error) {
        toastError(json?.error ?? 'Failed to save test');
        return;
      }

      const newEntry: ExistingTest = {
        slug: json.slug,
        title: payload.title,
        difficulty,
        words: wordCount || null,
        questionCount: payload.questions.length,
        createdAt: new Date().toISOString(),
      };

      success('Reading test created');
      setExisting((prev) => [newEntry, ...prev]);
      resetForm();
    } catch (err: any) {
      toastError(err?.message ?? 'Failed to save test');
    } finally {
      setSaving(false);
    }
  };

  return (
    <>
      <Head>
        <title>Admin Â· Reading Builder</title>
      </Head>
      <Container className="py-10">
        <div className="mb-10 space-y-2">
          <p className="text-small uppercase tracking-wide text-mutedText">Reading</p>
          <h1 className="text-3xl font-semibold">Create Reading Mock Tests</h1>
          <p className="max-w-2xl text-muted-foreground">
            Draft a passage, add comprehension questions, and publish them for students. Teachers and admins share this
            workspace.
          </p>
        </div>

        <form
          onSubmit={handleSubmit}
          className="grid gap-8 lg:grid-cols-[minmax(0,2fr)_minmax(0,1fr)]"
        >
          <div className="space-y-6">
            <section className="rounded-3xl border border-border bg-card/60 p-6 shadow-sm">
              <h2 className="text-xl font-semibold">Passage details</h2>
              <p className="mt-1 text-small text-muted-foreground">
                Set the title, difficulty, and passage body. We auto-calculate an estimated slug and word count.
              </p>

              <div className="mt-6 space-y-4">
                <Input
                  label="Title"
                  placeholder="IELTS Reading Practice Test #1"
                  value={title}
                  onChange={(e) => setTitle(e.target.value)}
                  required
                />

                <Input
                  label="Custom slug"
                  hint={`Will be saved as â€œ${suggestedSlug}â€`}
                  value={customSlug}
                  onChange={(e) => setCustomSlug(e.target.value)}
                />

                <Select
                  label="Difficulty"
                  value={difficulty}
                  onChange={(e) => setDifficulty(e.target.value)}
                >
                  <option value="Academic">Academic</option>
                  <option value="General">General</option>
                  <option value="Easy">Easy</option>
                  <option value="Medium">Medium</option>
                  <option value="Hard">Hard</option>
                </Select>

                <Textarea
                  label="Passage text"
                  hint="Supports long-form text or Markdown."
                  value={passage}
                  onChange={(e) => setPassage(e.target.value)}
                  rows={14}
                />

                <div className="text-small text-muted-foreground">
                  <span className="font-medium text-foreground">Word count:</span> {wordCount}
                </div>
              </div>
            </section>

            <section className="rounded-3xl border border-border bg-card/60 p-6 shadow-sm">
              <div className="flex flex-wrap items-center justify-between gap-4">
                <div>
                  <h2 className="text-xl font-semibold">Questions</h2>
                  <p className="mt-1 text-small text-muted-foreground">
                    Support MCQ, True/False/Not Given, and short answers. More types can be added later.
                  </p>
                </div>
                <Button type="button" variant="soft" tone="primary" size="sm" onClick={addQuestion}>
                  Add question
                </Button>
              </div>

              <div className="mt-6 space-y-6">
                {questions.map((q, index) => (
                  <div key={q.id} className="rounded-2xl border border-border/60 bg-background/50 p-5 shadow-sm">
                    <div className="mb-4 flex flex-wrap items-start justify-between gap-4">
                      <div>
                        <p className="text-sm font-semibold text-muted-foreground">Question {index + 1}</p>
                        <Select
                          className="mt-2"
                          value={q.type}
                          onChange={(e) => {
                            const nextType = e.target.value as QuestionType;
                            updateQuestion(q.id, {
                              type: nextType,
                              // reset type-specific fields
                              options: nextType === 'mcq' ? [...defaultMcqOptions] : q.options,
                              correctIndex: 0,
                              tfngAnswer: 'True',
                              shortAnswers: '',
                            });
                          }}
                          size="sm"
                        >
                          {QUESTION_TYPES.map((opt) => (
                            <option key={opt.value} value={opt.value}>
                              {opt.label}
                            </option>
                          ))}
                        </Select>
                      </div>
                      {questions.length > 1 && (
                        <Button type="button" variant="ghost" size="sm" onClick={() => removeQuestion(q.id)}>
                          Remove
                        </Button>
                      )}
                    </div>

                    <Textarea
                      label="Prompt"
                      value={q.prompt}
                      onChange={(e) => updateQuestion(q.id, { prompt: e.target.value })}
                      size="sm"
                    />

                    {q.type === 'mcq' && (
                      <div className="mt-4 space-y-4">
                        {q.options.map((opt, optIdx) => (
                          <div
                            key={`${q.id}-opt-${optIdx}`}
                            className="rounded-xl border border-border/60 bg-card/40 p-4"
                          >
                            <div className="flex flex-wrap items-center justify-between gap-3">
                              <p className="text-small font-medium text-muted-foreground">Option {String.fromCharCode(65 + optIdx)}</p>
                              <div className="flex items-center gap-2">
                                <Button
                                  type="button"
                                  size="sm"
                                  variant="soft"
                                  tone={q.correctIndex === optIdx ? 'primary' : 'default'}
                                  onClick={() => updateQuestion(q.id, { correctIndex: optIdx })}
                                >
                                  {q.correctIndex === optIdx ? 'Correct answer' : 'Mark correct'}
                                </Button>
                                {q.options.length > 2 && (
                                  <Button
                                    type="button"
                                    variant="ghost"
                                    size="sm"
                                    onClick={() => removeOption(q.id, optIdx)}
                                  >
                                    Remove
                                  </Button>
                                )}
                              </div>
                            </div>
                            <Input
                              className="mt-3"
                              placeholder="Answer text"
                              value={opt}
                              onChange={(e) => updateOption(q.id, optIdx, e.target.value)}
                              size="sm"
                            />
                          </div>
                        ))}

                        {q.options.length < MAX_OPTIONS && (
                          <Button type="button" variant="soft" size="sm" onClick={() => addOption(q.id)}>
                            Add option
                          </Button>
                        )}
                      </div>
                    )}

                    {q.type === 'tfng' && (
                      <div className="mt-4">
                        <Select
                          label="Correct answer"
                          value={q.tfngAnswer}
                          onChange={(e) => updateQuestion(q.id, { tfngAnswer: e.target.value as QuestionDraft['tfngAnswer'] })}
                          size="sm"
                        >
                          {TFNG_OPTIONS.map((opt) => (
                            <option key={opt} value={opt}>
                              {opt}
                            </option>
                          ))}
                        </Select>
                      </div>
                    )}

                    {q.type === 'short' && (
                      <Textarea
                        className="mt-4"
                        label="Accepted answers"
                        hint="One per line"
                        value={q.shortAnswers}
                        onChange={(e) => updateQuestion(q.id, { shortAnswers: e.target.value })}
                        size="sm"
                      />
                    )}
                  </div>
                ))}
              </div>

              <div className="mt-8 flex justify-end">
                <Button type="submit" loading={saving} loadingText="Saving" disabled={Boolean(validationError)}>
                  Save reading test
                </Button>
              </div>
            </section>
          </div>

          <aside className="space-y-6">
            <div className="rounded-3xl border border-border bg-card/60 p-6 shadow-sm">
              <h3 className="text-lg font-semibold">Existing passages</h3>
              <p className="mt-1 text-small text-muted-foreground">
                Recent passages saved to Supabase. Refresh to see updates from other teammates.
              </p>

              <div className="mt-4 space-y-3">
                {loadingList && <p className="text-small text-muted-foreground">Loadingâ€¦</p>}
                {!loadingList && existing.length === 0 && (
                  <p className="text-small text-muted-foreground">No passages yet.</p>
                )}
                {!loadingList &&
                  existing.map((item) => (
                    <div
                      key={item.slug}
                      className="rounded-2xl border border-border/60 bg-background/40 px-4 py-3 text-small"
                    >
                      <p className="font-medium text-foreground">{item.title}</p>
                      <p className="text-muted-foreground">Slug: {item.slug}</p>
                      <p className="text-muted-foreground">Difficulty: {item.difficulty}</p>
                      <p className="text-muted-foreground">
                        {item.questionCount} questions Â· {item.words ?? 'â€”'} words
                      </p>
                      {item.createdAt && (
                        <p className="text-muted-foreground">
                          Created {new Date(item.createdAt).toLocaleString()}
                        </p>
                      )}
                    </div>
                  ))}
              </div>
            </div>
          </aside>
        </form>
      </Container>
    </>
  );
};

const AdminReadingPage: React.FC = () => {
  return (
    <RoleGuard allow={['admin', 'teacher']}>
      <AdminReadingContent />
    </RoleGuard>
  );
};

export default AdminReadingPage;



================================================================================
FILE: C:\Users\DELL\Documents\Gramor_X\pages\admin\content\reading.tsx
================================================================================

// pages/admin/content/reading.tsx
import React, { useEffect, useState } from 'react';
import Head from 'next/head';
import { AdminGuard } from '@/components/auth/AdminGuard';
import { supabaseBrowser } from '@/lib/supabaseBrowser';
import { Container } from '@/components/design-system/Container';

type ReadingTest = {
  id: string;
  title: string;
  level: string | null;
  created_at: string;
};

export default function ReadingContent() {
  const [tests, setTests] = useState<ReadingTest[]>([]);
  const [title, setTitle] = useState('');
  const [level, setLevel] = useState('Academic');
  const [busy, setBusy] = useState(false);

  const refresh = async () => {
    const { data, error } = await supabaseBrowser
      .from('reading_tests')
      .select('id,title,level,created_at')
      .order('created_at', { ascending: false });
    if (!error && data) setTests(data as ReadingTest[]);
  };

  useEffect(() => { refresh(); }, []);

  const createTest = async (e: React.FormEvent) => {
    e.preventDefault();
    if (!title.trim()) return;
    setBusy(true);
    const { data: userData } = await supabaseBrowser.auth.getUser();
    const created_by = userData?.user?.id ?? null;
    const { error } = await supabaseBrowser.from('reading_tests').insert([{ title, level, created_by }]);
    setBusy(false);
    if (!error) {
      setTitle('');
      setLevel('Academic');
      await refresh();
    } else {
      alert(error.message);
    }
  };

  const remove = async (id: string) => {
    if (!confirm('Delete this test?')) return;
    const { error } = await supabaseBrowser.from('reading_tests').delete().eq('id', id);
    if (error) { alert(error.message); return; }
    await refresh();
  };

  return (
    <AdminGuard>
      <Head><title>Admin Â· Reading Content</title></Head>
      <Container className="py-8">
        <h1 className="text-h2 font-semibold mb-6">Reading â€” Tests</h1>

        <form onSubmit={createTest} className="rounded-2xl border p-4 grid gap-3 sm:grid-cols-3">
          <input
            className="sm:col-span-2 rounded-xl border px-3 py-2 bg-transparent"
            placeholder="Test title (e.g., Academic Demo 01)"
            value={title}
            onChange={(e) => setTitle(e.target.value)}
          />
          <select
            className="rounded-xl border px-3 py-2 bg-transparent"
            value={level}
            onChange={(e) => setLevel(e.target.value)}
          >
            <option>Academic</option>
            <option>General</option>
            <option>A1</option><option>A2</option>
            <option>B1</option><option>B2</option>
            <option>C1</option><option>C2</option>
          </select>
          <div className="sm:col-span-3 flex justify-end">
            <button
              disabled={busy}
              className="rounded-xl border px-4 py-2 hover:shadow-sm disabled:opacity-50"
            >
              {busy ? 'Creatingâ€¦' : 'Create Test'}
            </button>
          </div>
        </form>

        <div className="mt-6 rounded-2xl border overflow-hidden">
          <table className="w-full text-small">
            <thead className="bg-black/5 dark:bg-white/5">
              <tr>
                <th className="text-left p-3">Title</th>
                <th className="text-left p-3">Level</th>
                <th className="text-left p-3">Created</th>
                <th className="text-right p-3">Actions</th>
              </tr>
            </thead>
            <tbody>
              {tests.map(t => (
                <tr key={t.id} className="border-t">
                  <td className="p-3">{t.title}</td>
                  <td className="p-3">{t.level}</td>
                  <td className="p-3">{new Date(t.created_at).toLocaleString()}</td>
                  <td className="p-3 text-right">
                    {/* Future: Edit builder for passages/questions */}
                    <button
                      onClick={() => remove(t.id)}
                      className="rounded-lg border px-3 py-1 hover:shadow-sm"
                    >
                      Delete
                    </button>
                  </td>
                </tr>
              ))}
              {tests.length === 0 && (
                <tr><td colSpan={4} className="p-6 text-center opacity-70">No tests yet.</td></tr>
              )}
            </tbody>
          </table>
        </div>
      </Container>
    </AdminGuard>
  );
}



================================================================================
FILE: C:\Users\DELL\Documents\Gramor_X\pages\api\ai\generate-reading.ts
================================================================================

// pages/api/ai/generate-reading.ts
import type { NextApiRequest, NextApiResponse } from 'next';

const API_KEY = process.env.OPENAI_API_KEY || '';
const MODEL = process.env.GX_AI_MODEL || 'gpt-4o-mini';

type In = { theme?: string; difficulty?: 'Easy'|'Medium'|'Hard'; length?: 'short'|'medium'; types?: Array<'tfng'|'mcq'|'matching'|'short'> };
type Out = {
  passage: string;
  questions: Array<{
    type: 'tfng'|'mcq'|'matching'|'short';
    prompt: string;
    options?: string[];
    answer?: string; // keep for staff; strip for users
    explanation?: string;
  }>;
};

export default async function handler(req: NextApiRequest, res: NextApiResponse<Out | { error: string }>) {
  try {
    if (req.method !== 'POST') return res.status(405).json({ error: 'Method not allowed' });

    const body = (req.body || {}) as In;
    const theme = body.theme || 'Contemporary science';
    const difficulty = body.difficulty || 'Medium';
    const types = (body.types && body.types.length) ? body.types.slice(0, 3) : ['mcq','tfng'];

    if (!API_KEY) {
      return res.status(200).json({
        passage: 'Sample passage (developer mode): Cities foster biodiversity in unexpected niches...',
        questions: [
          { type: 'mcq', prompt: 'Main idea?', options: ['A','B','C','D'], answer: 'B', explanation: '...' },
          { type: 'tfng', prompt: 'Urban parks always increase species richness.', answer: 'False', explanation: '...' },
        ],
      });
    }

    const sys = [
      'Generate an IELTS-style reading passage and 6 questions.',
      `Difficulty: ${difficulty}. Types allowed: ${types.join(', ')}.`,
      'Keep one paragraph per 120â€“150 words; total ~350â€“450 words.',
      'Return strict JSON with keys: passage (string), questions (array).',
      'For each question include: type, prompt, options (if MCQ), answer, explanation.',
      'Avoid copyrighted or real exam content.'
    ].join(' ');

    const user = `Theme: ${theme}`;

    const r = await fetch('https://api.openai.com/v1/chat/completions', {
      method: 'POST',
      headers: { Authorization: `Bearer ${API_KEY}`, 'Content-Type': 'application/json' },
      body: JSON.stringify({
        model: MODEL,
        response_format: { type: 'json_object' },
        messages: [
          { role: 'system', content: sys },
          { role: 'user', content: user },
        ],
        temperature: 0.6,
        max_tokens: 800,
      }),
    });

    if (!r.ok) return res.status(500).json({ error: `Provider error (${r.status})` });
    const j = await r.json();
    const text = j?.choices?.[0]?.message?.content || '{}';
    const parsed = JSON.parse(text);
    return res.status(200).json(parsed);
  } catch (e: any) {
    return res.status(500).json({ error: e?.message || 'Internal error' });
  }
}



================================================================================
FILE: C:\Users\DELL\Documents\Gramor_X\pages\practice\reading.tsx
================================================================================

import { Container } from '@/components/design-system/Container';
import { Card } from '@/components/design-system/Card';
import { Badge } from '@/components/design-system/Badge';
import { Button } from '@/components/design-system/Button';
import { readingPracticeList } from '@/data/reading';
import { mockSections } from '@/data/mock';

const formatMinutes = (seconds: number) => `${Math.round(seconds / 60)} mins`;

const quickActions = [
  {
    title: 'Mock test hub',
    description: 'Three long passages with review tools that surface the exact evidence.',
    href: '/mock/reading',
  },
  {
    title: 'Passage library',
    description: 'Target question families and micro-drills for Academic & General Training.',
    href: '/reading',
  },
  {
    title: 'Progress insights',
    description: 'Check accuracy by passage and get difficulty-adjusted band predictions.',
    href: '/progress',
  },
];

const readingStrategies = [
  {
    title: 'Highlight & note toolkit',
    description: 'Colour-code supporting sentences and leave reminders while you read.',
  },
  {
    title: 'Keyword tracking',
    description: 'AI surfaces synonyms and paraphrases that triggered each answer.',
  },
  {
    title: 'Adaptive pacing',
    description: 'Timer nudges help you allocate time per passage based on your past results.',
  },
];

const featuredSets = readingPracticeList.slice(0, 4);

export default function ReadingPracticePage() {
  const totalQuestions = mockSections.reading.questions.length;

  return (
    <section className="py-24 bg-lightBg dark:bg-gradient-to-br dark:from-dark/80 dark:to-darker/90">
      <Container>
        <div className="max-w-3xl space-y-6">
          <div>
            <h1 className="font-slab text-display mb-3 text-gradient-primary">Reading Practice</h1>
            <p className="text-grayish">
              Move from skimming to evidence-based answers. Combine targeted drills with full papers and analytics designed to push you past band 7.
            </p>
          </div>

          <div className="grid gap-4 sm:grid-cols-3">
            {quickActions.map((action) => (
              <Card key={action.title} className="card-surface rounded-ds-2xl p-4 flex flex-col">
                <h2 className="text-h5 font-semibold text-foreground">{action.title}</h2>
                <p className="mt-2 text-sm text-muted-foreground flex-1">{action.description}</p>
                <Button href={action.href} variant="ghost" className="mt-4 rounded-ds self-start">
                  Open
                </Button>
              </Card>
            ))}
          </div>
        </div>

        <div className="mt-16">
          <h2 className="text-h3 font-semibold text-foreground">Featured reading papers</h2>
          <p className="mt-2 text-muted-foreground max-w-2xl">
            Focus on your biggest blind spots. After each attempt you receive paragraph references, summary notes, and revision flashcards automatically.
          </p>

          <div className="mt-8 grid gap-6 md:grid-cols-2 xl:grid-cols-4">
            {featuredSets.map((paper) => (
              <Card key={paper.id} className="card-surface rounded-ds-2xl p-6 h-full flex flex-col">
                <div>
                  <div className="flex items-center justify-between">
                    <h3 className="text-h5 font-semibold text-foreground">{paper.title}</h3>
                    <Badge variant="info" size="sm">{formatMinutes(paper.durationSec)}</Badge>
                  </div>
                  <p className="mt-2 text-sm text-muted-foreground">{paper.passages} passages Â· {paper.totalQuestions} questions</p>
                </div>
                <Button href={`/mock/reading/${paper.id}`} variant="primary" className="mt-6 rounded-ds">
                  Start now
                </Button>
              </Card>
            ))}
          </div>
        </div>

        <div className="mt-16 grid gap-6 md:grid-cols-3">
          {readingStrategies.map((item) => (
            <Card key={item.title} className="card-surface rounded-ds-2xl p-6 h-full">
              <h3 className="text-h5 font-semibold text-foreground">{item.title}</h3>
              <p className="mt-2 text-sm text-muted-foreground">{item.description}</p>
            </Card>
          ))}
        </div>

        <div className="mt-16">
          <Card className="card-surface rounded-ds-2xl p-6 md:flex md:items-center md:justify-between">
            <div>
              <h2 className="text-h4 font-semibold text-foreground">Master all {totalQuestions} question slots</h2>
              <p className="mt-2 text-sm text-muted-foreground">
                Our review engine spots which question families cost you marks and queues personalised drills for the next session.
              </p>
            </div>
            <Button href="/mock/reading" variant="primary" className="mt-4 rounded-ds md:mt-0">
              Browse mock tests
            </Button>
          </Card>
        </div>
      </Container>
    </section>
  );
}



================================================================================
FILE: C:\Users\DELL\Documents\Gramor_X\components\exam\ReadingPassage.tsx
================================================================================

import React, { useCallback, useEffect, useMemo, useRef, useState } from 'react';

type HighlightRange = {
  id: string;
  start: number;
  end: number;
  color: string;
  noteText?: string | null;
};

type SelectionPayload = {
  start: number;
  end: number;
  text: string;
  noteText?: string;
};

type ReadingPassageProps = {
  text: string;
  highlights: HighlightRange[];
  onCreateHighlight: (payload: SelectionPayload) => void;
  onCreateNote: (payload: SelectionPayload) => void;
  onHighlightFocus?: (id: string) => void;
};

type SelectionState = {
  start: number;
  end: number;
  text: string;
  rect: DOMRect;
};

const COLOR_CLASS: Record<string, string> = {
  warning: 'bg-warning/30 border-warning/50',
  primary: 'bg-primary/20 border-primary/60',
  accent: 'bg-accent/20 border-accent/60',
};

function clampPosition(value: number, min: number, max: number) {
  if (Number.isNaN(value)) return min;
  return Math.min(Math.max(value, min), max);
}

const TOOLBAR_WIDTH = 260;
const TOOLBAR_PADDING = 16;

export const ReadingPassage: React.FC<ReadingPassageProps> = ({
  text,
  highlights,
  onCreateHighlight,
  onCreateNote,
  onHighlightFocus,
}) => {
  const containerRef = useRef<HTMLDivElement | null>(null);
  const toolbarRef = useRef<HTMLDivElement | null>(null);
  const [selection, setSelection] = useState<SelectionState | null>(null);
  const [noteDraft, setNoteDraft] = useState('');
  const [isNoteComposerOpen, setNoteComposerOpen] = useState(false);

  const sortedHighlights = useMemo(() => {
    return [...highlights]
      .filter((item) => item.end > item.start)
      .sort((a, b) => a.start - b.start);
  }, [highlights]);

  const segments = useMemo(() => {
    const nodes: Array<{ key: string; content: string; highlight?: HighlightRange }> = [];
    let cursor = 0;
    for (const highlight of sortedHighlights) {
      const start = Math.max(0, Math.min(highlight.start, text.length));
      const end = Math.max(start, Math.min(highlight.end, text.length));
      if (start > cursor) {
        nodes.push({ key: `text-${cursor}-${start}`, content: text.slice(cursor, start) });
      }
      if (end > start) {
        nodes.push({ key: `hl-${highlight.id}`, content: text.slice(start, end), highlight });
      }
      cursor = Math.max(cursor, end);
    }
    if (cursor < text.length) {
      nodes.push({ key: `text-${cursor}-${text.length}`, content: text.slice(cursor) });
    }
    if (nodes.length === 0) {
      nodes.push({ key: 'plain', content: text });
    }
    return nodes;
  }, [sortedHighlights, text]);

  const clearSelection = useCallback(() => {
    if (typeof window !== 'undefined') {
      const active = window.getSelection();
      if (active) {
        try {
          active.removeAllRanges();
        } catch {
          // ignore
        }
      }
    }
    setSelection(null);
    setNoteComposerOpen(false);
    setNoteDraft('');
  }, []);

  const computeSelection = useCallback(() => {
    if (typeof window === 'undefined') return;
    const root = containerRef.current;
    if (!root) return;

    const selectionObj = window.getSelection();
    if (!selectionObj || selectionObj.rangeCount === 0 || selectionObj.isCollapsed) {
      setSelection(null);
      setNoteComposerOpen(false);
      setNoteDraft('');
      return;
    }

    const range = selectionObj.getRangeAt(0);
    if (!root.contains(range.startContainer) || !root.contains(range.endContainer)) {
      setSelection(null);
      setNoteComposerOpen(false);
      setNoteDraft('');
      return;
    }

    const cloned = range.cloneRange();
    cloned.selectNodeContents(root);
    cloned.setEnd(range.startContainer, range.startOffset);
    const leading = cloned.toString();
    const selectedText = range.toString();
    const start = leading.length;
    const end = start + selectedText.length;

    if (selectedText.trim().length === 0 || end <= start) {
      setSelection(null);
      setNoteComposerOpen(false);
      setNoteDraft('');
      return;
    }

    const rect = range.getBoundingClientRect();
    setSelection({ start, end, text: selectedText, rect });
    setNoteComposerOpen(false);
    setNoteDraft('');
  }, []);

  useEffect(() => {
    if (typeof window === 'undefined') return;
    const handler = () => computeSelection();
    document.addEventListener('selectionchange', handler);
    return () => {
      document.removeEventListener('selectionchange', handler);
    };
  }, [computeSelection]);

  useEffect(() => {
    if (!selection) return;
    if (typeof window === 'undefined') return;

    const updateRect = () => {
      const active = window.getSelection();
      if (!active || active.rangeCount === 0) return;
      const range = active.getRangeAt(0);
      setSelection((prev) => (prev ? { ...prev, rect: range.getBoundingClientRect() } : prev));
    };

    window.addEventListener('scroll', updateRect, true);
    window.addEventListener('resize', updateRect);
    return () => {
      window.removeEventListener('scroll', updateRect, true);
      window.removeEventListener('resize', updateRect);
    };
  }, [selection]);

  const handleCreateHighlight = useCallback(() => {
    if (!selection) return;
    onCreateHighlight({ start: selection.start, end: selection.end, text: selection.text });
    clearSelection();
  }, [selection, onCreateHighlight, clearSelection]);

  const handleOpenNoteComposer = useCallback(() => {
    if (!selection) return;
    setNoteComposerOpen(true);
    setNoteDraft('');
  }, [selection]);

  const handleSaveNote = useCallback(() => {
    if (!selection) return;
    const trimmed = noteDraft.trim();
    if (!trimmed) return;
    onCreateNote({ start: selection.start, end: selection.end, text: selection.text, noteText: trimmed });
    clearSelection();
  }, [selection, noteDraft, onCreateNote, clearSelection]);

  const toolbarPosition = useMemo(() => {
    if (!selection) return { top: 0, left: 0 };
    if (typeof window === 'undefined') return { top: 0, left: 0 };
    const viewportWidth = window.innerWidth || 0;
    const desiredLeft = selection.rect.left + selection.rect.width / 2 - TOOLBAR_WIDTH / 2;
    const left = clampPosition(desiredLeft, TOOLBAR_PADDING, Math.max(TOOLBAR_PADDING, viewportWidth - TOOLBAR_WIDTH - TOOLBAR_PADDING));
    const top = clampPosition(selection.rect.top - 56, TOOLBAR_PADDING, Math.max(TOOLBAR_PADDING, selection.rect.top + selection.rect.height + 8));
    return { top, left };
  }, [selection]);

  useEffect(() => {
    const node = toolbarRef.current;
    if (!node) return;
    node.style.setProperty('--reading-toolbar-top', `${toolbarPosition.top}px`);
    node.style.setProperty('--reading-toolbar-left', `${toolbarPosition.left}px`);
  }, [toolbarPosition]);

  return (
    <div className="relative">
      {selection && (
        <div
          ref={toolbarRef}
          className="fixed left-[var(--reading-toolbar-left)] top-[var(--reading-toolbar-top)] z-40 flex w-[260px] flex-col gap-2"
        >
          <div className="flex items-center justify-between gap-2 rounded-full border border-border bg-popover px-3 py-1 text-small text-popover-foreground shadow-lg">
            <button
              type="button"
              onClick={handleCreateHighlight}
              className="rounded-full bg-primary px-3 py-1 text-background transition hover:opacity-90 focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 focus-visible:ring-offset-popover"
            >
              Highlight
            </button>
            <button
              type="button"
              onClick={handleOpenNoteComposer}
              className="rounded-full bg-secondary px-3 py-1 text-background transition hover:opacity-90 focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 focus-visible:ring-offset-popover"
            >
              Add note
            </button>
            <button
              type="button"
              onClick={clearSelection}
              aria-label="Cancel selection"
              className="rounded-full border border-border px-3 py-1 text-foreground transition hover:border-danger hover:text-danger focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 focus-visible:ring-offset-popover"
            >
              Ã—
            </button>
          </div>
          {isNoteComposerOpen && (
            <div className="rounded-2xl border border-border bg-background p-3 shadow-xl">
              <label className="mb-2 block text-caption font-medium text-foreground/80" htmlFor="reading-note-input">
                Add a note
              </label>
              <textarea
                id="reading-note-input"
                value={noteDraft}
                onChange={(event) => setNoteDraft(event.target.value)}
                rows={3}
                className="w-full resize-none rounded-xl border border-border bg-background px-3 py-2 text-small focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 focus-visible:ring-offset-background"
                placeholder="Type your note"
              />
              <div className="mt-3 flex items-center justify-end gap-2">
                <button
                  type="button"
                  onClick={clearSelection}
                  className="rounded-full border border-border px-3 py-1 text-small text-foreground/70 hover:border-foreground/50"
                >
                  Cancel
                </button>
                <button
                  type="button"
                  onClick={handleSaveNote}
                  disabled={!noteDraft.trim()}
                  className="rounded-full bg-primary px-4 py-1 text-small font-medium text-background transition disabled:cursor-not-allowed disabled:opacity-60"
                >
                  Save
                </button>
              </div>
            </div>
          )}
        </div>
      )}

      <div
        ref={containerRef}
        className="whitespace-pre-wrap text-small leading-6 text-foreground/90"
        role="document"
        aria-label="Reading passage"
      >
        {segments.map((segment) => {
          if (!segment.highlight) {
            return (
              <span key={segment.key} className="whitespace-pre-wrap">
                {segment.content}
              </span>
            );
          }

          const colorClass = COLOR_CLASS[segment.highlight.color] ?? COLOR_CLASS.warning;

          return (
            <button
              type="button"
              key={segment.key}
              onClick={() => onHighlightFocus?.(segment.highlight!.id)}
              onKeyDown={(event) => {
                if (event.key === 'Enter' || event.key === ' ') {
                  event.preventDefault();
                  onHighlightFocus?.(segment.highlight!.id);
                }
              }}
              aria-label={
                segment.highlight.noteText
                  ? `Open note for highlighted text: ${segment.content}`
                  : `Highlighted text. Add a note.`
              }
              className={`inline whitespace-pre-wrap rounded-md border px-1 py-0.5 text-left transition focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 focus-visible:ring-offset-background ${colorClass}`}
            >
              {segment.content}
            </button>
          );
        })}
      </div>
    </div>
  );
};

export default ReadingPassage;



================================================================================
FILE: C:\Users\DELL\Documents\Gramor_X\components\reading\ReadingDashboard.tsx
================================================================================

// components/reading/ReadingDashboard.tsx
import React, { useEffect, useMemo, useState } from 'react';
import Link from 'next/link';

import { Container } from '@/components/design-system/Container';
import { Card } from '@/components/design-system/Card';
import { Badge } from '@/components/design-system/Badge';
import { Button } from '@/components/design-system/Button';
import { Alert } from '@/components/design-system/Alert';
import { Skeleton } from '@/components/design-system/Skeleton';
import { Icon } from '@/components/design-system/Icon';

type WeakArea = { label: string; reason: string; href: string; secondary?: string };
type TrendPoint = { date: string; score: number }; // 0..1
type TypeBreak = { type: 'tfng' | 'mcq' | 'matching' | 'short'; accuracy: number; attempts: number };
type TimeScore = { id: string; minutes: number; score: number };
type Recent = { slug: string; title: string; date: string; score: number; minutes: number; types: string[]; hrefReview: string };
type SavedItem = { slug: string; title: string; href: string };
type QueuedItem = { label: string; href: string };
type Quota = { dayUsed: number; dayLimit: number | null; monthUsed: number; monthLimit: number | null };

type DashboardPayload = {
  kpis?: {
    bandEstimate?: number;
    bandStd?: number;
    accuracy10?: number;       // 0..1
    accuracyDelta10?: number;  // -1..1
    avgSecPerQ?: number;
    streakDays?: number;
    totalPractices?: number;
  };
  trend?: TrendPoint[];
  byType?: TypeBreak[];
  timeVsScore?: TimeScore[];
  weakAreas?: WeakArea[];
  recent?: Recent[];
  saved?: SavedItem[];
  queued?: QueuedItem[];
  quota?: Quota;
};

type AIRecommend = {
  forecast?: { targetBand: number; etaDays: number; confidence: 'low'|'med'|'high'; rationale: string };
  actions: Array<{ label: string; reason: string; href: string; secondary?: string }>;
  tips?: string[];
};

type ForecastPayload = {
  bandNow: number;
  currentPct: number;
  targetBand: number;
  etaDays: number | null;
  confidence: 'low' | 'med' | 'high';
  rationale: string;
};

function pct(n?: number, digits = 0) {
  if (typeof n !== 'number' || !isFinite(n)) return 'â€”';
  return `${(n * 100).toFixed(digits)}%`;
}
function band(b?: number, std?: number) {
  if (typeof b !== 'number' || !isFinite(b)) return 'â€”';
  return typeof std === 'number' && isFinite(std) && std > 0 ? `${b.toFixed(1)} (Â±${std.toFixed(1)})` : b.toFixed(1);
}
function clamp01(n: number) {
  return Math.max(0, Math.min(1, Number.isFinite(n) ? n : 0));
}

export const ReadingDashboard: React.FC = () => {
  // Base dashboard
  const [data, setData] = useState<DashboardPayload | null>(null);
  const [err, setErr] = useState<string | null>(null);
  const [loading, setLoading] = useState(true);

  // AI Coach
  const [coach, setCoach] = useState<AIRecommend | null>(null);
  const [coachErr, setCoachErr] = useState<string | null>(null);
  const [coachLoading, setCoachLoading] = useState(true);

  // Forecast
  const [fc, setFc] = useState<ForecastPayload | null>(null);
  const [fcLoading, setFcLoading] = useState(true);

  // AI Summary
  const [summary, setSummary] = useState<string>('');
  const [summaryLoading, setSummaryLoading] = useState(true);

  useEffect(() => {
    let cancelled = false;
    (async () => {
      try {
        setLoading(true);
        const r = await fetch('/api/reading/dashboard');
        if (!r.ok) throw new Error(`Failed (${r.status})`);
        const j = (await r.json()) as DashboardPayload;
        if (!cancelled) { setData(j); setErr(null); }
      } catch (e: any) {
        if (!cancelled) { setErr(e?.message || 'Failed to load dashboard'); setData(null); }
      } finally {
        if (!cancelled) setLoading(false);
      }
    })();
    return () => { cancelled = true; };
  }, []);

  useEffect(() => {
    let cancelled = false;
    (async () => {
      try {
        setCoachLoading(true);
        const r = await fetch('/api/ai/recommend');
        if (!r.ok) throw new Error(`Failed (${r.status})`);
        const j = (await r.json()) as AIRecommend;
        if (!cancelled) { setCoach(j); setCoachErr(null); }
      } catch (e: any) {
        if (!cancelled) { setCoachErr(e?.message || 'AI coach unavailable'); setCoach(null); }
      } finally {
        if (!cancelled) setCoachLoading(false);
      }
    })();
    return () => { cancelled = true; };
  }, []);

  useEffect(() => {
    let cancelled = false;
    (async () => {
      try {
        setFcLoading(true);
        const r = await fetch('/api/reading/forecast?target=7.0');
        if (!r.ok) throw new Error(`Failed (${r.status})`);
        const j = (await r.json()) as ForecastPayload;
        if (!cancelled) setFc(j);
      } catch {
        if (!cancelled) setFc(null);
      } finally {
        if (!cancelled) setFcLoading(false);
      }
    })();
    return () => { cancelled = true; };
  }, []);

  useEffect(() => {
    let cancelled = false;
    (async () => {
      try {
        setSummaryLoading(true);
        const r = await fetch('/api/ai/summary');
        const j = await r.json();
        if (!cancelled) setSummary(j.summary || '');
      } catch {
        if (!cancelled) setSummary('');
      } finally {
        if (!cancelled) setSummaryLoading(false);
      }
    })();
    return () => { cancelled = true; };
  }, []);

  const k = data?.kpis ?? {};
  const acc10 = typeof k.accuracy10 === 'number' ? clamp01(k.accuracy10) : undefined;
  const accDelta = typeof k.accuracyDelta10 === 'number' ? k.accuracyDelta10 : undefined;

  const minutesRange = useMemo(() => {
    const xs = data?.timeVsScore?.map(d => d.minutes) ?? [];
    if (!xs.length) return { min: 0, max: 1 };
    const min = Math.min(...xs);
    const max = Math.max(...xs);
    return { min, max: Math.max(max, min + 1) };
  }, [data]);

  if (err) return <Alert variant="warning" title="Couldnâ€™t load dashboard">{err}</Alert>;

  if (loading || !data) {
    return (
      <div className="space-y-4">
        <Card className="p-4">
          <div className="grid grid-cols-2 gap-3 md:grid-cols-5">
            {Array.from({ length: 5 }).map((_, i) => (
              <div key={i} className="space-y-2">
                <Skeleton className="h-3 w-16" />
                <Skeleton className="h-6 w-20" />
              </div>
            ))}
          </div>
        </Card>
        <div className="grid gap-4 md:grid-cols-3">
          {Array.from({ length: 4 }).map((_, i) => (
            <Card key={i} className="p-5">
              <Skeleton className="h-5 w-1/2" />
              <Skeleton className="mt-3 h-24 w-full" />
            </Card>
          ))}
        </div>
      </div>
    );
  }

  return (
    <div className="space-y-6">
      {/* KPI STRIP */}
      <Card className="p-4 border-border/60 bg-white/70 backdrop-blur dark:bg-dark/70">
        <div className="grid grid-cols-2 gap-3 md:grid-cols-5">
          <div className="space-y-0.5">
            <div className="text-xs text-muted-foreground">Band (Reading)</div>
            <div className="text-lg font-semibold">{band(k.bandEstimate, k.bandStd)}</div>
          </div>
          <div className="space-y-0.5">
            <div className="text-xs text-muted-foreground">Accuracy (last 10)</div>
            <div className="flex items-center gap-2">
              <span className="text-lg font-semibold">{pct(acc10)}</span>
              {typeof accDelta === 'number' && (
                <Badge variant={accDelta >= 0 ? 'success' : 'danger'} size="xs">
                  {accDelta >= 0 ? '+' : ''}{(accDelta * 100).toFixed(0)}%
                </Badge>
              )}
            </div>
          </div>
          <div className="space-y-0.5">
            <div className="text-xs text-muted-foreground">Speed</div>
            <div className="text-lg font-semibold">
              {k.avgSecPerQ ? `${(k.avgSecPerQ / 60).toFixed(2)} min/Q` : 'â€”'}
            </div>
          </div>
          <div className="space-y-0.5">
            <div className="text-xs text-muted-foreground">Streak</div>
            <div className="text-lg font-semibold">{k.streakDays ?? 'â€”'}d</div>
          </div>
          <div className="space-y-0.5">
            <div className="text-xs text-muted-foreground">Completed</div>
            <div className="text-lg font-semibold">{k.totalPractices ?? 'â€”'}</div>
          </div>
        </div>
      </Card>

      {/* AI COACH */}
      <Card className="p-5 border-border/60 bg-white/70 backdrop-blur dark:bg-dark/70">
        <div className="mb-2 flex items-center justify-between">
          <h3 className="text-sm font-semibold inline-flex items-center gap-2">
            <Icon name="Sparkles" /> AI Coach
          </h3>
          <div className="text-xs text-muted-foreground">
            {coachLoading ? 'Generatingâ€¦' : coachErr ? 'Unavailable' : 'Personalized tips'}
          </div>
        </div>

        {coachLoading && (
          <div className="grid gap-3 md:grid-cols-3">
            {Array.from({ length: 3 }).map((_, i) => (
              <div key={i} className="space-y-2">
                <Skeleton className="h-4 w-3/4" />
                <Skeleton className="h-8 w-28" />
              </div>
            ))}
          </div>
        )}

        {!coachLoading && coach && (
          <div className="space-y-4">
            {coach.forecast && (
              <div className="flex items-center gap-3 text-sm">
                <Badge variant="info" size="sm">Forecast</Badge>
                <span>
                  {`â†’ Band ${coach.forecast.targetBand.toFixed(1)} in ~${coach.forecast.etaDays} days `}
                  <span className="text-muted-foreground">({coach.forecast.confidence} conf.)</span>
                </span>
                <span className="text-muted-foreground">â€” {coach.forecast.rationale}</span>
              </div>
            )}

            <div className="grid gap-3 md:grid-cols-3">
              {coach.actions.slice(0, 3).map(a => (
                <div key={a.label} className="flex items-center justify-between gap-3 rounded-lg border border-border/60 px-3 py-2">
                  <div className="min-w-0">
                    <div className="truncate text-sm font-medium">{a.label}</div>
                    <div className="truncate text-xs text-muted-foreground">{a.reason}</div>
                  </div>
                  <div className="shrink-0 flex gap-2">
                    <Link href={a.href}><Button variant="primary" size="sm" className="rounded-ds-xl">Start</Button></Link>
                    {a.secondary && <Link href={a.secondary}><Button variant="surface" size="sm" className="rounded-ds-xl">Review</Button></Link>}
                  </div>
                </div>
              ))}
            </div>

            {coach.tips?.length ? (
              <ul className="grid gap-2 md:grid-cols-3 text-xs text-muted-foreground">
                {coach.tips.slice(0, 3).map(t => (
                  <li key={t} className="rounded-md bg-muted px-2 py-1">{t}</li>
                ))}
              </ul>
            ) : null}
          </div>
        )}

        {!coachLoading && !coach && !coachErr && (
          <div className="text-xs text-muted-foreground">No suggestions yet.</div>
        )}

        {!coachLoading && coachErr && (
          <div className="text-xs text-muted-foreground">AI coach unavailable â€” try again later.</div>
        )}
      </Card>

      {/* FORECAST â€¢ HEATMAP â€¢ AI SUMMARY */}
      <div className="grid gap-4 md:grid-cols-3">
        {/* Forecast */}
        <Card className="p-5 border-border/60 bg-white/70 backdrop-blur dark:bg-dark/70">
          <div className="flex items-center justify-between">
            <h3 className="text-sm font-semibold inline-flex items-center gap-2">
              <Icon name="TrendingUp" /> Forecast
            </h3>
            {fc && (
              <Badge variant={fc.confidence === 'high' ? 'success' : fc.confidence === 'med' ? 'info' : 'warning'} size="xs">
                {fc.confidence} conf.
              </Badge>
            )}
          </div>
          {fcLoading ? (
            <div className="mt-2">
              <Skeleton className="h-4 w-1/3" />
              <Skeleton className="mt-2 h-3 w-2/3" />
            </div>
          ) : fc ? (
            <>
              <div className="mt-2 text-sm">
                Current: <span className="font-semibold">Band {fc.bandNow.toFixed(1)}</span>
                {` â†’ Target ${fc.targetBand.toFixed(1)} `}
                {fc.etaDays === null ? (
                  <span className="text-muted-foreground">â€¢ improve slope to reach target</span>
                ) : (
                  <span className="font-semibold">in ~{fc.etaDays} days</span>
                )}
              </div>
              <div className="mt-1 text-xs text-muted-foreground">{fc.rationale}</div>
              <div className="mt-3">
                <Link href="/reading?type=tfng" className="inline-flex">
                  <Button variant="surface" size="sm" className="rounded-ds-xl">Boost slope: weakest type</Button>
                </Link>
              </div>
            </>
          ) : (
            <div className="mt-2 text-xs text-muted-foreground">No history yet</div>
          )}
        </Card>

        {/* Heatmap */}
        <Card className="p-5 border-border/60 bg-white/70 backdrop-blur dark:bg-dark/70">
          <div className="mb-2 text-sm font-medium">Weak spot heatmap</div>
          <div className="grid grid-cols-2 gap-2 sm:grid-cols-4">
            {(data.byType ?? []).map((r) => {
              const acc = clamp01(r.accuracy);
              const intensity = Math.round(acc * 100);
              const bg = `hsla(260, 90%, ${95 - intensity * 0.4}%, 1)`;
              return (
                <div key={r.type} className="rounded-lg p-3" style={{ background: bg }}>
                  <div className="flex items-center justify-between">
                    <span className="text-xs font-medium capitalize">{r.type}</span>
                    <Badge size="xs" variant={acc >= 0.75 ? 'success' : acc >= 0.6 ? 'warning' : 'danger'}>
                      {(acc * 100).toFixed(0)}%
                    </Badge>
                  </div>
                  <div className="mt-1 text-[11px]">{r.attempts} attempts</div>
                </div>
              );
            })}
            {!data.byType?.length && <div className="col-span-4 text-xs text-muted-foreground">No data yet</div>}
          </div>
        </Card>

        {/* AI Summary */}
        <Card className="p-5 border-border/60 bg-white/70 backdrop-blur dark:bg-dark/70">
          <div className="text-sm font-semibold inline-flex items-center gap-2">
            <Icon name="Lightbulb" /> Recent Activity â€” AI Summary
          </div>
          {summaryLoading ? (
            <div className="mt-3 space-y-2">
              <Skeleton className="h-4 w-4/5" />
              <Skeleton className="h-4 w-3/5" />
            </div>
          ) : (
            <p className="mt-2 text-sm text-muted-foreground">{summary || 'No sessions yet.'}</p>
          )}
        </Card>
      </div>

      {/* PROGRESS (trend + time vs score) */}
      <Card className="p-5 border-border/60 bg-white/70 backdrop-blur dark:bg-dark/70">
        <div className="grid gap-4 md:grid-cols-2">
          {/* Trend sparkbars */}
          <div>
            <div className="mb-2 text-sm font-medium">Trend (last 20)</div>
            <div className="flex h-24 items-end gap-1">
              {(data.trend?.slice(-20) ?? []).map((p, i) => {
                const h = Math.max(6, Math.round(clamp01(p.score) * 88));
                return <div key={i} className="w-2 rounded-t bg-electricBlue/40" style={{ height: `${h}px` }} />;
              })}
              {!data.trend?.length && <div className="text-xs text-muted-foreground">No attempts yet</div>}
            </div>
          </div>

          {/* Time vs score */}
          <div>
            <div className="mb-2 text-sm font-medium">Time vs score</div>
            {data.timeVsScore?.length ? (
              <div className="relative h-28 w-full rounded border border-border/60">
                <div className="absolute left-1 top-1 text-[10px] text-muted-foreground">High score</div>
                <div className="absolute right-1 bottom-1 text-[10px] text-muted-foreground">More time</div>
                {(data.timeVsScore ?? []).slice(-40).map((pt) => {
                  const xPct = minutesRange.max === minutesRange.min
                    ? 50
                    : ((pt.minutes - minutesRange.min) / (minutesRange.max - minutesRange.min)) * 100;
                  const yPct = (1 - clamp01(pt.score)) * 100;
                  return (
                    <div
                      key={pt.id}
                      className="absolute h-2 w-2 rounded-full bg-purpleVibe/70"
                      style={{ left: `${xPct}%`, top: `${yPct}%`, transform: 'translate(-50%,-50%)' }}
                      title={`${pt.minutes}m â€¢ ${pct(pt.score)}`}
                    />
                  );
                })}
              </div>
            ) : (
              <div className="text-xs text-muted-foreground">No sessions yet</div>
            )}
          </div>
        </div>
      </Card>

      {/* RECENT */}
      <Card className="p-5 border-border/60 bg-white/70 backdrop-blur dark:bg-dark/70">
        <div className="flex items-center justify-between">
          <h3 className="text-sm font-semibold">Recent sessions</h3>
          <Link href="/reading/dashboard">
            <Button variant="surface" size="sm" className="rounded-ds-xl">Open full page</Button>
          </Link>
        </div>
        <div className="mt-3 overflow-x-auto">
          <table className="w-full text-sm">
            <thead className="text-xs text-muted-foreground">
              <tr className="text-left">
                <th className="py-2 pr-4">Date</th>
                <th className="py-2 pr-4">Title</th>
                <th className="py-2 pr-4">Score</th>
                <th className="py-2 pr-4">Time</th>
                <th className="py-2 pr-4">Types</th>
                <th className="py-2 pr-0 text-right">Review</th>
              </tr>
            </thead>
            <tbody>
              {(data.recent ?? []).slice(0, 7).map((r) => (
                <tr key={r.slug} className="border-top border-border/40">
                  <td className="py-2 pr-4 whitespace-nowrap">
                    {new Date(r.date).toLocaleDateString(undefined, { month: 'short', day: '2-digit' })}
                  </td>
                  <td className="py-2 pr-4 truncate">{r.title}</td>
                  <td className="py-2 pr-4">{pct(r.score)}</td>
                  <td className="py-2 pr-4">{r.minutes}m</td>
                  <td className="py-2 pr-4 capitalize">{r.types.join(', ')}</td>
                  <td className="py-2 pr-0 text-right">
                    <Link href={r.hrefReview} className="inline-flex items-center gap-1 text-electricBlue hover:text-electricBlue/80">
                      Review <Icon name="ArrowRight" size={16} />
                    </Link>
                  </td>
                </tr>
              ))}
              {!data.recent?.length && (
                <tr><td className="py-4 text-xs text-muted-foreground" colSpan={6}>No sessions yet</td></tr>
              )}
            </tbody>
          </table>
        </div>
      </Card>

      {/* SAVED & QUEUED */}
      <div className="grid gap-4 md:grid-cols-2">
        <Card className="p-5 border-border/60 bg-white/70 backdrop-blur dark:bg-dark/70">
          <h3 className="text-sm font-semibold">Saved passages</h3>
          <ul className="mt-2 space-y-2">
            {(data.saved ?? []).slice(0, 3).map((s) => (
              <li key={s.slug} className="flex items-center justify-between gap-3">
                <span className="truncate">{s.title}</span>
                <Link href={s.href}><Button variant="surface" size="sm" className="rounded-ds-xl">Continue</Button></Link>
              </li>
            ))}
            {!data.saved?.length && <li className="text-xs text-muted-foreground">Nothing saved yet</li>}
          </ul>
        </Card>

        <Card className="p-5 border-border/60 bg-white/70 backdrop-blur dark:bg-dark/70">
          <h3 className="text-sm font-semibold">Queued drills</h3>
          <ul className="mt-2 space-y-2">
            {(data.queued ?? []).slice(0, 3).map((q, idx) => (
              <li key={`${q.href}-${idx}`} className="flex items-center justify-between gap-3">
                <span className="truncate">{q.label}</span>
                <Link href={q.href}><Button variant="primary" size="sm" className="rounded-ds-xl">Start</Button></Link>
              </li>
            ))}
            {!data.queued?.length && <li className="text-xs text-muted-foreground">No queued drills</li>}
          </ul>
        </Card>
      </div>
    </div>
  );
};

export default ReadingDashboard;



================================================================================
FILE: C:\Users\DELL\Documents\Gramor_X\components\reading\ReadingExamShell.tsx
================================================================================

// components/reading/ReadingExamShell.tsx
import * as React from 'react';

import { Card } from '@/components/design-system/Card';
import { Button } from '@/components/design-system/Button';
import TimerProgress from '@/components/reading/TimerProgress';
import { ReadingPassagePane } from './ReadingPassagePane';
import { ReadingQuestionItem } from './ReadingQuestionItem';
import { QuestionNav } from './QuestionNav';

import type {
  ReadingTest,
  ReadingPassage,
  ReadingQuestion,
} from '@/lib/reading/types';

import { supabase } from '@/lib/supabaseClient';
import { readingBandFromRaw } from '@/lib/reading/band';
import { cn } from '@/lib/utils';
import { useToast } from '@/components/design-system/Toaster';

import { ExamHeader } from '@/components/exam/ExamHeader';
import {
  ExamBreadcrumbs,
  type ExamBreadcrumbItem,
} from '@/components/exam/ExamBreadcrumbs';
import { ExamFooter } from '@/components/exam/ExamFooter';
import { Icon } from '@/components/design-system/Icon';

// NEW STRICT CBE MODALS
import { ExamConfirmPopup } from '@/components/exam/ExamConfirmPopup';
import { ExamStrictModePopup } from '@/components/exam/ExamStrictModePopup';
import { ExamExitPopup } from '@/components/exam/ExamExitPopup';
import { ExamTimeWarningPopup } from '@/components/exam/ExamTimeWarningPopup';

type Props = {
  test: ReadingTest;
  passages: ReadingPassage[];
  questions: ReadingQuestion[];
  /** Optional: if true, disables submit + instructions (for future review mode) */
  readOnly?: boolean;
};

type AnswerValue = string | string[] | Record<string, any> | null;

type FilterStatus = 'all' | 'flagged' | 'unanswered';
type FilterType = 'all' | 'tfng' | 'ynng' | 'mcq' | 'gap' | 'match';
type ZoomLevel = 'sm' | 'md' | 'lg';

// Theme support
type Theme = 'light' | 'dark' | 'system';
const THEME_KEY = 'rx-reading-theme';
const FOCUS_KEY = 'rx-reading-focus';
const ZOOM_KEY = 'rx-reading-zoom';

// Split layout support (draggable)
const SPLIT_KEY = 'rx-reading-split-step';

// 7 steps from "passage wide" to "questions wide"
const SPLIT_LAYOUT_CLASSES = [
  'lg:grid-cols-[minmax(0,1.7fr)_10px_minmax(0,1fr)]',
  'lg:grid-cols-[minmax(0,1.5fr)_10px_minmax(0,1fr)]',
  'lg:grid-cols-[minmax(0,1.3fr)_10px_minmax(0,1fr)]',
  'lg:grid-cols-[minmax(0,1.15fr)_10px_minmax(0,1.15fr)]',
  'lg:grid-cols-[minmax(0,1.1fr)_10px_minmax(0,1.3fr)]',
  'lg:grid-cols-[minmax(0,1.0fr)_10px_minmax(0,1.5fr)]',
  'lg:grid-cols-[minmax(0,1.0fr)_10px_minmax(0,1.7fr)]',
] as const;

const splitStepFromRatio = (ratio: number): number => {
  const steps = SPLIT_LAYOUT_CLASSES.length;
  const min = 0.3;
  const max = 0.7;
  const clamped = Math.min(max, Math.max(min, ratio));
  const t = (clamped - min) / (max - min);
  const raw = Math.round(t * (steps - 1));
  return Math.min(steps - 1, Math.max(0, raw));
};

const isAnswered = (value: AnswerValue) => {
  if (!value) return false;
  if (typeof value === 'string') return value.trim().length > 0;
  if (Array.isArray(value)) return value.length > 0;
  if (typeof value === 'object') {
    return Object.values(value).some(
      (v) => (v ?? '').toString().trim() !== '',
    );
  }
  return false;
};

const ReadingExamShellInner: React.FC<Props> = ({
  test,
  passages,
  questions,
  readOnly = false,
}) => {
  const toast = useToast();

  // ===== THEME / SYSTEM DARK =====
  const [theme, setTheme] = React.useState<Theme>('system');
  const [systemPrefersDark, setSystemPrefersDark] = React.useState(false);

  React.useEffect(() => {
    if (typeof window === 'undefined') return;
    const saved = window.localStorage.getItem(THEME_KEY) as Theme | null;
    if (saved && ['light', 'dark', 'system'].includes(saved)) {
      setTheme(saved);
    }
  }, []);

  React.useEffect(() => {
    if (typeof window === 'undefined') return;
    const mq = window.matchMedia('(prefers-color-scheme: dark)');
    const handler = (event: MediaQueryListEvent) => {
      setSystemPrefersDark(event.matches);
    };
    setSystemPrefersDark(mq.matches);
    mq.addEventListener('change', handler);
    return () => mq.removeEventListener('change', handler);
  }, []);

  React.useEffect(() => {
    if (typeof document === 'undefined' || typeof window === 'undefined') return;
    const root = document.documentElement;
    root.classList.remove('light', 'dark');
    const effectiveDark =
      theme === 'dark' || (theme === 'system' && systemPrefersDark);
    root.classList.add(effectiveDark ? 'dark' : 'light');
    window.localStorage.setItem(THEME_KEY, theme);
  }, [theme, systemPrefersDark]);

  const toggleTheme = () => {
    setTheme((prev) =>
      prev === 'light' ? 'dark' : prev === 'dark' ? 'system' : 'light',
    );
  };

  const isDark =
    theme === 'dark' || (theme === 'system' && systemPrefersDark);

  if (!questions.length || !passages.length) {
    return (
      <Card className="p-6 text-sm text-muted-foreground">
        This Reading test does not have passages or questions configured yet.
      </Card>
    );
  }

  // ===== CORE STATE =====
  const [answers, setAnswers] = React.useState<Record<string, AnswerValue>>({});
  const [flags, setFlags] = React.useState<Record<string, boolean>>({});

  const [statusFilter, setStatusFilter] =
    React.useState<FilterStatus>('all');
  const [typeFilter, setTypeFilter] = React.useState<FilterType>('all');

  const [currentPassageIdx, setCurrentPassageIdx] = React.useState(0);
  const [currentQuestionId, setCurrentQuestionId] = React.useState(
    questions[0]?.id ?? null,
  );

  const [focusMode, setFocusMode] = React.useState(false);
  const [zoom, setZoom] = React.useState<ZoomLevel>('md');

  const [highlightsByPassage, setHighlightsByPassage] = React.useState<
    Record<string, string[]>
  >({});

  const [started, setStarted] = React.useState(readOnly);

  const questionRefs =
    React.useRef<Record<string, HTMLDivElement | null>>({});

  const startTimeRef = React.useRef<number | null>(null);
  const submitting = React.useRef(false);

  // strict CBE modals
  const [showSubmitConfirm, setShowSubmitConfirm] = React.useState(false);
  const [showExitPopup, setShowExitPopup] = React.useState(false);
  const [showTimeWarning, setShowTimeWarning] = React.useState(false);
  const [timeWarningShown, setTimeWarningShown] = React.useState(false);

  // timer tracking for warning popup (does NOT control TimerProgress)
  // @ts-expect-error reading type shape
  const durationSeconds = (test.durationSeconds ?? 3600) as number;
  const [remainingSeconds, setRemainingSeconds] =
    React.useState<number>(durationSeconds);

  // ===== SPLIT LAYOUT STATE (DRAGGABLE) =====
  const [splitStep, setSplitStep] = React.useState<number>(3); // 0..6, 3 â‰ˆ balanced
  const layoutContainerRef = React.useRef<HTMLDivElement | null>(null);
  const splitDragActiveRef = React.useRef(false);
  const splitBoundsRef = React.useRef<{ left: number; width: number } | null>(
    null,
  );

  // hydrate saved split step
  React.useEffect(() => {
    if (typeof window === 'undefined') return;
    const raw = window.localStorage.getItem(SPLIT_KEY);
    if (!raw) return;
    const parsed = Number(raw);
    if (Number.isNaN(parsed)) return;
    if (parsed >= 0 && parsed < SPLIT_LAYOUT_CLASSES.length) {
      setSplitStep(parsed);
    }
  }, []);

  const handleSplitMouseMove = (event: MouseEvent) => {
    if (!splitDragActiveRef.current) return;
    const bounds = splitBoundsRef.current;
    if (!bounds) return;

    const relativeX = event.clientX - bounds.left;
    if (relativeX <= 0 || relativeX >= bounds.width) return;

    const ratio = relativeX / bounds.width; // 0..1
    const step = splitStepFromRatio(ratio);

    setSplitStep((prev) => {
      if (prev === step) return prev;
      if (typeof window !== 'undefined') {
        window.localStorage.setItem(SPLIT_KEY, String(step));
      }
      return step;
    });
  };

  const handleSplitMouseUp = () => {
    if (!splitDragActiveRef.current) return;
    splitDragActiveRef.current = false;
    if (typeof window !== 'undefined') {
      window.removeEventListener('mousemove', handleSplitMouseMove);
      window.removeEventListener('mouseup', handleSplitMouseUp);
    }
  };

  const handleSplitMouseDown = (
    event: React.MouseEvent<HTMLDivElement>,
  ) => {
    if (typeof window === 'undefined') return;
    if (!layoutContainerRef.current) return;

    const rect = layoutContainerRef.current.getBoundingClientRect();
    splitBoundsRef.current = { left: rect.left, width: rect.width };
    splitDragActiveRef.current = true;

    window.addEventListener('mousemove', handleSplitMouseMove);
    window.addEventListener('mouseup', handleSplitMouseUp);

    event.preventDefault();
  };

  React.useEffect(() => {
    // safety cleanup on unmount
    return () => {
      if (typeof window === 'undefined') return;
      window.removeEventListener('mousemove', handleSplitMouseMove);
      window.removeEventListener('mouseup', handleSplitMouseUp);
    };
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);

  // ===== HYDRATE PREFS =====
  React.useEffect(() => {
    if (typeof window === 'undefined') return;

    const focusRaw = window.localStorage.getItem(FOCUS_KEY);
    if (focusRaw === '1') setFocusMode(true);

    const zoomRaw = window.localStorage.getItem(ZOOM_KEY) as
      | ZoomLevel
      | null;
    if (zoomRaw === 'sm' || zoomRaw === 'md' || zoomRaw === 'lg') {
      setZoom(zoomRaw);
    }
  }, []);

  const toggleFocus = () => {
    setFocusMode((prev) => {
      const next = !prev;
      if (typeof window !== 'undefined') {
        window.localStorage.setItem(FOCUS_KEY, next ? '1' : '0');
      }
      return next;
    });
  };

  const changeZoom = (level: ZoomLevel) => {
    setZoom(level);
    if (typeof window !== 'undefined') {
      window.localStorage.setItem(ZOOM_KEY, level);
    }
  };

  // internal countdown for time warning popup
  React.useEffect(() => {
    if (readOnly || !started) return;
    if (typeof window === 'undefined') return;

    const interval = window.setInterval(() => {
      setRemainingSeconds((prev) => (prev > 0 ? prev - 1 : 0));
    }, 1000);

    return () => window.clearInterval(interval);
  }, [started, readOnly]);

  React.useEffect(() => {
    if (readOnly || !started || timeWarningShown) return;
    const minutesLeft = Math.floor(remainingSeconds / 60);
    if (minutesLeft <= 5) {
      setShowTimeWarning(true);
      setTimeWarningShown(true);
    }
  }, [remainingSeconds, readOnly, started, timeWarningShown]);

  // ===== PASSAGE / QUESTION MAPS =====
  const passageIndexById = React.useMemo(() => {
    const m: Record<string, number> = {};
    passages.forEach((p, idx) => {
      // @ts-expect-error reading type shape
      m[p.id as string] = idx;
    });
    return m;
  }, [passages]);

  const questionsById = React.useMemo(() => {
    const m: Record<string, ReadingQuestion> = {};
    questions.forEach((q) => {
      m[q.id] = q;
    });
    return m;
  }, [questions]);

  const currentPassage = passages[currentPassageIdx];

  // ===== COUNTERS =====
  const total = questions.length;
  const answeredCount = React.useMemo(
    () => questions.filter((q) => isAnswered(answers[q.id])).length,
    [questions, answers],
  );
  const unansweredCount = total - answeredCount;

  const flaggedCount = React.useMemo(
    () => Object.values(flags).filter(Boolean).length,
    [flags],
  );

  // ===== FILTERED QUESTIONS =====
  const visibleQuestions = React.useMemo(() => {
    return questions.filter((q) => {
      // only show current passage
      // @ts-expect-error reading type
      if (q.passageId && q.passageId !== currentPassage.id) return false;

      // type filter
      // @ts-expect-error reading type
      const type = (q.questionTypeId ?? 'all') as FilterType;
      if (typeFilter !== 'all' && type !== typeFilter) return false;

      const val = answers[q.id];
      const isA = isAnswered(val);
      const isF = flags[q.id] ?? false;

      if (statusFilter === 'flagged' && !isF) return false;
      if (statusFilter === 'unanswered' && isA) return false;

      return true;
    });
  }, [
    questions,
    currentPassage,
    answers,
    flags,
    statusFilter,
    typeFilter,
  ]);

  // ===== JUMP / NAV =====
  const handleJump = (id: string) => {
    setCurrentQuestionId(id);
    const q = questionsById[id];

    // passage sync
    // @ts-expect-error reading type
    if (q && q.passageId) {
      // @ts-expect-error reading type
      const idx = passageIndexById[q.passageId as string];
      if (typeof idx === 'number') setCurrentPassageIdx(idx);
    }

    const el = questionRefs.current[id];
    if (el && typeof window !== 'undefined') {
      el.scrollIntoView({ behavior: 'smooth', block: 'start' });
    }
  };

  const goNextPassage = () => {
    setCurrentPassageIdx((idx) =>
      idx + 1 < passages.length ? idx + 1 : idx,
    );
  };

  const goPrevPassage = () => {
    setCurrentPassageIdx((idx) => (idx > 0 ? idx - 1 : idx));
  };

  const handleAnswerChange = (questionId: string, value: AnswerValue) => {
    setAnswers((prev) => ({ ...prev, [questionId]: value }));
  };

  const toggleFlag = (questionId: string) => {
    setFlags((prev) => ({ ...prev, [questionId]: !prev[questionId] }));
  };

  // ===== HIGHLIGHTS =====
  const currentHighlights =
    highlightsByPassage[currentPassage.id] ?? [];

  const handleAddHighlight = (passageId: string, text: string) => {
    if (!text.trim()) return;
    setHighlightsByPassage((prev) => {
      const existing = prev[passageId] ?? [];
      if (existing.includes(text)) return prev;
      return {
        ...prev,
        [passageId]: [...existing, text],
      };
    });
  };

  const handleClearHighlights = (passageId: string) => {
    setHighlightsByPassage((prev) => ({
      ...prev,
      [passageId]: [],
    }));
  };

  // ===== SUBMIT (CORE) =====
  const submitToServer = async () => {
    if (readOnly) return;
    if (submitting.current) return;
    submitting.current = true;

    try {
      const {
        data: { user },
        error: userError,
      } = await supabase.auth.getUser();

      if (userError) {
        // eslint-disable-next-line no-console
        console.error('Failed to fetch user', userError);
      }
      if (!user) {
        toast({
          variant: 'destructive',
          title: 'Not signed in',
          description: 'You must be logged in to submit this mock.',
        });
        submitting.current = false;
        return;
      }

      let correct = 0;
      for (const q of questions) {
        const userA = answers[q.id];
        // @ts-expect-error reading type
        const correctA = q.correctAnswer;

        let ok = false;
        if (typeof correctA === 'string') {
          ok = userA === correctA;
        } else if (Array.isArray(correctA)) {
          ok =
            Array.isArray(userA) &&
            correctA.every((x) => (userA as string[]).includes(x));
        }
        if (ok) correct++;
      }

      const band = readingBandFromRaw(correct, total);
      const startedAt = startTimeRef.current ?? Date.now();
      const durationSec = Math.floor((Date.now() - startedAt) / 1000);

      const { data: attemptRow, error: attemptError } = await supabase
        .from('reading_attempts')
        .insert({
          user_id: user.id,
          // @ts-expect-error reading type
          test_id: test.id,
          status: 'submitted',
          duration_seconds: durationSec,
          raw_score: correct,
          band_score: band,
          section_stats: {},
          meta: {
            flags,
            answers,
            highlights: highlightsByPassage,
          },
        })
        .select()
        .maybeSingle();

      if (attemptError || !attemptRow) {
        // eslint-disable-next-line no-console
        console.error('Failed to insert reading_attempt', attemptError);
        const message = attemptError?.message ?? '';

        if (message.includes('uq_reading_attempt_in_progress')) {
          toast({
            variant: 'destructive',
            title: 'Attempt already in progress',
            description:
              'You already have an active attempt for this test. Refresh the page or open it from your attempts history.',
          });
        } else {
          toast({
            variant: 'destructive',
            title: 'Failed to submit attempt',
            description:
              message ||
              'Something went wrong while saving your attempt. Please try again.',
          });
        }

        submitting.current = false;
        return;
      }

      const attemptId: string = (attemptRow as any).id;
      if (typeof window !== 'undefined') {
        window.location.href = `/mock/reading/result/${attemptId}`;
      }
    } catch (err: any) {
      // eslint-disable-next-line no-console
      console.error('Unexpected error during reading submit', err);
      toast({
        variant: 'destructive',
        title: 'Unexpected error',
        description:
          err?.message ??
          'An unexpected error occurred while submitting your attempt.',
      });
    } finally {
      submitting.current = false;
    }
  };

  // ===== SUBMIT BUTTON HANDLER =====
  const handleSubmitClick = () => {
    if (readOnly) return;

    if (answeredCount === 0) {
      toast({
        variant: 'destructive',
        title: 'Cannot submit yet',
        description: 'Answer at least one question before submitting.',
      });
      return;
    }

    if (unansweredCount > 0) {
      setShowSubmitConfirm(true);
      return;
    }

    void submitToServer();
  };

  // ===== NAV helpers =====
  const currentIndex =
    questions.findIndex((q) => q.id === currentQuestionId) ?? 0;

  const goPrevQuestion = () => {
    if (currentIndex <= 0) return;
    handleJump(questions[currentIndex - 1].id);
  };

  const goNextQuestion = () => {
    if (currentIndex + 1 >= questions.length) return;
    handleJump(questions[currentIndex + 1].id);
  };

  const handleStartTest = () => {
    startTimeRef.current = Date.now();
    setStarted(true);
  };

  const handleExit = () => {
    if (typeof window !== 'undefined') {
      window.location.href = '/mock/reading';
    }
  };

  // ===== LABELS =====
  const examTypeLabel =
    // @ts-expect-error reading type
    test.examType === 'gt'
      ? 'IELTS Reading Â· General Training'
      : 'IELTS Reading Â· Academic';

  const breadcrumbs: ExamBreadcrumbItem[] = [
    { label: 'Home', href: '/' },
    { label: 'Mocks', href: '/mock' },
    { label: 'Reading', href: '/mock/reading' },
    { label: test.title, active: true },
  ];

  const durationMinutes = Math.round(durationSeconds / 60);

  return (
    <div
      className={cn(
        'w-full border border-border/70 rounded-xl bg-background/95 shadow-sm overflow-hidden flex flex-col transition-colors duration-300',
        focusMode && 'ring-2 ring-primary/40 bg-background',
      )}
    >
      {/* HEADER */}
      <div className="sticky top-0 z-40">
        <div
          className={cn(
            'border-b border-border/70 shadow-sm',
            isDark
              ? 'bg-gradient-to-r from-slate-950 via-slate-900 to-slate-950'
              : 'bg-gradient-to-r from-blue-50 via-white to-blue-50',
          )}
        >
          <div className="px-3 py-2 sm:px-4 sm:py-2 border-b border-white/5">
            <ExamBreadcrumbs items={breadcrumbs} />
          </div>

          <ExamHeader
            breadcrumbs={undefined}
            examLabel={examTypeLabel}
            title={test.title}
            subtitle={
              test.description ??
              'Three passages, 40 questions. Strict timing, auto-saving, exam-style layout.'
            }
            metaLeft={
              <div className="flex flex-wrap items-center gap-x-4 gap-y-1 text-[11px] text-muted-foreground">
                <span className="inline-flex items-center gap-1">
                  <Icon name="file-text" className="h-3.5 w-3.5" />
                  {total} questions
                </span>
                <span className="inline-flex items-center gap-1">
                  <Icon name="book-open" className="h-3.5 w-3.5" />
                  {passages.length} passages
                </span>
                <span className="inline-flex items-center gap-1">
                  <Icon name="clock" className="h-3.5 w-3.5" />
                  {durationMinutes} minutes
                </span>
                <span className="hidden sm:inline-flex items-center gap-1">
                  <Icon name="flag" className="h-3.5 w-3.5" />
                  {flaggedCount} flagged
                </span>
              </div>
            }
            metaRight={
              <div className="flex flex-col items-end gap-2">
                {/* Theme Toggle + Zoom + Focus */}
                <div className="flex items-center gap-1">
                  <Button
                    size="xs"
                    variant="ghost"
                    onClick={toggleTheme}
                    className="h-7 w-7"
                  >
                    <Icon
                      name={isDark ? 'moon' : 'sun'}
                      className="h-4 w-4"
                    />
                  </Button>

                  <div className="flex items-center gap-1 rounded-full border border-primary/50 bg-background/80 px-2 py-0.5 shadow-sm">
                    <span className="mr-1 text-[10px] font-semibold uppercase tracking-wide text-muted-foreground">
                      Zoom
                    </span>
                    <Button
                      size="xs"
                      variant={zoom === 'sm' ? 'secondary' : 'ghost'}
                      className="h-6 px-1.5 text-[10px]"
                      onClick={() => changeZoom('sm')}
                    >
                      S
                    </Button>
                    <Button
                      size="xs"
                      variant={zoom === 'md' ? 'secondary' : 'ghost'}
                      className="h-6 px-1.5 text-[10px]"
                      onClick={() => changeZoom('md')}
                    >
                      M
                    </Button>
                    <Button
                      size="xs"
                      variant={zoom === 'lg' ? 'secondary' : 'ghost'}
                      className="h-6 px-1.5 text-[10px]"
                      onClick={() => changeZoom('lg')}
                    >
                      L
                    </Button>

                    <span className="mx-1 h-4 w-px bg-border/60" />

                    <Button
                      size="xs"
                      variant={focusMode ? 'primary' : 'outline'}
                      className="h-6 px-2 text-[10px] font-semibold"
                      onClick={toggleFocus}
                    >
                      {focusMode ? 'Focus on' : 'Focus mode'}
                    </Button>
                  </div>
                </div>

                {/* Timer */}
                <div className="flex items-center gap-3">
                  <div className="flex flex-col items-end">
                    <span className="text-[10px] font-semibold tracking-wide text-primary/80 uppercase">
                      Time remaining
                    </span>
                    <div className="mt-0.5 text-sm font-semibold tabular-nums">
                      <TimerProgress total={total} />
                    </div>
                  </div>
                </div>
              </div>
            }
            onExitHref="/mock/reading"
            onExitClick={() => setShowExitPopup(true)}
          />
        </div>
      </div>

      {/* DESKTOP LAYOUT WITH DRAGGABLE SPLIT */}
      <div
        ref={layoutContainerRef}
        className={cn(
          'hidden lg:grid gap-4 h-[calc(100vh-190px)] px-4 py-3 overflow-hidden',
          SPLIT_LAYOUT_CLASSES[splitStep],
        )}
      >
        {/* Passage side */}
        <ReadingPassagePane
          passage={currentPassage}
          totalPassages={passages.length}
          currentPassageIndex={currentPassageIdx}
          onPrev={goPrevPassage}
          onNext={goNextPassage}
          highlights={currentHighlights}
          onAddHighlight={(text) =>
            handleAddHighlight(currentPassage.id, text)
          }
          onClearHighlights={() =>
            handleClearHighlights(currentPassage.id)
          }
          zoom={zoom}
        />

        {/* Drag handle */}
        <div
          className="hidden lg:flex items-center justify-center cursor-col-resize select-none"
          onMouseDown={handleSplitMouseDown}
          aria-hidden="true"
        >
          <div className="relative h-[80%] w-px bg-border/60">
            <div className="absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 rounded-full border border-border/70 bg-background/90 px-1.5 py-2 shadow-sm flex items-center justify-center">
              <Icon
                name="grip-vertical"
                className="h-3 w-3 text-muted-foreground"
              />
            </div>
          </div>
        </div>

        {/* Questions side */}
        <div className="bg-card/95 shadow-sm rounded-lg flex flex-col overflow-hidden border border-border/60">
          <div id="reading-question-nav">
            <QuestionNav
              questions={questions}
              answers={answers}
              flags={flags}
              currentQuestionId={currentQuestionId}
              onJump={handleJump}
              statusFilter={statusFilter}
              typeFilter={typeFilter}
              setStatusFilter={setStatusFilter}
              setTypeFilter={setTypeFilter}
            />
          </div>

          <div
            className={cn(
              'flex-1 overflow-y-auto px-4 py-4 space-y-4',
              isDark ? 'bg-background/80' : 'bg-white',
              zoom === 'sm' && 'text-xs',
              zoom === 'md' && 'text-sm',
              zoom === 'lg' && 'text-base',
            )}
          >
            {visibleQuestions.length === 0 ? (
              <Card className="p-4 text-sm text-muted-foreground">
                No questions match the current filters for this passage.
              </Card>
            ) : (
              visibleQuestions.map((q) => {
                const isCurrent = q.id === currentQuestionId;
                const isFlagged = !!flags[q.id];
                const val = answers[q.id] ?? null;

                return (
                  <div
                    key={q.id}
                    ref={(el) => {
                      questionRefs.current[q.id] = el;
                    }}
                    className={cn(
                      'rounded-lg transition ring-0',
                      isCurrent
                        ? isDark
                          ? 'ring-1 ring-primary/70 bg-primary/10'
                          : 'ring-2 ring-blue-500 bg-blue-50'
                        : 'hover:bg-muted/50',
                    )}
                  >
                    <ReadingQuestionItem
                      question={q}
                      value={val}
                      onChange={(v) => handleAnswerChange(q.id, v)}
                      isFlagged={isFlagged}
                      onToggleFlag={() => toggleFlag(q.id)}
                    />
                  </div>
                );
              })
            )}
          </div>
        </div>
      </div>

      {/* MOBILE / TABLET STACKED */}
      <div className="flex flex-col gap-4 px-4 py-3 lg:hidden">
        <ReadingPassagePane
          passage={currentPassage}
          totalPassages={passages.length}
          currentPassageIndex={currentPassageIdx}
          onPrev={goPrevPassage}
          onNext={goNextPassage}
          highlights={currentHighlights}
          onAddHighlight={(text) =>
            handleAddHighlight(currentPassage.id, text)
          }
          onClearHighlights={() =>
            handleClearHighlights(currentPassage.id)
          }
          zoom={zoom}
        />

        <Card
          className="p-3 border-border/70 bg-card/95 shadow-sm"
          id="reading-question-nav"
        >
          <QuestionNav
            questions={questions}
            answers={answers}
            flags={flags}
            currentQuestionId={currentQuestionId}
            onJump={handleJump}
            statusFilter={statusFilter}
            typeFilter={typeFilter}
            setStatusFilter={setStatusFilter}
            setTypeFilter={setTypeFilter}
          />
        </Card>

        <div
          className={cn(
            'space-y-3',
            zoom === 'sm' && 'text-xs',
            zoom === 'md' && 'text-sm',
            zoom === 'lg' && 'text-base',
          )}
        >
          {visibleQuestions.length === 0 ? (
            <Card className="p-4 text-sm text-muted-foreground">
              No questions match the current filters for this passage.
            </Card>
          ) : (
            visibleQuestions.map((q) => {
              const isCurrent = q.id === currentQuestionId;
              const isFlagged = !!flags[q.id];
              const val = answers[q.id] ?? null;

              return (
                <div
                  key={q.id}
                  ref={(el) => {
                    questionRefs.current[q.id] = el;
                  }}
                  className={cn(
                    'rounded-lg transition ring-0',
                    isCurrent
                      ? isDark
                        ? 'ring-1 ring-primary/70 bg-primary/10'
                        : 'ring-2 ring-blue-500 bg-blue-50'
                      : 'p-0',
                  )}
                >
                  <ReadingQuestionItem
                    question={q}
                    value={val}
                    onChange={(v) => handleAnswerChange(q.id, v)}
                    isFlagged={isFlagged}
                    onToggleFlag={() => toggleFlag(q.id)}
                  />
                </div>
              );
            })
          )}
        </div>
      </div>

      {/* FOOTER */}
      <ExamFooter
        currentQuestion={currentIndex + 1}
        totalQuestions={total}
        primaryLabel={readOnly ? 'Review only' : 'Submit attempt'}
        onPrimaryClick={readOnly ? undefined : handleSubmitClick}
        primaryDisabled={readOnly}
        secondaryLabel={currentIndex > 0 ? 'Previous question' : undefined}
        onSecondaryClick={currentIndex > 0 ? goPrevQuestion : undefined}
      />

      {/* STRICT MODE POPUP */}
      {!readOnly && (
        <ExamStrictModePopup
          open={!started}
          onAcknowledge={handleStartTest}
        />
      )}

      {/* SUBMIT CONFIRM POPUP */}
      <ExamConfirmPopup
        open={showSubmitConfirm}
        unanswered={unansweredCount}
        onCancel={() => setShowSubmitConfirm(false)}
        onConfirm={() => {
          setShowSubmitConfirm(false);
          void submitToServer();
        }}
      />

      {/* EXIT TEST POPUP */}
      <ExamExitPopup
        open={showExitPopup}
        unanswered={unansweredCount}
        onCancel={() => setShowExitPopup(false)}
        onExit={handleExit}
      />

      {/* TIME WARNING POPUP */}
      <ExamTimeWarningPopup
        open={showTimeWarning}
        remainingMinutes={Math.max(
          0,
          Math.floor(remainingSeconds / 60),
        )}
        onClose={() => setShowTimeWarning(false)}
        onJumpToNav={() => {
          if (typeof document !== 'undefined') {
            const el = document.getElementById('reading-question-nav');
            if (el) {
              el.scrollIntoView({ behavior: 'smooth', block: 'start' });
            }
          }
        }}
      />
    </div>
  );
};

export const ReadingExamShell = ReadingExamShellInner;
export default ReadingExamShellInner;



================================================================================
FILE: C:\Users\DELL\Documents\Gramor_X\components\reading\ReadingFilterBar.tsx
================================================================================

import React from 'react';
import { useRouter } from 'next/router';
import { Button } from '@/components/design-system/Button';

const TYPES = [
  { key: 'all', label: 'All' },
  { key: 'tfng', label: 'True/False/Not Given' },
  { key: 'mcq', label: 'MCQ' },
  { key: 'matching', label: 'Matching' },
  { key: 'short', label: 'Short Answer' },
];

export const ReadingFilterBar: React.FC<{ className?: string }> = ({
  className = '',
}) => {
  const router = useRouter();
  const active = (router.query.type as string) || 'all';

  const setType = (t: string) => {
    router.push(
      { pathname: router.pathname, query: { ...router.query, type: t } },
      undefined,
      { shallow: true },
    );
  };

  return (
    <div
      className={`flex flex-wrap items-center gap-2 rounded-ds bg-muted/40 px-2 py-1.5 ${className}`}
      aria-label="Filter reading tests by question type"
    >
      <span className="text-[11px] font-medium uppercase tracking-[0.16em] text-muted-foreground mr-1.5">
        Focus type
      </span>
      {TYPES.map((t) => (
        <Button
          key={t.key}
          onClick={() => setType(t.key)}
          variant={active === t.key ? 'primary' : 'secondary'}
          size="xs"
          className="rounded-ds px-2.5 text-[11px]"
        >
          {t.label}
        </Button>
      ))}
    </div>
  );
};



================================================================================
FILE: C:\Users\DELL\Documents\Gramor_X\components\reading\ReadingForecastPanel.tsx
================================================================================

// components/reading/ReadingForecastPanel.tsx
import React, { useEffect, useState } from 'react';
import { Card } from '@/components/design-system/Card';
import { Badge } from '@/components/design-system/Badge';
import { Button } from '@/components/design-system/Button';
import { Icon } from '@/components/design-system/Icon';
import { Skeleton } from '@/components/design-system/Skeleton';

type ForecastPayload = {
  bandNow: number;
  currentPct: number;
  targetBand: number;
  etaDays: number | null;
  confidence: 'low' | 'med' | 'high';
  rationale: string;
};

const ForecastSkeleton: React.FC = () => (
  <Card className="p-4 space-y-3 bg-background/95 dark:bg-dark/90">
    <div className="flex items-center justify-between">
      <Skeleton className="h-4 w-28" />
      <Skeleton className="h-5 w-16 rounded-full" />
    </div>
    <Skeleton className="h-6 w-40" />
    <Skeleton className="h-4 w-full" />
    <Skeleton className="h-4 w-2/3" />
    <div className="pt-2">
      <Skeleton className="h-8 w-40 rounded-full" />
    </div>
  </Card>
);

export const ReadingForecastPanel: React.FC<{ targetBand?: number }> = ({
  targetBand = 7.0,
}) => {
  const [data, setData] = useState<ForecastPayload | null>(null);
  const [loading, setLoading] = useState(true);
  const [hasError, setHasError] = useState(false);

  useEffect(() => {
    let cancelled = false;

    (async () => {
      try {
        setLoading(true);
        setHasError(false);

        const r = await fetch(`/api/reading/forecast?target=${targetBand}`);
        if (!r.ok) {
          throw new Error(`forecast status ${r.status}`);
        }

        const j = (await r.json()) as Partial<ForecastPayload> | null;

        if (
          j &&
          typeof j.bandNow === 'number' &&
          typeof j.targetBand === 'number'
        ) {
          if (!cancelled) {
            setData({
              bandNow: j.bandNow,
              currentPct: j.currentPct ?? 0,
              targetBand: j.targetBand,
              etaDays: j.etaDays ?? null,
              confidence: (j.confidence as ForecastPayload['confidence']) ?? 'low',
              rationale:
                j.rationale ??
                'We need a few more completed mocks before the forecast becomes sharp.',
            });
          }
        } else {
          if (!cancelled) {
            setData(null);
          }
        }
      } catch (e) {
        // eslint-disable-next-line no-console
        console.error('Reading forecast fetch failed', e);
        if (!cancelled) {
          setHasError(true);
          setData(null);
        }
      } finally {
        if (!cancelled) setLoading(false);
      }
    })();

    return () => {
      cancelled = true;
    };
  }, [targetBand]);

  if (loading) {
    return <ForecastSkeleton />;
  }

  if (!data) {
    return (
      <Card className="p-4 space-y-3 bg-background/95 dark:bg-dark/90">
        <div className="flex items-center justify-between">
          <span className="text-xs font-semibold text-muted-foreground uppercase tracking-[0.16em]">
            Reading forecast
          </span>
          <Badge variant="outline" className="rounded-ds-xl text-[10px]">
            <Icon name="Info" className="mr-1 h-3 w-3" />
            Warming up
          </Badge>
        </div>
        <p className="text-sm text-muted-foreground">
          We don&apos;t have enough completed reading attempts to forecast your band yet.
        </p>
        {hasError && (
          <p className="text-xs text-destructive">
            Couldn&apos;t reach the forecast service right now. Try again after another
            attempt.
          </p>
        )}
        <div className="pt-2">
          <Button
            variant="surface"
            size="sm"
            className="rounded-ds-xl text-xs"
            asChild
          >
            <a href="/mock/reading/history">Finish a mock to unlock forecast</a>
          </Button>
        </div>
      </Card>
    );
  }

  const bandNow = data.bandNow;
  const target = data.targetBand;

  const confidenceLabel =
    data.confidence === 'high'
      ? 'High confidence'
      : data.confidence === 'med'
      ? 'Medium confidence'
      : 'Early estimate';

  return (
    <Card className="p-4 space-y-3 bg-background/95 dark:bg-dark/90">
      <div className="flex items-center justify-between">
        <span className="text-xs font-semibold text-muted-foreground uppercase tracking-[0.16em]">
          Reading forecast
        </span>
        <Badge
          variant={data.confidence === 'high' ? 'success' : 'outline'}
          className="rounded-ds-xl text-[10px]"
        >
          <Icon name="Sparkles" className="mr-1 h-3 w-3" />
          {confidenceLabel}
        </Badge>
      </div>
      <div className="flex items-baseline gap-2">
        <span className="text-2xl font-semibold text-foreground">
          {bandNow.toFixed(1)}
        </span>
        <span className="text-xs text-muted-foreground">
          â†’ target {target.toFixed(1)}
        </span>
      </div>
      <div className="text-xs text-muted-foreground">
        Current:{' '}
        <span className="font-semibold text-foreground">
          Band {bandNow.toFixed(1)}
        </span>{' '}
        ({Math.round(data.currentPct)}% of target)
      </div>
      <div className="text-xs">
        {data.etaDays === null ? (
          <span className="text-muted-foreground">
            â€¢ Keep improving your slope to reach target.
          </span>
        ) : (
          <span className="font-semibold text-foreground">
            In ~{data.etaDays} days (based on your current pace)
          </span>
        )}
      </div>
      <div className="mt-1 text-xs text-muted-foreground">{data.rationale}</div>
      <div className="mt-3">
        <Button variant="surface" size="sm" className="rounded-ds-xl" asChild>
          <a href="/reading?type=tfng">Boost slope: weakest type drill</a>
        </Button>
      </div>
    </Card>
  );
};



================================================================================
FILE: C:\Users\DELL\Documents\Gramor_X\components\reading\ReadingPassagePane.tsx
================================================================================

import * as React from 'react';
import { Card } from '@/components/design-system/Card';
import { Button } from '@/components/design-system/Button';
import { Icon } from '@/components/design-system/Icon';
import { cn } from '@/lib/utils';

type Props = {
  passage: any;
  totalPassages: number;
  currentPassageIndex: number;
  onPrev: () => void;
  onNext: () => void;
  highlights: string[];
  onAddHighlight: (text: string) => void;
  onClearHighlights: () => void;
  zoom: 'sm' | 'md' | 'lg';
};

export const ReadingPassagePane: React.FC<Props> = ({
  passage,
  totalPassages,
  currentPassageIndex,
  onPrev,
  onNext,
  highlights,
  onAddHighlight,
  onClearHighlights,
  zoom,
}) => {
  const [highlightMode, setHighlightMode] = React.useState(false);

  const toggleHighlight = () => setHighlightMode((x) => !x);

  const handleHighlight = () => {
    const sel = window.getSelection();
    if (!sel) return;

    const text = sel.toString();
    if (text.trim().length === 0) return;

    onAddHighlight(text);

    try {
      const range = sel.getRangeAt(0);
      const span = document.createElement('span');
      span.className = 'bg-yellow-300/40';
      range.surroundContents(span);
    } catch {
      // ignore
    }
    sel.removeAllRanges();
  };

  const rawContent: string = passage?.content ?? '';

  // detect if content contains HTML
  const hasHtmlTags = /<\/?[a-z][\s\S]*>/i.test(rawContent);

  const paragraphs = React.useMemo(() => {
    if (!rawContent || hasHtmlTags) return [];

    // Split on double newline OR fallback to single newline
    return rawContent
      .split(/\n{2,}|\r\n\r\n/)
      .map((p) => p.trim())
      .filter(Boolean);
  }, [rawContent, hasHtmlTags]);

  return (
    <Card
      className={cn(
        'flex flex-col w-full rounded-lg border border-border/60 shadow-sm bg-card/95',
        'overflow-hidden'
      )}
    >
      {/* IELTS top bar */}
      <div className="flex items-center justify-between px-4 py-3 border-b border-border/60 bg-muted/40">
        <div className="flex flex-col">
          <div className="text-[13px] font-semibold text-primary tracking-tight">
            READING PASSAGE {currentPassageIndex + 1}
          </div>
          {passage?.title && (
            <div className="text-[11px] text-muted-foreground">{passage.title}</div>
          )}
        </div>

        <div className="flex items-center gap-2">
          <Button
            size="xs"
            variant={highlightMode ? 'secondary' : 'outline'}
            className={cn(
              'h-7 px-2 text-[11px]',
              highlightMode && 'bg-yellow-300/30 text-primary'
            )}
            onClick={toggleHighlight}
          >
            <Icon name="highlighter" className="h-3.5 w-3.5 mr-1" />
            {highlightMode ? 'Highlight (On)' : 'Highlight'}
          </Button>

          <Button
            size="xs"
            variant="outline"
            className="h-7 px-2 text-[11px]"
            onClick={onClearHighlights}
            disabled={highlights.length === 0}
          >
            <Icon name="eraser" className="h-3.5 w-3.5 mr-1" />
            Clear
          </Button>
        </div>
      </div>

      {/* Main text area */}
      <div
        className={cn(
          'flex-1 overflow-y-auto px-5 py-5 leading-7',
          'scrollbar-thin scrollbar-thumb-muted-foreground/30 scrollbar-track-transparent',
          zoom === 'sm' && 'text-xs',
          zoom === 'md' && 'text-sm',
          zoom === 'lg' && 'text-base'
        )}
        onMouseUp={() => highlightMode && handleHighlight()}
      >
        <div className="max-w-[780px] mx-auto text-justify space-y-4">
          {hasHtmlTags ? (
            <div
              className="prose prose-sm dark:prose-invert max-w-none leading-relaxed"
              dangerouslySetInnerHTML={{ __html: rawContent }}
            />
          ) : (
            paragraphs.map((p, idx) => (
              <p
                key={idx}
                className="text-muted-foreground/90 leading-relaxed"
              >
                {p}
              </p>
            ))
          )}
        </div>
      </div>

      {/* Bottom nav */}
      <div className="flex items-center justify-between px-4 py-2 border-t border-border/60 bg-muted/30 text-[12px]">
        <Button
          size="xs"
          variant="outline"
          disabled={currentPassageIndex === 0}
          onClick={onPrev}
        >
          Previous passage
        </Button>

        <span className="text-muted-foreground">
          Passage {currentPassageIndex + 1} of {totalPassages}
        </span>

        <Button
          size="xs"
          variant="outline"
          disabled={currentPassageIndex + 1 >= totalPassages}
          onClick={onNext}
        >
          Next passage
        </Button>
      </div>
    </Card>
  );
};



================================================================================
FILE: C:\Users\DELL\Documents\Gramor_X\components\reading\ReadingQuestionItem.tsx
================================================================================

// components/reading/ReadingQuestionItem.tsx
import * as React from 'react';

import type { ReadingQuestion } from '@/lib/reading/types';
import { Card } from '@/components/design-system/Card';
import { Button } from '@/components/design-system/Button';

type AnswerValue = string | string[] | Record<string, unknown> | null;

type ReadingQuestionItemProps = {
  question: ReadingQuestion;
  value: AnswerValue;
  onChange: (val: AnswerValue) => void;
  isFlagged?: boolean;
  onToggleFlag?: () => void;
};

export type QuestionKind =
  | 'tfng'
  | 'yynn'
  | 'mcq'
  | 'gap'
  | 'match'
  | 'short'
  | 'other';

const TFNG_OPTIONS = ['True', 'False', 'Not Given'];
const YYNN_OPTIONS = ['Yes', 'No', 'Not Given'];

export function getQuestionKind(q: ReadingQuestion): QuestionKind {
  const id = String((q as any).questionTypeId ?? '').toLowerCase();

  if (id === 'tfng' || id === 'true_false_not_given') return 'tfng';
  if (id === 'yynn' || id === 'yes_no_not_given') return 'yynn';
  if (id.startsWith('mcq') || id.includes('choice')) return 'mcq';
  if (id.includes('gap') || id.includes('blank') || id.includes('summary'))
    return 'gap';
  if (id.includes('match')) return 'match';
  if (
    id === 'short_answer' ||
    id === 'sentence_completion' ||
    id === 'summary_completion'
  ) {
    return 'short';
  }

  return 'other';
}

function getMcqOptions(q: ReadingQuestion): string[] {
  const rawConstraints = (q as any).constraintsJson as
    | { options?: string[]; labels?: string[] }
    | undefined;

  if (rawConstraints) {
    if (Array.isArray(rawConstraints.options)) {
      return rawConstraints.options.map(String);
    }
    if (Array.isArray(rawConstraints.labels)) {
      return rawConstraints.labels.map(String);
    }
  }

  return [];
}

export const ReadingQuestionItem: React.FC<ReadingQuestionItemProps> = ({
  question,
  value,
  onChange,
  isFlagged = false,
  onToggleFlag,
}) => {
  const kind = getQuestionKind(question);

  const currentTextValue =
    typeof value === 'string'
      ? value
      : Array.isArray(value)
      ? value.join(', ')
      : '';

  const handleTextChange: React.ChangeEventHandler<
    HTMLInputElement | HTMLTextAreaElement
  > = (e) => {
    onChange(e.target.value);
  };

  const renderTfng = (options: string[]) => {
    const current = typeof value === 'string' ? value : '';

    return (
      <div className="flex flex-wrap gap-2">
        {options.map((opt) => {
          const picked = current === opt;
          return (
            <Button
              key={opt}
              type="button"
              size="sm"
              variant={picked ? 'primary' : 'outline'}
              className="rounded-full px-3 text-xs"
              onClick={() => onChange(picked ? '' : opt)}
            >
              {opt}
            </Button>
          );
        })}
      </div>
    );
  };

  const renderMcq = () => {
    const opts = getMcqOptions(question);
    const current = typeof value === 'string' ? value : '';

    if (!opts.length) {
      return (
        <input
          type="text"
          value={currentTextValue}
          onChange={handleTextChange}
          className="w-full rounded-md border border-lightBorder bg-background px-2 py-1 text-sm focus:outline-none focus:ring-2 focus:ring-ring dark:bg-dark dark:border-white/10"
          placeholder="Type your answer"
        />
      );
    }

    return (
      <div className="space-y-2">
        {opts.map((opt, idx) => {
          const letter = String.fromCharCode('A'.charCodeAt(0) + idx);
          const picked = current === letter || current === opt;

          return (
            <button
              key={idx}
              type="button"
              onClick={() => onChange(picked ? '' : letter)}
              className={[
                'flex w-full items-center justify-between rounded-md border px-3 py-2 text-left text-xs transition',
                picked
                  ? 'border-primary bg-primary/10 text-primary'
                  : 'border-lightBorder bg-background hover:border-primary/60 dark:bg-dark dark:border-white/10',
              ].join(' ')}
            >
              <span className="flex items-center gap-2">
                <span className="flex h-6 w-6 items-center justify-center rounded-full border border-lightBorder text-[11px] font-semibold dark:border-white/10">
                  {letter}
                </span>
                <span className="text-foreground">{opt}</span>
              </span>
            </button>
          );
        })}
      </div>
    );
  };

  const renderShortAnswer = () => (
    <input
      type="text"
      value={currentTextValue}
      onChange={handleTextChange}
      className="w-full rounded-md border border-lightBorder bg-background px-2 py-1 text-sm focus:outline-none focus:ring-2 focus:ring-ring dark:bg-dark dark:border-white/10"
      placeholder="Write your answer"
    />
  );

  const renderGapFill = () => {
    const constraints = (question as any).constraintsJson ?? {};
    const blanksRaw = constraints.blanks ?? constraints.gaps?.length ?? 1;
    const blanks = Math.max(1, Number(blanksRaw) || 1);
    const labels: string[] = Array.isArray(constraints.labels)
      ? constraints.labels
      : [];
    const currentObj =
      value && typeof value === 'object' && !Array.isArray(value)
        ? (value as Record<string, string>)
        : {};

    return (
      <div className="space-y-2">
        {Array.from({ length: blanks }).map((_, idx) => (
          <label
            key={idx}
            className="flex items-center gap-2 text-xs text-muted-foreground"
          >
            <span className="w-6 text-right">{idx + 1}.</span>
            <input
              type="text"
              value={currentObj[idx] ?? ''}
              onChange={(e) =>
                onChange({
                  ...currentObj,
                  [idx]: e.target.value,
                })
              }
              className="flex-1 rounded-md border border-lightBorder bg-background px-2 py-1 text-xs focus:outline-none focus:ring-2 focus:ring-ring dark:bg-dark dark:border-white/10"
              placeholder={labels[idx] ?? 'Type your answer'}
            />
          </label>
        ))}
        <p className="text-[11px] text-muted-foreground">
          Enter one answer per blank; use capital letters for names.
        </p>
      </div>
    );
  };

  const renderMatching = () => {
    const constraints = (question as any).constraintsJson ?? {};
    const prompts: string[] = Array.isArray(constraints.prompts)
      ? constraints.prompts
      : Array.isArray(constraints.pairs)
      ? constraints.pairs
      : [];
    const options: string[] = Array.isArray(constraints.options)
      ? constraints.options
      : [];

    if (!prompts.length || !options.length) {
      return renderGeneric();
    }

    const currentObj =
      value && typeof value === 'object' && !Array.isArray(value)
        ? (value as Record<string, string>)
        : {};

    return (
      <div className="space-y-2 text-xs">
        {prompts.map((prompt, idx) => (
          <div
            key={`${prompt}-${idx}`}
            className="flex flex-col gap-1 rounded-md border border-lightBorder bg-background/60 p-2 dark:bg-dark/70 dark:border-white/10 sm:flex-row sm:items-center sm:gap-3"
          >
            <span className="font-medium text-foreground sm:min-w-[140px]">
              {prompt}
            </span>
            <select
              className="w-full rounded-md border border-lightBorder bg-white px-2 py-1 text-xs focus:outline-none focus:ring-2 focus:ring-ring dark:bg-dark dark:border-white/10"
              value={currentObj[idx] ?? ''}
              onChange={(e) =>
                onChange({
                  ...currentObj,
                  [idx]: e.target.value,
                })
              }
            >
              <option value="">Select</option>
              {options.map((opt) => (
                <option key={`${opt}-${idx}`} value={opt}>
                  {opt}
                </option>
              ))}
            </select>
          </div>
        ))}
      </div>
    );
  };

  const renderGeneric = () => (
    <textarea
      value={currentTextValue}
      onChange={handleTextChange}
      className="w-full min-h-[60px] rounded-md border border-lightBorder bg-background px-2 py-1 text-sm focus:outline-none focus:ring-2 focus:ring-ring dark:bg-dark dark:border-white/10"
      placeholder="Answer"
    />
  );

  let control: React.ReactNode;
  if (kind === 'tfng') control = renderTfng(TFNG_OPTIONS);
  else if (kind === 'yynn') control = renderTfng(YYNN_OPTIONS);
  else if (kind === 'mcq') control = renderMcq();
  else if (kind === 'gap') control = renderGapFill();
  else if (kind === 'match') control = renderMatching();
  else if (kind === 'short') control = renderShortAnswer();
  else control = renderGeneric();

  return (
    <Card className="space-y-3 rounded-ds-xl border border-lightBorder bg-background/95 p-4 text-sm shadow-sm dark:bg-dark/90 dark:border-white/10">
      <div className="flex items-start justify-between gap-3">
        <div className="flex items-start gap-3">
          <span className="flex h-9 w-9 shrink-0 items-center justify-center rounded-full bg-muted text-sm font-semibold text-foreground">
            {question.questionOrder}
          </span>
          <div>
            <div className="font-semibold text-foreground leading-tight">
              {question.prompt}
            </div>
            {question.instruction && (
              <p className="mt-1 text-xs text-muted-foreground">
                {question.instruction}
              </p>
            )}
          </div>
        </div>

        {onToggleFlag && (
          <Button
            size="xs"
            variant={isFlagged ? 'soft' : 'outline'}
            tone={isFlagged ? 'warning' : 'default'}
            onClick={onToggleFlag}
            aria-pressed={isFlagged}
            className="rounded-ds"
          >
            {isFlagged ? 'Marked for review' : 'Mark for review'}
          </Button>
        )}
      </div>

      <div>{control}</div>
    </Card>
  );
};

export default ReadingQuestionItem;



================================================================================
FILE: C:\Users\DELL\Documents\Gramor_X\components\reading\ReadingResultSummary.tsx
================================================================================

// components/reading/ReadingResultSummary.tsx
import * as React from 'react';
import { Card } from '@/components/design-system/Card';
import { Badge } from '@/components/design-system/Badge';
import { Icon } from '@/components/design-system/Icon';

type AttemptSummary = {
  id: string;
  rawScore: number | null;
  bandScore: number | null;
  questionCount: number | null;
  durationSeconds: number | null;
  createdAt: string;
};

type TestSummary = {
  id: string;
  slug: string;
  title: string;
  examType: string;
  totalQuestions: number | null;
  durationSeconds: number | null;
};

type Props = {
  attempt: AttemptSummary;
  test: TestSummary;
};

export const ReadingResultSummary: React.FC<Props> = ({ attempt, test }) => {
  const totalQs = attempt.questionCount ?? test.totalQuestions ?? 40;
  const raw = attempt.rawScore ?? 0;
  const band = attempt.bandScore ?? null;

  const accuracy = totalQs > 0 ? Math.round((raw / totalQs) * 100) : 0;

  const mins = attempt.durationSeconds
    ? Math.floor(attempt.durationSeconds / 60)
    : Math.round((test.durationSeconds ?? 3600) / 60);

  let bandTone: 'good' | 'ok' | 'low' = 'ok';
  if (band != null) {
    if (band >= 7) bandTone = 'good';
    else if (band < 6) bandTone = 'low';
  }

  const bandBadgeClass =
    bandTone === 'good'
      ? 'bg-emerald-500/10 text-emerald-600 border-emerald-500/40'
      : bandTone === 'low'
      ? 'bg-destructive/10 text-destructive border-destructive/40'
      : 'bg-amber-500/10 text-amber-700 border-amber-500/40';

  return (
    <Card className="p-6 space-y-4 bg-background/95 dark:bg-dark/90 border border-lightBorder dark:border-white/10">
      <div className="flex flex-wrap items-center justify-between gap-4">
        <div className="space-y-2">
          <div className="flex items-center gap-2">
            <Badge
              variant="outline"
              className={
                bandBadgeClass +
                ' border text-xs font-semibold rounded-ds px-2 py-1'
              }
            >
              Band {band != null ? band.toFixed(1) : 'â€”'}
            </Badge>
            <span className="text-xs text-muted-foreground">
              Accuracy {accuracy}% ({raw}/{totalQs})
            </span>
          </div>
          <p className="text-xs text-muted-foreground max-w-md">
            This band is an estimate based on your raw score out of {totalQs}{' '}
            questions. Use it as a signal, then dig into your detailed review to
            fix weaknesses.
          </p>
        </div>
        <div className="flex flex-col items-end gap-1 text-xs text-muted-foreground">
          <span className="inline-flex items-center gap-1">
            <Icon name="clock" className="h-3.5 w-3.5" />
            Time used: {mins} min
          </span>
          <span className="inline-flex items-center gap-1">
            <Icon name="book-open" className="h-3.5 w-3.5" />
            {test.examType === 'gt'
              ? 'General Training'
              : 'Academic'}{' '}
            Reading
          </span>
        </div>
      </div>

      <div className="grid gap-3 sm:grid-cols-3 text-xs">
        <div className="rounded-ds border border-lightBorder/70 p-3 dark:border-white/10">
          <p className="text-[11px] text-muted-foreground uppercase tracking-[0.16em] mb-1">
            Raw score
          </p>
          <p className="text-sm font-semibold text-foreground">
            {raw}/{totalQs}
          </p>
        </div>
        <div className="rounded-ds border border-lightBorder/70 p-3 dark:border-white/10">
          <p className="text-[11px] text-muted-foreground uppercase tracking-[0.16em] mb-1">
            Estimated band
          </p>
          <p className="text-sm font-semibold text-foreground">
            {band != null ? band.toFixed(1) : 'â€”'}
          </p>
        </div>
        <div className="rounded-ds border border-lightBorder/70 p-3 dark:border-white/10">
          <p className="text-[11px] text-muted-foreground uppercase tracking-[0.16em] mb-1">
            Speed
          </p>
          <p className="text-sm font-semibold text-foreground">
            {mins} min Â·{' '}
            {totalQs > 0 ? Math.round(totalQs / (mins || 1)) : 0} Q/min (approx)
          </p>
        </div>
      </div>
    </Card>
  );
};

export default ReadingResultSummary;



================================================================================
FILE: C:\Users\DELL\Documents\Gramor_X\components\reading\ReadingStatsCard.tsx
================================================================================

import React from 'react';
import Link from 'next/link';
import { supabaseBrowser } from '@/lib/supabaseBrowser';
import { Card } from '@/components/design-system/Card';
import { Badge } from '@/components/design-system/Badge';
import { Button } from '@/components/design-system/Button';

type Stat = {
  user_id: string;
  attempts: number;
  total_score: number;
  total_max: number;
  accuracy_pct: number | null;
  avg_duration_ms: number | null;
  first_attempt_at: string | null;
  last_attempt_at: string | null;
};

type Attempt = {
  id: string;
  passage_slug: string;
  score: number;
  max_score: number;
  created_at: string;
};

export function ReadingStatsCard() {
  const [loading, setLoading] = React.useState(true);
  const [stat, setStat] = React.useState<Stat | null>(null);
  const [recent, setRecent] = React.useState<Attempt[]>([]);
  const [isAuthed, setIsAuthed] = React.useState<boolean>(false);

  React.useEffect(() => {
    let active = true;
    (async () => {
      setLoading(true);
      const { data: { session } } = await supabaseBrowser.auth.getSession();
      const uid = session?.user?.id;
      setIsAuthed(!!uid);

      if (!uid) {
        setLoading(false);
        return;
      }

      const [statRes, attemptsRes] = await Promise.all([
        supabaseBrowser
          .from('reading_user_stats')
          .select('*')
          .eq('user_id', uid)
          .single(),
        supabaseBrowser
          .from('reading_attempts')
          .select('id, passage_slug, score, max_score, created_at')
          .order('created_at', { ascending: false })
          .limit(5),
      ]);

      if (!active) return;
      if (!statRes.error && statRes.data) setStat(statRes.data as Stat);
      if (!attemptsRes.error && attemptsRes.data) setRecent(attemptsRes.data as Attempt[]);
      setLoading(false);
    })();
    return () => { active = false; };
  }, []);

  if (loading) {
    return (
      <Card className="p-6">
        <div className="animate-pulse h-5 w-40 bg-muted dark:bg-white/10 rounded mb-3" />
        <div className="animate-pulse h-4 w-64 bg-muted dark:bg-white/10 rounded" />
      </Card>
    );
  }

  if (!isAuthed) {
    return (
      <Card className="p-6 flex items-center justify-between">
        <div>
          <div className="font-semibold mb-1">Reading progress</div>
          <div className="text-small text-grayish dark:text-muted-foreground">Sign in to track your attempts and accuracy.</div>
        </div>
        <Button href="/login" variant="primary" className="rounded-ds-xl">Sign in</Button>
      </Card>
    );
  }

  return (
    <Card className="p-6">
      <div className="flex items-center justify-between mb-4">
        <div className="font-semibold">Reading progress</div>
        {stat?.accuracy_pct != null && (
          <Badge>{stat.accuracy_pct}% accuracy</Badge>
        )}
      </div>

      <div className="grid grid-cols-2 md:grid-cols-4 gap-4 mb-6">
        <div>
          <div className="text-small text-grayish dark:text-muted-foreground">Attempts</div>
          <div className="text-h3 font-semibold">{stat?.attempts ?? 0}</div>
        </div>
        <div>
          <div className="text-small text-grayish dark:text-muted-foreground">Points</div>
          <div className="text-h3 font-semibold">{stat?.total_score ?? 0}/{stat?.total_max ?? 0}</div>
        </div>
        <div>
          <div className="text-small text-grayish dark:text-muted-foreground">Avg. duration</div>
          <div className="text-h3 font-semibold">
            {stat?.avg_duration_ms ? Math.round((stat.avg_duration_ms / 1000) / 60) + ' min' : 'â€”'}
          </div>
        </div>
        <div>
          <div className="text-small text-grayish dark:text-muted-foreground">Last attempt</div>
          <div className="text-h3 font-semibold">
            {stat?.last_attempt_at ? new Date(stat.last_attempt_at).toLocaleDateString() : 'â€”'}
          </div>
        </div>
      </div>

      <div className="mb-3 font-medium">Recent attempts</div>
      {recent.length === 0 ? (
        <div className="text-small text-grayish dark:text-muted-foreground">No attempts yet. Try a passage to see your stats.</div>
      ) : (
        <ul className="grid gap-2">
          {recent.map(a => (
            <li key={a.id} className="flex items-center justify-between">
              <div className="truncate">
                <Link
                  href={`/reading/${encodeURIComponent(a.passage_slug)}/review?attemptId=${a.id}`}
                  className="underline"
                >
                  {a.passage_slug}
                </Link>
                <span className="ml-2 text-small text-grayish dark:text-muted-foreground">
                  {new Date(a.created_at).toLocaleString()}
                </span>
              </div>
              <Badge>{a.score}/{a.max_score}</Badge>
            </li>
          ))}
        </ul>
      )}

      <div className="mt-6 flex gap-2">
        <Button as="a" href="/reading" variant="secondary" className="rounded-ds-xl">Browse passages</Button>
        <Button as="a" href="/reading/passage/reading-test-38" variant="primary" className="rounded-ds-xl">Start now</Button>
      </div>
    </Card>
  );
}



================================================================================
FILE: C:\Users\DELL\Documents\Gramor_X\components\reading\useReadingAnswers.ts
================================================================================

'use client';
import { useCallback, useEffect, useMemo, useState } from 'react';

/**
 * Minimal client store for Reading answers (per passage).
 * - Persists to localStorage under key `reading:<slug>:answers`
 * - API: setAnswer, clear, allAnswers
 */
export type AnswerValue = string | number | boolean | string[] | null;

export function useReadingAnswers(slug: string) {
  const storageKey = useMemo(() => `reading:${slug}:answers`, [slug]);
  const [answers, setAnswers] = useState<Record<string, AnswerValue>>({});

  useEffect(() => {
    if (typeof window === 'undefined') return;
    try {
      const merged: Record<string, AnswerValue> = {};
      const legacyKeys = [storageKey, `reading:${slug}`, `readingAnswers:${slug}`];
      legacyKeys.forEach((key) => {
        const raw = localStorage.getItem(key);
        if (!raw) return;
        try {
          const parsed = JSON.parse(raw);
          if (parsed && typeof parsed === 'object' && !Array.isArray(parsed)) {
            Object.assign(merged, parsed as Record<string, AnswerValue>);
          }
        } catch {
          // ignore malformed payloads
        }
      });

      setAnswers(merged);

      if (Object.keys(merged).length) {
        try { localStorage.setItem(storageKey, JSON.stringify(merged)); } catch {}
      }

      legacyKeys
        .filter((key) => key !== storageKey)
        .forEach((key) => {
          try { localStorage.removeItem(key); } catch {}
        });
    } catch {
      // ignore hydration failures
    }
  }, [slug, storageKey]);

  const persist = useCallback((
    next: Record<string, AnswerValue> | ((prev: Record<string, AnswerValue>) => Record<string, AnswerValue>),
  ) => {
    setAnswers((prev) => {
      const computed = typeof next === 'function' ? next(prev) : next;
      try {
        if (Object.keys(computed).length) localStorage.setItem(storageKey, JSON.stringify(computed));
        else localStorage.removeItem(storageKey);
      } catch {}
      return computed;
    });
  }, [storageKey]);

  const setAnswer = useCallback((id: string, value: AnswerValue) => {
    persist((prev) => ({ ...prev, [id]: value }));
  }, [persist]);

  const clear = useCallback(() => {
    persist({});
  }, [persist]);

  const allAnswers = useCallback(() => answers, [answers]);

  return { answers, setAnswer, clear, allAnswers };
}

export type ReadingAnswersStore = ReturnType<typeof useReadingAnswers>;



================================================================================
FILE: C:\Users\DELL\Documents\Gramor_X\components\reading\answer-sheet\ReadingAnswerSheetGrid.tsx
================================================================================

import * as React from 'react';

import { Card } from '@/components/design-system/Card';

// Props for the ReadingAnswerSheetGrid. It takes the number of
// questions and a map of answers keyed by question order (1-indexed).
type ReadingAnswerSheetGridProps = {
  totalQuestions: number;
  answers: Record<number, string | string[] | null>;
};

/**
 * Displays a simple grid representing the user's answers to each
 * question. Answered questions are highlighted differently to provide
 * a quick overview of which questions were attempted.
 */
export const ReadingAnswerSheetGrid: React.FC<ReadingAnswerSheetGridProps> = ({
  totalQuestions,
  answers,
}) => {
  const cells = [];
  for (let i = 1; i <= totalQuestions; i++) {
    const hasAnswer = answers[i] != null;
    cells.push(
      <div
        key={i}
        className={
          'p-2 text-center border text-xs ' +
          (hasAnswer
            ? 'bg-emerald-50 text-emerald-700'
            : 'bg-muted/20 text-muted-foreground')
        }
      >
        {i}
      </div>,
    );
  }
  return (
    <Card className="p-3 space-y-2">
      <p className="text-xs font-medium">Answer sheet</p>
      <div className="grid grid-cols-10 gap-1">{cells}</div>
    </Card>
  );
};

export default ReadingAnswerSheetGrid;



================================================================================
FILE: C:\Users\DELL\Documents\Gramor_X\components\reading\history\ReadingHistoryTable.tsx
================================================================================

// components/reading/history/ReadingHistoryTable.tsx
import * as React from 'react';
import Link from 'next/link';

import { Card } from '@/components/design-system/Card';
import { Badge } from '@/components/design-system/Badge';
import { Button } from '@/components/design-system/Button';
import { Icon } from '@/components/design-system/Icon';
import { cn } from '@/lib/utils';

export type ReadingHistoryRow = {
  attemptId: string;
  testSlug: string;
  testTitle: string;
  bandScore: number | null;
  rawScore: number | null;
  totalQuestions: number | null;  // derived from meta.answers
  createdAt: string;
  status?: 'in_progress' | 'submitted'; // optional visual cue
};

type Props = {
  rows: ReadingHistoryRow[];
  className?: string;
};

export const ReadingHistoryTable: React.FC<Props> = ({ rows, className }) => {
  if (!rows.length) {
    return (
      <Card
        className={cn(
          'p-6 text-center text-sm text-muted-foreground rounded-xl border border-border/60 bg-card/95 shadow-sm',
          className
        )}
      >
        No reading attempts yet. Start a strict mock and your history will appear here.
      </Card>
    );
  }

  return (
    <Card
      className={cn(
        'overflow-hidden rounded-xl border border-border/60 bg-card/95 shadow-sm',
        className
      )}
    >
      {/* HEADER */}
      <div
        className={cn(
          'grid',
          'grid-cols-[minmax(0,2.2fr)_minmax(0,0.9fr)_minmax(0,0.9fr)_minmax(0,1.2fr)]',
          'gap-3 px-4 py-3 text-[11px] font-semibold uppercase tracking-wide',
          'bg-muted/40 text-muted-foreground'
        )}
      >
        <div>Test</div>
        <div>Band</div>
        <div>Score</div>
        <div className="text-right">Actions</div>
      </div>

      {/* BODY */}
      <div className="divide-y divide-border/60">
        {rows.map((row) => {
          const total = row.totalQuestions ?? 40;
          const raw = row.rawScore ?? 0;
          const band = row.bandScore;
          const accuracy = total > 0 ? Math.round((raw / total) * 100) : 0;

          // Band color logic
          let toneClass = 'bg-amber-500/15 text-amber-700 border border-amber-500/30';
          if (band !== null) {
            if (band >= 7.0) {
              toneClass = 'bg-emerald-600/15 text-emerald-700 border border-emerald-600/40';
            } else if (band < 6.0) {
              toneClass = 'bg-red-500/15 text-red-600 border border-red-500/40';
            }
          }

          const isInProgress = row.status === 'in_progress';

          return (
            <div
              key={row.attemptId}
              className={cn(
                'grid items-center',
                'grid-cols-[minmax(0,2.2fr)_minmax(0,0.9fr)_minmax(0,0.9fr)_minmax(0,1.2fr)]',
                'gap-3 px-4 py-3 text-xs transition-colors',
                'hover:bg-muted/30',
                isInProgress && 'opacity-75 italic'
              )}
            >
              {/* TEST INFO */}
              <div className="space-y-1 pr-4">
                <span className="text-sm font-medium truncate block">
                  {row.testTitle}
                </span>

                <div className="text-[11px] text-muted-foreground">
                  {isInProgress && (
                    <span className="inline-block mr-2">
                      <Badge variant="secondary" className="text-[9px] px-1">In Progress</Badge>
                    </span>
                  )}
                  Attempted on{' '}
                  {new Date(row.createdAt).toLocaleString([], {
                    month: 'short',
                    day: 'numeric',
                    year: 'numeric',
                    hour: '2-digit',
                    minute: '2-digit',
                  })}
                </div>
              </div>

              {/* BAND + ACCURACY */}
              <div className="space-y-1">
                <Badge
                  variant="outline"
                  className={cn(
                    'w-fit px-2 py-0.5 text-[11px] rounded-ds-md font-medium shadow-sm',
                    toneClass
                  )}
                >
                  {band !== null ? `Band ${band.toFixed(1)}` : 'â€”'}
                </Badge>
                <div className="text-[11px] text-muted-foreground">
                  Accuracy {accuracy}%
                </div>
              </div>

              {/* RAW SCORE */}
              <div className="flex flex-col text-[11px] text-muted-foreground">
                <span>
                  {raw}/{total} correct
                </span>
                {isInProgress && <span className="text-[10px] text-orange-600">partial</span>}
              </div>

              {/* ACTIONS */}
              <div className="flex items-center justify-end gap-2">
                <Button
                  asChild
                  size="xs"
                  variant="outline"
                  className="rounded-ds-xl px-2 py-1 text-[11px]"
                  disabled={isInProgress}
                >
                  <Link href={`/mock/reading/result/${row.attemptId}`}>
                    <Icon name="file-text" className="h-3.5 w-3.5 mr-1" />
                    Result
                  </Link>
                </Button>

                <Button
                  asChild
                  size="xs"
                  variant={isInProgress ? 'secondary' : 'default'}
                  className="rounded-ds-xl px-2 py-1 text-[11px]"
                >
                  <Link href={`/mock/reading/review/${row.attemptId}`}>
                    <Icon name="eye" className="h-3.5 w-3.5 mr-1" />
                    {isInProgress ? 'Continue' : 'Review'}
                  </Link>
                </Button>
              </div>
            </div>
          );
        })}
      </div>
    </Card>
  );
};

export default ReadingHistoryTable;


================================================================================
FILE: C:\Users\DELL\Documents\Gramor_X\components\reading\review\ReadingReviewQuestionItem.tsx
================================================================================

import * as React from 'react';

import type { ReadingQuestion } from '@/lib/reading/types';
import { Card } from '@/components/design-system/Card';
import { Badge } from '@/components/design-system/Badge';

type ReadingReviewQuestionItemProps = {
  question: ReadingQuestion;
  userAnswer: string | string[] | null;
  isCorrect: boolean;
};

export const ReadingReviewQuestionItem: React.FC<
  ReadingReviewQuestionItemProps
> = ({ question, userAnswer, isCorrect }) => {
  const formatAnswer = (ans: any): string => {
    if (ans == null) return '-';
    if (Array.isArray(ans)) return ans.join(', ');
    return String(ans);
  };

  const borderTone = isCorrect
    ? 'border-emerald-500/50 bg-emerald-500/5'
    : 'border-destructive/40 bg-destructive/5';

  return (
    <Card
      className={`p-3 space-y-2 text-sm border-l-4 ${
        isCorrect ? 'border-l-emerald-500' : 'border-l-destructive'
      }`}
    >
      <div className="flex items-center justify-between gap-3">
        <p className="flex-1">
          <span className="font-medium mr-1">
            {(question as any).questionOrder}.
          </span>
          {question.prompt}
        </p>
        <Badge
          size="xs"
          variant="outline"
          className={borderTone + ' text-[10px] font-semibold uppercase'}
        >
          {isCorrect ? 'Correct' : 'Incorrect'}
        </Badge>
      </div>

      {question.instruction && (
        <p className="text-xs text-muted-foreground">{question.instruction}</p>
      )}

      <div className="text-xs space-y-0.5">
        <p>
          Your answer:{' '}
          <span className="font-medium">
            {formatAnswer(userAnswer)}
          </span>
        </p>
        <p>
          Correct answer:{' '}
          <span className="font-medium">
            {formatAnswer((question as any).correctAnswer)}
          </span>
        </p>
      </div>
    </Card>
  );
};

export default ReadingReviewQuestionItem;



================================================================================
FILE: C:\Users\DELL\Documents\Gramor_X\components\reading\review\ReadingReviewShell.tsx
================================================================================

import * as React from 'react';
import { Card } from '@/components/design-system/Card';
import { Badge } from '@/components/design-system/Badge';
import { Button } from '@/components/design-system/Button';
import Icon from '@/components/design-system/Icon';

import type {
  ReadingTest,
  ReadingPassage,
  ReadingQuestion,
} from '@/lib/reading/types';

type ReviewAnswer = {
  questionId: string;
  isCorrect: boolean;
  selectedAnswer: string | string[] | null;
};

type AttemptForReview = {
  id: string;
  rawScore: number | null;
  bandScore: number | null;
  questionCount: number | null;
  createdAt: string;
  durationSeconds: number | null;
};

type ReadingReviewShellProps = {
  test: ReadingTest;
  passages: ReadingPassage[];
  questions: ReadingQuestion[];
  attempt: AttemptForReview;
  answers: ReviewAnswer[];
};

type CorrectnessFilter = 'all' | 'correct' | 'wrong' | 'unanswered';

export const ReadingReviewShell: React.FC<ReadingReviewShellProps> = ({
  passages,
  questions,
  answers,
}) => {
  const [correctnessFilter, setCorrectnessFilter] =
    React.useState<CorrectnessFilter>('all');
  const [tagFilter, setTagFilter] = React.useState<string>('all');

  const answersMap = React.useMemo(() => {
    const map = new Map<string, ReviewAnswer>();
    for (const ans of answers) {
      map.set(ans.questionId, ans);
    }
    return map;
  }, [answers]);

  const questionsByPassage = React.useMemo(() => {
    const grouped: Record<string, ReadingQuestion[]> = {};
    for (const q of questions) {
      if (!q.passageId) continue;
      if (!grouped[q.passageId]) grouped[q.passageId] = [];
      grouped[q.passageId].push(q);
    }
    Object.values(grouped).forEach((arr) =>
      arr.sort((a, b) => (a.questionOrder ?? 0) - (b.questionOrder ?? 0)),
    );
    return grouped;
  }, [questions]);

  const sortedPassages = React.useMemo(
    () =>
      [...passages].sort(
        (a, b) => (a.passageOrder ?? 0) - (b.passageOrder ?? 0),
      ),
    [passages],
  );

  const availableTags = React.useMemo(() => {
    const set = new Set<string>();
    questions.forEach((q) => {
      q.tags?.forEach((t) => {
        if (t) set.add(t);
      });
    });
    return Array.from(set).sort();
  }, [questions]);

  const resetFilters = () => {
    setCorrectnessFilter('all');
    setTagFilter('all');
  };

  return (
    <div className="space-y-4">
      {/* ===== FILTER BAR ===== */}
      <div className="flex flex-col gap-3 border-b border-border/60 pb-3 md:flex-row md:items-center md:justify-between">
        <div className="flex flex-wrap items-center gap-2 text-xs">
          <span className="text-[11px] uppercase tracking-wide text-muted-foreground">
            Filter questions
          </span>

          <div className="inline-flex items-center gap-1 rounded-ds-full bg-background/70 p-1">
            <Button
              type="button"
              size="xs"
              variant={correctnessFilter === 'all' ? 'primary' : 'ghost'}
              className="h-6 px-2 text-[11px]"
              onClick={() => setCorrectnessFilter('all')}
            >
              All
            </Button>
            <Button
              type="button"
              size="xs"
              variant={correctnessFilter === 'wrong' ? 'primary' : 'ghost'}
              className="h-6 px-2 text-[11px]"
              onClick={() => setCorrectnessFilter('wrong')}
            >
              Wrong
            </Button>
            <Button
              type="button"
              size="xs"
              variant={correctnessFilter === 'correct' ? 'primary' : 'ghost'}
              className="h-6 px-2 text-[11px]"
              onClick={() => setCorrectnessFilter('correct')}
            >
              Correct
            </Button>
            <Button
              type="button"
              size="xs"
              variant={correctnessFilter === 'unanswered' ? 'primary' : 'ghost'}
              className="h-6 px-2 text-[11px]"
              onClick={() => setCorrectnessFilter('unanswered')}
            >
              Unanswered
            </Button>
          </div>
        </div>

        <div className="flex flex-wrap items-center gap-2 text-xs">
          <div className="inline-flex items-center gap-2">
            <span className="text-[11px] text-muted-foreground">Tag</span>
            <select
              value={tagFilter}
              onChange={(e) => setTagFilter(e.target.value)}
              className="h-7 rounded-ds-full border border-border/60 bg-background px-2 text-[11px] text-foreground focus:outline-none"
            >
              <option value="all">All tags</option>
              {availableTags.map((tag) => (
                <option key={tag} value={tag}>
                  {tag}
                </option>
              ))}
            </select>
          </div>

          <Button
            type="button"
            size="xs"
            variant="ghost"
            className="h-7 px-2 text-[11px]"
            onClick={resetFilters}
          >
            <Icon name="XCircle" size={12} className="mr-1" />
            Clear
          </Button>
        </div>
      </div>

      {/* ===== PASSAGES WITH COLLAPSIBLE QUESTIONS ===== */}
      {sortedPassages.map((passage, idx) => {
        const passageQuestions = questionsByPassage[passage.id] ?? [];

        // Apply filters per passage
        const visibleQuestions = passageQuestions.filter((q) => {
          const ans = answersMap.get(q.id);
          const isCorrect = ans?.isCorrect ?? false;
          const isAnswered = ans && ans.selectedAnswer != null;

          if (correctnessFilter === 'correct' && !isCorrect) return false;
          if (correctnessFilter === 'wrong' && isCorrect) return false;
          if (correctnessFilter === 'unanswered' && isAnswered) return false;

          if (tagFilter !== 'all') {
            if (!q.tags || !q.tags.includes(tagFilter)) return false;
          }

          return true;
        });

        const hasVisibleQuestions = visibleQuestions.length > 0;

        return (
          <details
            key={passage.id}
            className="group rounded-ds-2xl border border-border/70 bg-background/60 p-3 md:p-4"
          >
            <summary className="flex items-center justify-between gap-3 cursor-pointer list-none">
              <div className="space-y-1">
                <div className="inline-flex items-center gap-2 text-[11px] text-muted-foreground">
                  <Badge variant="neutral" size="xs">
                    Passage {idx + 1}
                  </Badge>
                  {passage.subtitle && (
                    <span className="truncate max-w-[220px] md:max-w-xs">
                      {passage.subtitle}
                    </span>
                  )}
                </div>
                <p className="text-sm font-medium text-foreground line-clamp-1">
                  {passage.title}
                </p>
              </div>
              <Icon
                name="ChevronDown"
                size={16}
                className="shrink-0 text-muted-foreground transition-transform group-open:rotate-180"
              />
            </summary>

            <div className="mt-3 space-y-3">
              {/* Passage content preview */}
              <Card className="rounded-ds-xl border border-border/60 bg-card/80 p-3 text-xs text-muted-foreground max-h-40 overflow-y-auto">
                <div className="space-y-1 leading-relaxed">
                  {passage.content}
                </div>
              </Card>

              {/* Questions */}
              <div className="space-y-2">
                {hasVisibleQuestions ? (
                  visibleQuestions.map((q, qIndex) => {
                    const ans = answersMap.get(q.id);
                    const isCorrect = ans?.isCorrect ?? false;

                    const selected = ans?.selectedAnswer;
                    const selectedLabel = Array.isArray(selected)
                      ? selected.join(', ')
                      : selected ?? 'Not answered';

                    const correctAnswer: any = (q as any).correctAnswer;
                    let correctLabel: string | null = null;
                    if (typeof correctAnswer === 'string') {
                      correctLabel = correctAnswer;
                    } else if (Array.isArray(correctAnswer)) {
                      correctLabel = correctAnswer.join(', ');
                    } else if (correctAnswer && typeof correctAnswer === 'object') {
                      correctLabel = JSON.stringify(correctAnswer);
                    }

                    return (
                      <Card
                        key={q.id}
                        className="rounded-ds-xl border border-border/60 bg-card/90 p-3 text-xs"
                      >
                        <div className="flex items-start justify-between gap-3">
                          <div className="space-y-1">
                            <div className="inline-flex items-center gap-2">
                              <span className="text-[11px] font-medium text-muted-foreground">
                                Q{q.questionOrder ?? qIndex + 1}
                              </span>
                              {q.instruction && (
                                <span className="text-[11px] text-muted-foreground line-clamp-1">
                                  {q.instruction}
                                </span>
                              )}
                            </div>
                            <p className="text-xs text-muted-foreground line-clamp-2">
                              {q.prompt}
                            </p>
                          </div>

                          <Badge
                            variant={isCorrect ? 'success' : 'destructive'}
                            size="xs"
                            className="shrink-0"
                          >
                            {isCorrect ? 'Correct' : 'Wrong'}
                          </Badge>
                        </div>

                        <div className="mt-2 grid grid-cols-1 md:grid-cols-2 gap-2">
                          <div className="space-y-1">
                            <p className="text-[11px] uppercase tracking-wide text-muted-foreground">
                              Your answer
                            </p>
                            <p className="text-xs text-foreground break-words">
                              {selectedLabel}
                            </p>
                          </div>
                          {correctLabel && (
                            <div className="space-y-1">
                              <p className="text-[11px] uppercase tracking-wide text-muted-foreground">
                                Correct answer
                              </p>
                              <p className="text-xs text-foreground break-words">
                                {correctLabel}
                              </p>
                            </div>
                          )}
                        </div>
                      </Card>
                    );
                  })
                ) : (
                  <p className="text-[11px] text-muted-foreground">
                    No questions in this passage match the current filters.
                  </p>
                )}
              </div>
            </div>
          </details>
        );
      })}

      {sortedPassages.length === 0 && (
        <p className="text-xs text-muted-foreground text-center">
          No passages found for this test.
        </p>
      )}
    </div>
  );
};



================================================================================
FILE: C:\Users\DELL\Documents\Gramor_X\components\reading\review\ReadingReviewSummaryBar.tsx
================================================================================

import * as React from 'react';

import { Card } from '@/components/design-system/Card';

// Props describing the information required to summarise a reading
// attempt in the review view. All numeric fields may be null when
// information is unavailable.
type ReadingReviewSummaryBarProps = {
  testTitle: string;
  bandScore: number | null;
  rawScore: number | null;
  totalQuestions: number | null;
  createdAt: string;
  durationSeconds?: number;
};

/**
 * Displays a concise summary of a completed reading attempt, including
 * the test title, date completed, band score, raw/total score and
 * duration. It is typically rendered at the top of the review page.
 */
export const ReadingReviewSummaryBar: React.FC<ReadingReviewSummaryBarProps> = ({
  testTitle,
  bandScore,
  rawScore,
  totalQuestions,
  createdAt,
  durationSeconds,
}) => {
  return (
    <Card className="p-3 flex flex-col sm:flex-row sm:items-center sm:justify-between text-xs">
      <div className="space-y-0.5">
        <p className="font-medium">{testTitle}</p>
        <p className="text-muted-foreground">
          Completed on {new Date(createdAt).toLocaleDateString()}
        </p>
      </div>
      <div className="flex gap-4 pt-2 sm:pt-0">
        <div>
          <p className="font-medium">
            {bandScore != null ? bandScore.toFixed(1) : '-'}
          </p>
          <p className="text-muted-foreground">Band</p>
        </div>
        <div>
          <p className="font-medium">
            {rawScore != null ? rawScore : '-'} / {totalQuestions != null ? totalQuestions : '-'}
          </p>
          <p className="text-muted-foreground">Correct</p>
        </div>
        {durationSeconds != null && (
          <div>
            <p className="font-medium">{Math.round(durationSeconds / 60)} min</p>
            <p className="text-muted-foreground">Duration</p>
          </div>
        )}
      </div>
    </Card>
  );
};

export default ReadingReviewSummaryBar;



================================================================================
FILE: C:\Users\DELL\Documents\Gramor_X\hooks\useNextReadingPlan.ts
================================================================================

// hooks/useNextReadingPlan.ts
import { useEffect, useState } from 'react';

export type NextPlan = {
  difficulty: 'Easy'|'Medium'|'Hard';
  primaryType: 'tfng'|'mcq'|'matching'|'short';
  reason: string;
  href: string;
  minSecPerQ?: number;
};

export function useNextReadingPlan() {
  const [data, setData] = useState<NextPlan | null>(null);
  const [loading, setLoading] = useState(true);
  const [err, setErr] = useState<string | null>(null);

  useEffect(() => {
    let cancelled = false;
    (async () => {
      try {
        setLoading(true);
        const r = await fetch('/api/ai/next-item');
        if (!r.ok) throw new Error(`Failed (${r.status})`);
        const j = await r.json();
        if (!cancelled) { setData(j); setErr(null); }
      } catch (e: any) {
        if (!cancelled) { setErr(e?.message || 'Could not fetch next plan'); setData(null); }
      } finally {
        if (!cancelled) setLoading(false);
      }
    })();
    return () => { cancelled = true; };
  }, []);

  return { data, loading, err };
}



================================================================================
FILE: C:\Users\DELL\Documents\Gramor_X\hooks\useReadingExamState.ts
================================================================================



================================================================================
FILE: C:\Users\DELL\Documents\Gramor_X\hooks\useReadingHighlightManager.ts
================================================================================



================================================================================
FILE: C:\Users\DELL\Documents\Gramor_X\hooks\useReadingTimer.ts
================================================================================



================================================================================
FILE: C:\Users\DELL\Documents\Gramor_X\context\ReadingExamContext.tsx
================================================================================



================================================================================
FILE: C:\Users\DELL\Documents\Gramor_X\lib\analytics\readingForecast.ts
================================================================================

// lib/analytics/readingForecast.ts
// Least-squares on last N sessions, with guards. No deps.

export type TrendPoint = { date: string; score: number }; // score 0..1
export type Forecast = {
  targetBand: number;
  etaDays: number | null; // null if not reachable from current slope
  confidence: 'low' | 'med' | 'high';
  rationale: string;
  targetPct: number; // 0..1
  slopePctPerDay: number; // signed
};

const pctToBand = (p: number) => {
  const x = p * 100;
  if (x <= 35) return 5.0;
  if (x <= 55) return 6.0;
  if (x <= 72) return 7.0;
  if (x <= 88) return 7.5;
  if (x <= 95) return 8.0;
  return 8.5;
};

const bandToPct = (b: number) => {
  // inverse of coarse mapping (piecewise midpoints)
  if (b <= 5) return 0.30;
  if (b <= 6) return 0.50;
  if (b <= 7) return 0.70;
  if (b <= 7.5) return 0.82;
  if (b <= 8) return 0.90;
  return 0.95;
};

export function regressETA(points: TrendPoint[], targetBand = 7.0): Forecast {
  const pts = (points ?? []).slice(-30).filter(p => Number.isFinite(p.score));
  if (pts.length < 5) {
    const cur = pts.at(-1)?.score ?? 0.6;
    return {
      targetBand,
      etaDays: null,
      confidence: 'low',
      rationale: 'Not enough history; keep logging sessions.',
      targetPct: bandToPct(targetBand),
      slopePctPerDay: 0,
    };
  }

  // x = days since first, y = score (0..1)
  const t0 = new Date(pts[0].date).getTime();
  const xy = pts.map((p) => ({
    x: (new Date(p.date).getTime() - t0) / (1000 * 60 * 60 * 24),
    y: Math.max(0, Math.min(1, p.score)),
  }));

  const n = xy.length;
  const sx = xy.reduce((a, v) => a + v.x, 0);
  const sy = xy.reduce((a, v) => a + v.y, 0);
  const sxx = xy.reduce((a, v) => a + v.x * v.x, 0);
  const sxy = xy.reduce((a, v) => a + v.x * v.y, 0);
  const denom = n * sxx - sx * sx || 1;

  const slope = (n * sxy - sx * sy) / denom;   // per day (0..1 units)
  const intercept = (sy - slope * sx) / n;

  const cur = xy[xy.length - 1]?.y ?? 0.6;
  const tgt = bandToPct(targetBand);

  const slopePctPerDay = slope; // same units
  let etaDays: number | null = null;
  if (slope > 0 && tgt > cur) etaDays = Math.ceil((tgt - cur) / slope);
  if (slope <= 0 && tgt > cur) etaDays = null;

  const variance =
    xy.reduce((a, v) => a + Math.pow(v.y - (slope * v.x + intercept), 2), 0) / n;
  const conf = variance < 0.002 ? 'high' : variance < 0.008 ? 'med' : 'low';

  return {
    targetBand,
    etaDays,
    confidence: conf,
    rationale:
      etaDays === null
        ? 'Trajectory is flat/declining; focus weaker types to change slope.'
        : `Slope ${(slope * 100).toFixed(2)}%/day from ${Math.round(n)} sessions.`,
    targetPct: tgt,
    slopePctPerDay: slopePctPerDay,
  };
}

export const deriveBand = (scorePct0to1: number) => pctToBand(scorePct0to1);



================================================================================
FILE: C:\Users\DELL\Documents\Gramor_X\lib\skills\readingMiniCloze.ts
================================================================================

import type { ReadingClozeBlank, ReadingClozeSegment } from '@/types/review';

function escapeRegExp(value: string) {
  return value.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
}

function buildReadingSegments(
  template: string,
  tokens: Array<{ id: string; token: string; placeholder: string }>,
): ReadingClozeSegment[] {
  const segments: ReadingClozeSegment[] = [];
  let cursor = 0;

  tokens.forEach((entry) => {
    const index = template.indexOf(entry.token, cursor);
    if (index === -1) {
      return;
    }

    const slice = template.slice(cursor, index);
    if (slice) {
      segments.push({ type: 'text', content: slice });
    }

    segments.push({ type: 'blank', id: entry.id, placeholder: entry.placeholder });
    cursor = index + entry.token.length;
  });

  if (cursor < template.length) {
    segments.push({ type: 'text', content: template.slice(cursor) });
  }

  return segments;
}

function selectTopic(word: any) {
  if (!word) return null;
  const topics = Array.isArray(word.ielts_topics) ? word.ielts_topics : [];
  return topics.length > 0 ? topics[0] : null;
}

export interface ReadingMiniClozePayload {
  passage: string;
  segments: ReadingClozeSegment[];
  blanks: ReadingClozeBlank[];
  headword: string;
  topic: string;
  definition: string;
  suggestedCollocations: string[];
}

export function buildReadingMiniCloze(options: {
  word: any | undefined;
  collocations: any[];
  examples: any[];
}): ReadingMiniClozePayload | null {
  const { word, collocations, examples } = options;
  if (!word) return null;

  const headword = word.headword ?? '';
  const topic = selectTopic(word) ?? 'IELTS Task 2';
  const definition = word.definition ?? 'describe the idea clearly';
  const collocationChunks = collocations
    .map((row) => row?.chunk)
    .filter((chunk: any): chunk is string => typeof chunk === 'string');

  const suggestedCollocations = collocationChunks.slice(0, 3);
  while (suggestedCollocations.length < 3) {
    suggestedCollocations.push(`use ${headword}`);
  }

  const readingCollocationOne = suggestedCollocations[0];
  const readingCollocationTwo = suggestedCollocations[1] ?? suggestedCollocations[0];
  const exampleSentence = examples[1]?.text ?? `This ensures you can ${readingCollocationTwo} during the exam.`;

  const blankTokens = [
    { id: 'blank-headword', token: '__BLANK_HEADWORD__', placeholder: 'Blank 1', answer: headword, label: 'Headword' },
    {
      id: 'blank-collocation-1',
      token: '__BLANK_COLLOC_ONE__',
      placeholder: 'Blank 2',
      answer: readingCollocationOne,
      label: 'Collocation 1',
    },
    {
      id: 'blank-collocation-2',
      token: '__BLANK_COLLOC_TWO__',
      placeholder: 'Blank 3',
      answer: readingCollocationTwo,
      label: 'Collocation 2',
    },
  ];

  const readingTemplate = [
    `IELTS passages about ${topic} often rely on ${blankTokens[0].token} to ${definition}.`,
    `Writers sound fluent when they use ${blankTokens[1].token} in introductions.`,
    `Link your ideas by pairing ${blankTokens[2].token}. ${exampleSentence}`,
  ].join(' ');

  const readingSegments = buildReadingSegments(
    readingTemplate,
    blankTokens.map((token) => ({ id: token.id, token: token.token, placeholder: token.placeholder })),
  );
  const readingPassage = blankTokens.reduce(
    (acc, token) => acc.replace(new RegExp(escapeRegExp(token.token), 'g'), '_____'),
    readingTemplate,
  );

  return {
    passage: readingPassage,
    segments: readingSegments,
    blanks: blankTokens.map((token) => ({ id: token.id, label: token.label, answer: token.answer })),
    headword,
    topic,
    definition,
    suggestedCollocations,
  };
}



================================================================================
FILE: C:\Users\DELL\Documents\Gramor_X\features\mock-reading\ReadingReviewView.tsx
================================================================================

import React, { useEffect, useMemo, useState } from 'react';
import Link from 'next/link';
import { useRouter } from 'next/router';
import { supabaseBrowser as supabase } from '@/lib/supabaseBrowser';
import { getAnswerText, type ReadingAnswer } from '@/lib/reading/answers';

type QType = 'tfng' | 'yynn' | 'heading' | 'match' | 'mcq' | 'gap';
type Q = { id: string; type: QType; prompt?: string; options?: string[]; answer: string; explanation?: string };
type Passage = { id: string; title: string; text: string; questions: Q[] };
type ReadingPaper = { id: string; title: string; passages: Passage[] };

type Attempt = { id: string; answers: Record<string, ReadingAnswer>; score: number; total: number; percentage: number; submitted_at: string };
type AttemptRecord = Attempt & { paper_id?: string | null };

const sampleReading: ReadingPaper = {
  id: 'sample-001',
  title: 'Reading Sample 001',
  passages: [
    {
      id: 'P1',
      title: 'The Honeybee',
      text: 'Bees are fascinatingâ€¦',
      questions: [
        {
          id: 'q1',
          type: 'tfng',
          prompt: 'Bees can see UV light.',
          answer: 'True',
          explanation: 'Bees have UV vision.'
        },
        {
          id: 'q2',
          type: 'yynn',
          prompt: 'Honey is spicy.',
          answer: 'No',
          explanation: 'Honey is sweet.'
        },
        {
          id: 'q3',
          type: 'heading',
          prompt: 'Choose paragraph heading',
          options: ['Origins', 'Vision', 'Diet'],
          answer: 'Vision',
          explanation: 'The paragraph describes visual capability.'
        }
      ]
    },
    {
      id: 'P2',
      title: 'Ancient Roads',
      text: 'Roads enabled tradeâ€¦',
      questions: [
        {
          id: 'q4',
          type: 'match',
          prompt: 'Match A with B',
          options: ['Roman', 'Silk', 'Inca'],
          answer: 'Roman',
          explanation: 'Describes Roman roads.'
        },
        {
          id: 'q5',
          type: 'mcq',
          prompt: 'Pick one',
          options: ['A', 'B', 'C'],
          answer: 'C',
          explanation: 'Option C aligns with text.'
        }
      ]
    }
  ]
};

const loadPaper = async (id: string): Promise<ReadingPaper> => {
  try {
    const mod = await import(`@/data/reading/${id}.json`);
    return mod.default as ReadingPaper;
  } catch {
    return sampleReading;
  }
};

const normalizeAttemptAnswers = (input: unknown): Record<string, ReadingAnswer> => {
  if (!input || typeof input !== 'object') return {};
  const result: Record<string, ReadingAnswer> = {};
  Object.entries(input as Record<string, unknown>).forEach(([key, value]) => {
    if (typeof key !== 'string') return;
    if (typeof value === 'string') {
      result[key] = { value, flagged: false };
      return;
    }
    if (value && typeof value === 'object') {
      const record = value as { value?: unknown; flagged?: unknown };
      const raw = record.value;
      const normalizedValue = typeof raw === 'string' ? raw : raw == null ? '' : String(raw);
      result[key] = { value: normalizedValue, flagged: record.flagged === true };
      return;
    }
    result[key] = { value: '', flagged: false };
  });
  return result;
};

const Shell: React.FC<{
  title: string;
  right?: React.ReactNode;
  children: React.ReactNode;
  mainClassName?: string;
}> = ({ title, right, children, mainClassName }) => (
  <div className="min-h-screen bg-background text-foreground">
    <a
      href="#main-content"
      className="sr-only focus:not-sr-only focus:absolute focus:left-4 focus:top-4 focus:z-50 focus:rounded focus:bg-background focus:px-3 focus:py-2"
    >
      Skip to main content
    </a>
    <div className="mx-auto max-w-6xl px-4 py-6">
      <header className="mb-4 flex flex-wrap items-center justify-between gap-4" role="banner">
        <h1 className="text-h3 font-semibold" id="review-page-heading">
          {title}
        </h1>
        {right ? (
          <div aria-live="polite" className="flex items-center gap-3">
            {right}
          </div>
        ) : null}
      </header>
      <main id="main-content" aria-labelledby="review-page-heading" className={mainClassName || 'grid gap-6'}>
        {children}
      </main>
    </div>
  </div>
);

const ReadingReviewView: React.FC = () => {
  const router = useRouter();
  const { id: routePaperId, paperId: queryPaperId, attempt, attemptId } = router.query as {
    id?: string | string[];
    paperId?: string | string[];
    attempt?: string | string[];
    attemptId?: string | string[];
  };
  const resolvedAttemptId =
    typeof attemptId === 'string'
      ? attemptId
      : typeof attempt === 'string'
        ? attempt
        : undefined;
  const routerReady = router.isReady;

  const [paperId, setPaperId] = useState<string | null>(null);
  const [paper, setPaper] = useState<ReadingPaper | null>(null);
  const [att, setAtt] = useState<Attempt | null>(null);
  const [attemptState, setAttemptState] = useState<'idle' | 'loading' | 'ready' | 'error'>('idle');

  useEffect(() => {
    if (typeof routePaperId === 'string') {
      setPaperId(routePaperId);
    } else if (Array.isArray(routePaperId) && routePaperId[0]) {
      setPaperId(routePaperId[0]);
    }
  }, [routePaperId]);

  useEffect(() => {
    if (typeof queryPaperId === 'string') {
      setPaperId(queryPaperId);
    } else if (Array.isArray(queryPaperId) && queryPaperId[0]) {
      setPaperId(queryPaperId[0]);
    }
  }, [queryPaperId]);

  useEffect(() => {
    if (!paperId) return;
    let cancelled = false;
    (async () => {
      const loaded = await loadPaper(paperId);
      if (!cancelled) {
        setPaper(loaded);
      }
    })();
    return () => {
      cancelled = true;
    };
  }, [paperId]);

  useEffect(() => {
    if (!routerReady) return;
    if (!resolvedAttemptId) {
      if (attemptState === 'idle') {
        setAttemptState('error');
      }
      return;
    }

    let cancelled = false;
    const fetchAttempt = async () => {
      setAttemptState('loading');
      try {
        const { data } = await supabase
          .from('attempts_reading')
          .select('*')
          .eq('id', resolvedAttemptId)
          .single();
        if (!cancelled && data) {
          const record = data as AttemptRecord & { paper_id?: string | null; score_json?: any };
          const payload = record.score_json && typeof record.score_json === 'object' ? record.score_json : record;
          const answers = normalizeAttemptAnswers(payload.answers);
          const correct = Number(payload?.correct ?? payload?.score ?? record.score ?? 0);
          const total = Number(payload?.total ?? record.total ?? 0);
          const percentage = Number(payload?.percentage ?? record.percentage ?? 0);
          setAtt({
            id: String(record.id ?? resolvedAttemptId),
            answers,
            score: Number.isFinite(correct) ? correct : 0,
            total: Number.isFinite(total) ? total : 0,
            percentage: Number.isFinite(percentage) ? percentage : 0,
            submitted_at: record.submitted_at ?? new Date().toISOString()
          });
          const paperIdFromRecord = record.paper_id ?? undefined;
          if (paperIdFromRecord) {
            setPaperId((prev) => (prev === paperIdFromRecord ? prev : paperIdFromRecord));
          }
          setAttemptState('ready');
          return;
        }
      } catch {
        // ignore supabase errors and fall back to local storage
      }

      if (cancelled) return;

      if (typeof window !== 'undefined') {
        try {
          const raw = window.localStorage.getItem(`read:attempt-res:${resolvedAttemptId}`);
          if (raw) {
            const parsed = JSON.parse(raw);
            const answers = normalizeAttemptAnswers(parsed.answers);
            const passages = (parsed.paper?.passages ?? []) as Passage[];
            const flat: Q[] = passages.flatMap((p) => p.questions || []);
            const total = flat.length;
            let score = 0;
            for (const q of flat) {
              if (getAnswerText(answers[q.id]).trim().toLowerCase() === (q.answer ?? '').trim().toLowerCase()) score++;
            }
            setAtt({
              id: resolvedAttemptId,
              answers,
              score,
              total,
              percentage: total ? Math.round((score / total) * 100) : 0,
              submitted_at: parsed.submitted_at ?? new Date().toISOString()
            });
            if (parsed.paper?.id) {
              setPaperId((prev) => prev ?? parsed.paper.id);
            }
            setAttemptState('ready');
            return;
          }
        } catch {
          // local storage unavailable
        }
      }

      if (!cancelled) {
        setAttemptState('error');
      }
    };

    void fetchAttempt();

    return () => {
      cancelled = true;
    };
  }, [routerReady, resolvedAttemptId, attemptState]);

  useEffect(() => {
    if (attemptState === 'error') {
      setPaperId((prev) => prev ?? 'sample-001');
    }
  }, [attemptState]);

  useEffect(() => {
    if (attemptState !== 'error' || att || !paper) return;
    const flat = paper.passages.flatMap((p) => p.questions || []);
    setAtt({
      id: resolvedAttemptId ?? 'demo-attempt',
      answers: {},
      score: 0,
      total: flat.length,
      percentage: 0,
      submitted_at: new Date().toISOString()
    });
    setAttemptState('ready');
  }, [attemptState, att, paper, resolvedAttemptId]);

  useEffect(() => {
    if (!paperId) return;
    void router.prefetch('/mock/reading/[id]', `/mock/reading/${paperId}`);
  }, [paperId, router]);

  const flatQs = useMemo(() => paper?.passages.flatMap((p) => p.questions) ?? [], [paper]);

  const statsByType = useMemo(() => {
    if (!paper || !att) return [] as { type: string; correct: number; total: number; pct: number }[];
    const map: Record<string, { correct: number; total: number }> = {};
    for (const q of flatQs) {
      const key = q.type;
      map[key] ??= { correct: 0, total: 0 };
      map[key].total++;
      const ok = getAnswerText(att.answers?.[q.id]).trim().toLowerCase() === (q.answer ?? '').trim().toLowerCase();
      if (ok) map[key].correct++;
    }
    return Object.entries(map).map(([type, { correct, total }]) => ({
      type,
      correct,
      total,
      pct: total ? Math.round((correct / total) * 100) : 0
    }));
  }, [paper, att, flatQs]);

  if (!paper || !att) {
    return (
      <Shell title="Review â€” Loadingâ€¦" mainClassName="grid gap-6">
        <div className="rounded-2xl border border-border p-4" role="status" aria-live="polite">
          Loadingâ€¦
        </div>
      </Shell>
    );
  }

  return (
    <Shell
      title={`Review â€” ${paper.title}`}
      right={
        <div className="rounded-full border border-border px-3 py-1 text-small" role="status" aria-live="polite">
          Score: {att.score}/{att.total} ({att.percentage}%)
        </div>
      }
      mainClassName="grid gap-6"
    >
      <section className="rounded-2xl border border-border p-4" aria-labelledby="performance-heading">
        <h2 id="performance-heading" className="mb-2 text-body font-semibold">
          Performance by question type
        </h2>
        <div className="grid gap-2 sm:grid-cols-2 md:grid-cols-3" role="list">
          {statsByType.length > 0 ? (
            statsByType.map((s) => (
              <article
                key={s.type}
                role="listitem"
                className="rounded-lg border border-border p-3 text-small"
                aria-label={`${labelType(s.type)}: ${s.correct} of ${s.total} correct (${s.pct} percent)`}
              >
                <div className="font-medium">{labelType(s.type)}</div>
                <div className="text-foreground/80">{s.correct}/{s.total} correct â€¢ {s.pct}%</div>
              </article>
            ))
          ) : (
            <p className="text-small text-foreground/80">No responses recorded.</p>
          )}
        </div>
      </section>

      <section className="rounded-2xl border border-border p-4" aria-labelledby="answers-heading">
        <h2 id="answers-heading" className="mb-2 text-body font-semibold">
          Answers &amp; explanations
        </h2>
        <div className="grid gap-3">
          {flatQs.map((q, idx) => {
            const promptId = `review-question-${q.id}`;
            const explanationId = q.explanation ? `review-question-${q.id}-explanation` : undefined;
            const given = getAnswerText(att.answers?.[q.id]).trim();
            const ok = given.toLowerCase() === (q.answer ?? '').trim().toLowerCase();
            return (
              <article
                key={q.id}
                className="rounded-lg border border-border p-3"
                aria-labelledby={promptId}
                aria-describedby={explanationId}
              >
                <h3 id={promptId} className="mb-1 text-small font-medium text-foreground/80">
                  Q{idx + 1}. {q.prompt || q.id}
                </h3>
                <dl className="space-y-1 text-small">
                  <div className="flex flex-wrap items-center gap-2">
                    <dt className="sr-only">Result</dt>
                    <dd>
                      <span
                        className={`inline-flex items-center rounded px-2 py-0.5 text-background ${ok ? 'bg-primary' : 'bg-border text-foreground'}`}
                        aria-label={ok ? 'Answer correct' : 'Answer incorrect'}
                      >
                        {ok ? 'Correct' : 'Wrong'}
                      </span>
                    </dd>
                  </div>
                  <div className="flex flex-wrap gap-2">
                    <dt className="font-medium">Your answer:</dt>
                    <dd>
                      <strong>{given || 'â€”'}</strong>
                    </dd>
                  </div>
                  {!ok && (
                    <div className="flex flex-wrap gap-2">
                      <dt className="font-medium">Correct answer:</dt>
                      <dd>
                        <strong>{q.answer}</strong>
                      </dd>
                    </div>
                  )}
                </dl>
                {q.explanation && (
                  <p id={explanationId} className="mt-2 text-small text-foreground/80">
                    {q.explanation}
                  </p>
                )}
              </article>
            );
          })}
        </div>
      </section>

      <div className="flex flex-col gap-3 sm:flex-row sm:items-center sm:justify-between">
        <Link href="/reading" prefetch className="text-small underline underline-offset-4">
          Try another reading
        </Link>
        <Link
          href="/dashboard"
          prefetch
          className="rounded-xl border border-border px-4 py-2 transition hover:border-primary focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 focus-visible:ring-offset-background"
        >
          Go to dashboard
        </Link>
      </div>
    </Shell>
  );
};

const labelType = (t: string) =>
  t === 'tfng'
    ? 'True/False/Not Given'
    : t === 'yynn'
      ? 'Yes/No/Not Given'
      : t === 'heading'
        ? 'Headings'
        : t === 'match'
          ? 'Matching'
          : t === 'mcq'
            ? 'Multiple Choice'
            : 'Gap Fill';

export default ReadingReviewView;



