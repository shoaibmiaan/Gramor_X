===== File #1: pages/api/mistakes/categorize.ts =====
export default async function mistakesCategorizeHandler(req: NextApiRequest, res: NextApiResponse) {
  if (req.method !== 'POST') return res.status(405).json({ error: 'Method not allowed' });
  const { id, action } = req.body ?? {};
  if (!id) return res.status(400).json({ error: 'Missing id' });

  try {
    if (action === 'toggle_resolved') {
      // fetch current
      const { data, error } = await SUPABASE.from('mistakes_book').select('resolved').eq('id', id).maybeSingle();
      if (error) throw error;
      const cur = data?.resolved ?? false;
      const { error: up } = await SUPABASE.from('mistakes_book').update({ resolved: !cur }).eq('id', id);
      if (up) throw up;
      return res.status(200).json({ success: true });
    }

    // Other categories / tags could be supported here
    return res.status(400).json({ error: 'Unknown action' });
  } catch (e: any) {
    console.error('mistakes categorize', e);
    return res.status(500).json({ error: e?.message ?? 'Failed' });
  }
}


===== File #2: pages/api/mistakes/index.ts =====
import type { NextApiRequest, NextApiResponse } from 'next';

import { createSupabaseServerClient } from '@/lib/supabaseServer';
import { scheduleSpacedReview } from '@/lib/experiments/spaced-intervals';

type MistakeRow = {
  id: string;
  mistake: string;
  correction: string | null;
  type: string | null;
  repetitions: number | null;
  next_review: string | null;
  retry_path: string | null;
  created_at: string;
  last_seen_at?: string | null;
  resolved_at?: string | null;
};

type MistakeTag = { key: string; value: string };

type MistakePayload = {
  id: string;
  prompt: string;
  correction: string | null;
  skill: string;
  repetitions: number;
  nextReview: string | null;
  retryPath: string | null;
  createdAt: string;
  lastSeenAt: string;
  resolvedAt: string | null;
  tags: MistakeTag[];
};

const FALLBACK_CODES = new Set(['42P01', '42703']);

export default async function handler(req: NextApiRequest, res: NextApiResponse) {
  const supabase = createSupabaseServerClient({ req });

  const {
    data: { user },
  } = await supabase.auth.getUser();
  if (!user) {
    return res.status(401).json({ error: 'Unauthorized' });
  }

  if (req.method === 'GET') {
    const limit = Math.min(Number(req.query.limit) || 10, 50);
    const cursor = typeof req.query.cursor === 'string' ? req.query.cursor : null;
    const since = new Date();
    since.setDate(since.getDate() - 30);
    const sinceIso = since.toISOString();

    const selectCols =
      'id,mistake,correction,type,repetitions,next_review,retry_path,created_at,last_seen_at,resolved_at';

    let query = supabase
      .from('mistake_review_queue')
      .select(selectCols)
      .eq('user_id', user.id)
      .is('resolved_at', null)
      .gte('created_at', sinceIso)
      .order('created_at', { ascending: false })
      .limit(limit + 1);

    if (cursor) {
      query = query.lt('created_at', cursor);
    }

    let { data, error } = await query;
    let rows = (data as MistakeRow[]) ?? [];

    if (error && FALLBACK_CODES.has(error.code ?? '')) {
      // Older databases might not have the view yet. Fall back to the raw table.
      let fallback = supabase
        .from('mistakes_book')
        .select('id,mistake,correction,type,repetitions,next_review,retry_path,created_at,last_seen_at')
        .eq('user_id', user.id)
        .gte('created_at', sinceIso)
        .order('created_at', { ascending: false })
        .limit(limit + 1);
      if (cursor) fallback = fallback.lt('created_at', cursor);

      const fallbackResult = await fallback;
      error = fallbackResult.error;
      rows = (fallbackResult.data as MistakeRow[]) ?? [];

      if (!error) {
        const { data: resolvedData } = await supabase
          .from('mistake_resolutions')
          .select('mistake_id')
          .eq('user_id', user.id);
        if (resolvedData?.length) {
          const resolvedIds = new Set(resolvedData.map((row: { mistake_id: string }) => row.mistake_id));
          rows = rows.filter((row) => !resolvedIds.has(row.id));
        }
      }
    }

    if (error) {
      return res.status(500).json({ error: error.message });
    }

    const hasMore = rows.length > limit;
    const trimmed = hasMore ? rows.slice(0, limit) : rows;
    const items = trimmed.map(mapRow).filter((item): item is MistakePayload => item !== null);
    const nextCursor = hasMore ? trimmed[trimmed.length - 1]?.created_at ?? null : null;

    return res.status(200).json({ items, nextCursor });
  }

  if (req.method === 'POST') {
    const { mistake, correction, type, retryPath } = req.body as {
      mistake?: string;
      correction?: string;
      type?: string;
      retryPath?: string | null;
    };
    if (!mistake) {
      return res.status(400).json({ error: 'Missing mistake' });
    }
    const { data, error } = await supabase
      .from('mistakes_book')
      .insert({ user_id: user.id, mistake, correction, type, retry_path: retryPath ?? null })
      .select()
      .single();
    if (error) return res.status(500).json({ error: error.message });
    return res.status(201).json(mapRow(data as MistakeRow));
  }

  if (req.method === 'PUT') {
    const { id, repetitions } = req.body as { id?: string; repetitions?: number };
    if (!id) {
      return res.status(400).json({ error: 'Missing id' });
    }
    const nextReps = Number.isFinite(repetitions) ? Math.max(0, Math.floor(repetitions as number)) : 0;
    const nextReview = await scheduleSpacedReview(user.id, nextReps);
    const payload = {
      repetitions: nextReps,
      next_review: nextReview.toISOString(),
      last_seen_at: new Date().toISOString(),
    };
    const { data, error } = await supabase
      .from('mistakes_book')
      .update(payload)
      .eq('id', id)
      .eq('user_id', user.id)
      .select()
      .single();
    if (error) return res.status(500).json({ error: error.message });
    return res.status(200).json(mapRow(data as MistakeRow));
  }

  if (req.method === 'PATCH') {
    const { id, resolved } = req.body as { id?: string; resolved?: boolean };
    if (!id) {
      return res.status(400).json({ error: 'Missing id' });
    }

    if (resolved) {
      const { error } = await supabase
        .from('mistake_resolutions')
        .upsert({ user_id: user.id, mistake_id: id, resolved_at: new Date().toISOString() });
      if (error && error.code !== '23505') {
        return res.status(500).json({ error: error.message });
      }
    } else {
      const { error } = await supabase
        .from('mistake_resolutions')
        .delete()
        .eq('user_id', user.id)
        .eq('mistake_id', id);
      if (error) {
        return res.status(500).json({ error: error.message });
      }
    }

    const { data, error } = await supabase
      .from('mistake_review_queue')
      .select(
        'id,mistake,correction,type,repetitions,next_review,retry_path,created_at,last_seen_at,resolved_at',
      )
      .eq('user_id', user.id)
      .eq('id', id)
      .maybeSingle();

    if (error) {
      return res.status(500).json({ error: error.message });
    }

    return res.status(200).json({ item: mapRow(data as MistakeRow | null) });
  }

  if (req.method === 'DELETE') {
    const { id } = req.body as { id?: string };
    if (!id) {
      return res.status(400).json({ error: 'Missing id' });
    }
    const { error } = await supabase
      .from('mistakes_book')
      .delete()
      .eq('id', id)
      .eq('user_id', user.id);
    if (error) return res.status(500).json({ error: error.message });
    return res.status(200).json({ success: true });
  }

  res.setHeader('Allow', 'GET,POST,PUT,PATCH,DELETE');
  return res.status(405).end('Method Not Allowed');
}

function mapRow(row: MistakeRow | null | undefined): MistakePayload | null {
  if (!row) return null;
  const { retryPath, tags } = parseRetryPath(row.retry_path ?? null);
  return {
    id: row.id,
    prompt: row.mistake,
    correction: row.correction ?? null,
    skill: row.type ?? 'general',
    repetitions: row.repetitions ?? 0,
    nextReview: row.next_review ?? null,
    retryPath,
    createdAt: row.created_at,
    lastSeenAt: row.last_seen_at ?? row.created_at,
    resolvedAt: row.resolved_at ?? null,
    tags,
  };
}

function parseRetryPath(raw: string | null): { retryPath: string | null; tags: MistakeTag[] } {
  if (!raw) return { retryPath: null, tags: [] };

  try {
    const url = new URL(raw, raw.startsWith('http') ? raw : `https://mistakes.local${raw.startsWith('/') ? '' : '/'}${raw}`);
    const cleanParams = new URLSearchParams();
    const tags: MistakeTag[] = [];

    url.searchParams.forEach((value, key) => {
      if (key.toLowerCase() === 'tag') {
        const parsed = decodeTag(value);
        if (parsed) tags.push(parsed);
      } else {
        cleanParams.append(key, value);
      }
    });

    const search = cleanParams.toString();
    const retryPath = `${url.pathname}${search ? `?${search}` : ''}${url.hash}`;
    return { retryPath, tags };
  } catch {
    return { retryPath: raw, tags: [] };
  }
}

function decodeTag(input: string): MistakeTag | null {
  if (!input) return null;
  const [rawKey, ...rest] = input.split(':');
  const value = rest.join(':').trim();
  if (!value) return null;
  const key = prettifyTagKey(rawKey || 'Tag');
  return { key, value };
}

function prettifyTagKey(raw: string): string {
  return raw
    .split(/[\s_\-|]+/)
    .filter(Boolean)
    .map((part) => part.charAt(0).toUpperCase() + part.slice(1))
    .join(' ');
}


===== File #3: pages/api/mistakes/add.ts =====
import type { NextApiRequest, NextApiResponse } from 'next';
import { z } from 'zod';

import { createSupabaseServerClient } from '@/lib/supabaseServer';

type ModuleKey = 'listening' | 'reading' | 'writing' | 'speaking';

const TagSchema = z.object({
  key: z.string().trim().min(1).max(40),
  value: z.string().trim().min(1).max(120),
});

const MistakeSchema = z.object({
  questionId: z.string().trim().min(1).max(64),
  prompt: z.string().trim().min(1).max(240),
  correctAnswer: z.string().trim().max(240).optional().nullable(),
  givenAnswer: z.string().trim().max(240).optional().nullable(),
  retryPath: z.string().trim().max(240).optional().nullable(),
  skill: z.string().trim().max(64).optional(),
  tags: z.array(TagSchema).max(8).optional(),
});

const BodySchema = z.object({
  attemptId: z.string().trim().min(1).max(64),
  module: z.enum(['listening', 'reading', 'writing', 'speaking']),
  paperId: z.string().trim().max(64).optional(),
  mistakes: z.array(MistakeSchema).max(60),
});

type TagInput = z.infer<typeof TagSchema>;

type ResponseBody =
  | { ok: true; inserted: number; skipped: number; insertedIds?: string[] }
  | { ok: false; error: string };

export default async function handler(
  req: NextApiRequest,
  res: NextApiResponse<ResponseBody>,
) {
  if (req.method !== 'POST') {
    res.setHeader('Allow', 'POST');
    return res.status(405).json({ ok: false, error: 'method_not_allowed' });
  }

  let parsed;
  try {
    parsed = BodySchema.parse(req.body ?? {});
  } catch (error) {
    const message =
      error instanceof z.ZodError
        ? error.issues[0]?.message ?? 'invalid_payload'
        : 'invalid_payload';
    return res.status(400).json({ ok: false, error: message });
  }

  if (!parsed.mistakes.length) {
    return res.status(200).json({ ok: true, inserted: 0, skipped: 0, insertedIds: [] });
  }

  const supabase = createSupabaseServerClient({ req, res });
  const { data: auth } = await supabase.auth.getUser();
  const user = auth?.user;

  if (!user) {
    return res.status(401).json({ ok: false, error: 'unauthorized' });
  }

  // Prepare items: dedupe tags, normalise retryPath (and attach tags to retryPath query)
  const prepared = parsed.mistakes.map((item) => {
    const tags = dedupeTags(item.tags ?? []);
    const basePath = normaliseBasePath(
      item.retryPath,
      parsed.module,
      parsed.paperId,
      item.questionId,
    );
    const retryPath = attachTags(basePath, tags);

    // tagsForInsert: array of 'key:value' strings (Postgres text[])
    const tagsForInsert = tags.map((t) => `${t.key}:${t.value}`);

    return {
      questionId: item.questionId,
      prompt: item.prompt,
      correction: item.correctAnswer?.trim() ?? null,
      skill: item.skill?.trim() || parsed.module,
      retryPath,
      tags: tagsForInsert,
    };
  });

  // Find unique retry paths to detect existing rows
  const uniquePaths = Array.from(
    new Set(
      prepared
        .map((p) => p.retryPath)
        .filter((path): path is string => Boolean(path)),
    ),
  );

  // Find existing rows by retry_path for this user
  const existingPaths = new Set<string>();
  if (uniquePaths.length > 0) {
    const { data: existing, error: fetchErr } = await supabase
      .from('mistakes_book')
      .select('retry_path')
      .eq('user_id', user.id)
      .in('retry_path', uniquePaths);

    if (fetchErr) {
      // Non-fatal: log and continue — we'll treat as no existing rows (but surface an error if insert fails)
      // eslint-disable-next-line no-console
      console.error('failed to fetch existing retry paths', fetchErr);
    } else {
      (existing ?? []).forEach((row: { retry_path: string | null }) => {
        if (row.retry_path) existingPaths.add(row.retry_path);
      });
    }
  }

  // Fresh items are those without retryPath OR whose retryPath not in existingPaths
  const freshItems = prepared.filter(
    (item) => !item.retryPath || !existingPaths.has(item.retryPath),
  );

  const now = new Date().toISOString();

  // Update last_seen_at for matches (if any)
  if (existingPaths.size > 0) {
    const { error: updateErr } = await supabase
      .from('mistakes_book')
      .update({ last_seen_at: now })
      .eq('user_id', user.id)
      .in('retry_path', Array.from(existingPaths));

    if (updateErr) {
      // Non-fatal but log it
      // eslint-disable-next-line no-console
      console.error('failed to update last_seen_at for existing mistakes', updateErr);
    }
  }

  // Insert fresh items, persist tags into tags column (text[])
  let inserted = 0;
  const insertedIds: string[] = [];

  if (freshItems.length > 0) {
    const insertPayload = freshItems.map((item) => ({
      user_id: user.id,
      // keep field names similar to your system: 'mistake' stores prompt text
      mistake: item.prompt,
      correction: item.correction,
      type: item.skill,
      retry_path: item.retryPath ?? null,
      tags: item.tags && item.tags.length ? item.tags : null, // Postgres text[] or null
      last_seen_at: now,
      created_at: now,
    }));

    const { error: insertError, data } = await supabase
      .from('mistakes_book')
      .insert(insertPayload)
      .select('id');

    if (insertError) {
      // Surface error — this is a real failure
      // eslint-disable-next-line no-console
      console.error('insert mistakes failed', insertError);
      return res.status(500).json({ ok: false, error: insertError.message });
    }

    inserted = (data?.length ?? 0);
    if (Array.isArray(data)) {
      // data items are { id: ... } shape
      data.forEach((row: any) => {
        if (row?.id) insertedIds.push(row.id);
      });
    }
  }

  const skipped = parsed.mistakes.length - inserted;
  return res.status(200).json({ ok: true, inserted, skipped, insertedIds });
}

/* ---------- helpers (kept from your original with small tweaks) ---------- */

function dedupeTags(tags: TagInput[]): TagInput[] {
  const seen = new Set<string>();
  const result: TagInput[] = [];

  tags.forEach((tag) => {
    const key = tag.key.trim();
    const value = tag.value.trim();
    if (!key || !value) return;
    const signature = `${key.toLowerCase()}::${value.toLowerCase()}`;
    if (seen.has(signature)) return;
    seen.add(signature);
    result.push({ key, value });
  });

  return result;
}

function normaliseBasePath(
  retryPath: string | null | undefined,
  module: ModuleKey,
  paperId: string | undefined,
  questionId: string,
): string {
  const fallbackBase = paperId ? `/mock/${module}/${paperId}` : `/mock/${module}`;
  const base = retryPath && retryPath.trim() ? retryPath.trim() : `${fallbackBase}?focus=${encodeURIComponent(questionId)}`;

  try {
    const url = new URL(base, base.startsWith('http') ? base : `https://mistakes.local${base.startsWith('/') ? '' : '/'}${base}`);
    return `${url.pathname}${url.search}${url.hash}`;
  } catch {
    return base;
  }
}

function attachTags(path: string, tags: TagInput[]): string {
  if (!path) return path;

  try {
    const url = new URL(path, path.startsWith('http') ? path : `https://mistakes.local${path.startsWith('/') ? '' : '/'}${path}`);
    tags.forEach((tag) => {
      url.searchParams.append('tag', `${tag.key}:${tag.value}`);
    });
    const search = url.searchParams.toString();
    return `${url.pathname}${search ? `?${search}` : ''}${url.hash}`;
  } catch {
    const query = tags
      .map((tag) => `tag=${encodeURIComponent(`${tag.key}:${tag.value}`)}`)
      .join('&');
    if (!query) return path;
    return path.includes('?') ? `${path}&${query}` : `${path}?${query}`;
  }
}


===== File #4: pages/api/mistakes/list.ts =====
export default async function mistakesListHandler(req: NextApiRequest, res: NextApiResponse) {
  const userId = (req.query.userId as string) || null;
  try {
    const { data, error } = await SUPABASE.from('mistakes_book').select('*').eq('user_id', userId).order('created_at', { ascending: false });
    if (error) throw error;
    return res.status(200).json(data ?? []);
  } catch (e: any) {
    console.error('mistakes list', e);
    return res.status(500).json({ error: e?.message ?? 'Failed to load' });
  }
}


